* 函数、闭包与迭代器
  语言影响或觉得人类的思维方式.org
  Rust 是一门混合范式的编程语言, 有机地融合了面向对象、函数式和方向编程范式. 它
  并非将这些特性进行简单堆砌, 而是通过高度一致性的类型系统融合了这三种范式的编程
  思想. 可以通过 ~impl~ 关键字配合结构体和 trait 来实现面向对象范式中的多态和封
  装, 也可以通过函数、高阶函数、闭包、模式匹配来实现函数式范式中的一些编程工具.
  Rust 支持 0 成本静态分发的泛型编程, 并且将它很好地融入了其他两种编程范式中, 提
  供了更高的抽象层次. 通过将这三种编程范式完美融合起来, Rust 语言拥有了更高程度
  的抽象以及更强的表达能力.

  函数式语言的历史要比面向对象语言悠久, 它源自古老的 LISP 语言, 其后发明的语言或
  多或少都受到了函数式编程思想的影响, eg: Python, Ruby, 以及更纯的函数式语言
  HasKell. 随着摩尔定律的失效, CPU 性能的提升转为主要依赖核数的增加, 多核时代到
  来后, 函数式编程因为其天生对并发友好的特性又逐渐受到了重视. 所以近年来很多新诞
  生的语言也吸收了函数式范式的诸多特性, eg: Elixir, Scala, Swift 都收到了 LISP
  和 HasKell 的影响, 对代数数据类型(algebraic data type)、模式匹配、高阶函数、闭
  包等特性各有所支持. 甚至一些年代久远的主流语言, eg: C++ 和 Java 也都开始吸收函
  数式语言的特性. Rust 作为一门在多核时代诞生的现代编程语言, 引入函数式编程范式
  完全是顺势而为的.

  本章内容主要从函数和闭包 2 个方面来探讨 Rust 对函数式编程范式的支持, 还会讲迭
  代器及其在闭包中的应用.
  
** 函数
   对于一段重复执行的代码, 可以将其定义为一个函数, 方便调用.

   *fn* 关键字后面为函数名称, 通常以 *蛇形命名法(snake_case)* 命名, 否则编译器会
   发出警告. 函数参数必须明确地指定类型, 如果有返回值也必须指定返回值的类型. 需
   要注意的是, Rust 中的函数参数 *不能指定默认值*. 函数体被包含于花括号之内, 出
   函数体之外的函数声明为 *函数签名*. 可以说, 一个函数是由函数签名和函数体组合
   而成的.

   一般来说, 函数定义时不允许直接使用语言中的保留字和关键字作为函数名. 但是在
   *Rust 2018* 中, 通过将原生标识操作符(Raw Identifier) *r#* 作为前缀, 即可使用
   关键字为函数命名, 该语法一般用于 FFI 中, 用于避免 C 函数名和 Rust 的关键字或
   保留字重名而引起的冲突.

   通过前面的张姐我们了解到, 函数 ucanshu 可以按值传递, 也可以按引用传递. 当参数按
   值传递时, 会转移所有权或执行复制(Copy)语义. 当参数按引用传递时, 所有权不会发
   生变化, 但是需要有生命周期参数. 当符合生命周期参数省略规则时, 编译器可以通过
   自动推断补齐参数的生命周期参数, 否则, 需要显示地为参数标明生命周期参数.

   函数参数也分为可变和不可变. Rust 的函数参数默认不可变, 当需要可变操作的时候,
   需要使用 ~mut~ 关键字来修饰.

*** 函数屏蔽
    当声明变量之后, 如果再次声明同名的变量绑定, 则之前的变量绑定会被屏蔽, 这叫做
    变量遮蔽(variable shadow). 变量可以如此, 但 *函数不能被多次定义*.

    可以通过显式地使用花括号将同名的函数分隔到不同的作用域中, 这样编译器就不会报
    错. 也就是说, 在同一个作用域中不能定义多个同名函数, 因为 *默认的函数定义只在
    当前作用域内有效*, 会屏蔽作用域外的同名函数.

*** 函数模式匹配
    函数中的参数等价于一个隐式的 let 绑定, 而 let 绑定本身是一个模式匹配的行为.
    所以函数参数也支持模式匹配.

    参数使用 ~ref~ 关键字来修饰:意味着要使用模式匹配来获取参数的不可变引用. 与
    ~ref~ 相对的是 ~ref mut~, ~ref mut~ 用来匹配可变引用.

    除了 ~ref~ 和 ~ref mut~, 函数参数也可以使用通配符(~_~)来忽略参数.

    实现某个 trait 中的方法时, 有时并不会用到其函数签名中声明的所有权参数, 这时
    可以使用通配符来进行忽略, 这样不会引起编译错误.

    Rust 中的 let 语句可以通过模式匹配解构元组(Tuple), 函数参数也可以. 若只想解
    构元组中的单个值, 则使用通配符将其他值忽略掉即可.

*** 函数返回单元值
    Rust 中的函数只能有唯一的返回值, 即使没有显式返回值的函数, 其实也相当于返回
    了一个单元值 ~()~. 如果乳摇返回多个值, 亦可使用元组类型.

    Rust 语言提供了 ~return~ 关键字来返回函数中的值. 对于只需要返回函数体最后一
    行 表达式所求值的函数, ~return~ 可以省略. 在某些控制结构中, eg: 循环或条件分
    支, 则需要显式地使用 ~return~ 关键字来返回.

    第二张中出现的函数返回类型为 "~!~" 的发散函数(diverging function), 此类函数
    *永远不会有任何返回值*.
    
*** 泛型函数
    Rust 的函数也支持泛型. 通过实现 泛型函数, 可以节省很多工作量.

    当编译器无法自动类型时, 需要显式地指定函数调用的类型, 使用 turbofish 操作符
    ~::<>~ 指定具体类型.

*** 方法与函数
    Rust 中的 *方法和函数是有区别的*. 方法来自面向对象的编程范式, 在语义上, 它代
    表某个实例对象的行为. 函数只是一段简单的代码, 它可以通过名字来进行调用. 方法
    也是通过名字来进行调用的, 但它必须关联一个 *方法接受者*.
    
*** 高阶函数
    在数学和计算机科学里均有高阶函数的定义. 在数学中, 高阶函数也叫算子或泛函.
    eg: 微积分中的导数就是一个函数到另一个函数的映射. 在计算机科学里, 高阶函数是
    指以函数作为参数或返回值的函数, 它也是函数式编程语言最基础的特性. Rust 语言
    也支持高阶函数, 因为函数在 Rust 中是一等公民.
    
    实现这一切的基础在于 Rust 支持类似 C/C++ 语言中的 *函数指针*.
    函数指针:　指向函数的指针, 其值为函数的地址.

    声明函数指针类型时, *必须显式指定函数指针类型 ~fn()~, 以及赋值的是函数名*.

    对于函数指针类型, 可以使用 ~type~ 关键字为其定义别名, 便于提升代码的可读性.

** 闭包
   *闭包(Closure)* 通常是指词法闭包, 是一个持有外部环境变量的函数. *外部环境* 是
   指闭包定义时所在的词法作用域. 外部环境变量, 在函数式编程范式中也被称为 *自由
   变量*, 是指并不是在闭包内定义的变量. *将自由变量和自身绑定的函数就是闭包*.

   *注意*: 此处闭包类型为 ~Fn(i32) -> i32~, 以大写字母 F 开头的 ~Fn~ 并不是函数
   指针类型 ~fn(i32) -> i32~, 它是一个 trait, 本章后面的章节有更详细的介绍.

   闭包包含以下来钟特性:

   - *延迟执行*: 返回的闭包只有在需要调用的时候才会执行
   - *捕获环境变量*: 闭包会获取其定义时所在作用域中的自由变量, 以供之后调用时使
     用.

*** 闭包的基本语法
    Rust 的闭包语法形式参考了 Ruby 语言的 lambda 表达式.

    闭包由 *管道符* (两个对称的竖线)和花括号(或圆括号)组合而成. 管道符里是闭包函
    数的参数, 可以像普通函数参数那样在冒号后面添加类型标注, 也可以省略为以下形
    式:
    #+begin_src rust
      let add = |a, b| -> i32 { a + b };
    #+end_src

    花括号里包含的是闭包函数执行体, 花括号和返回值也可以省略:
    #+begin_src rust
      let add = |a, b| a + b;
    #+end_src

    当闭包函数没有参数只有捕获的自由变量时, 管道符里的参数也可省略:
    #+begin_src rust
      let (a, b) = (1, 2);
      let add = || a + b;
    #+end_src

    闭包的参数可以是任意类型的. 
    
    # Rust 2018 已修复:
    # 但两个定义一模一样的闭包也并不一定属于同一种类型.

*** 闭包的实现
    闭包类型与 Rust 类型系统提供的常规类型不同, 它是由编译器制造的临时存在的闭包
    实例类型.

    *其实在 Rust 中, 闭包是一种语法糖*. 也就是说, 闭包不属于 Rust 语言提供的基本
    语法要素, 而是在基本语法功能之上又提供的一层方便开发者编程的语法. 闭包和普
    通函数的差别就是闭包可以捕获环境中的自由变量.

    若想要实现自己的闭包, 可以使用指针. 闭包 ~||{a + b}~ 的实现可以通过函数指针
    和捕获变量指针组合来实现. 指针放在栈上, 捕获变量放到堆上. 实际上, 早期的
    Rust 版本实现闭包就采用了类似的方式. 因为要把闭包捕获变量放到堆上, 所以称其
    为 *装箱(Boxed)闭包*. 这种方式带来的问题就是影响性能. Rust 是基于 LLVM 的语
    言, 这种闭包实现的方式使得 LLVM 难以对其进行内联和优化.

    
    所以 Rust 团队又对闭包的实现做了重大改进, 也就是当前版本中的闭包实现方式. 改
    进方案为 *非装箱(Unboxed)闭包*, 此方案是 Rust 语言一致性的再一次提现.

    非装箱闭包方案有三个目标:

    - 可以让用户更好地控制优化
    - 支持闭包按值和按引用绑定环境变量
    - 支持三种不同的闭包访问: 对应 ~self~, ~&self~ 和 ~&mut self~ 三种方法

    实现这三个目标的核心思想是: 通过增加 trait 将函数调用变为可重载的操作符.
    eg: 将 ~a(b, c, d)~ 这种函数调用变为如下形式:
    #+begin_src rust
      Fn::call(&a, (b, c, d));
      FnMut::call_mut(&mut a, (b, c, d));
      FnOnce::call_once(a, (b, c, d));
    #+end_src

    Rust 增加的这三个 trait 分别就是 ~Fn~, ~FnMut~ 和 ~FnOnce~.

    在 Rust 源码中的定义如下所示:
    #+begin_src rust
      #[lang = "fn"]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[rustc_paren_sugar]
      #[rustc_on_unimplemented(
          on(
              Args = "()",
              note = "wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}"
          ),
          message = "expected a `{Fn}<{Args}>` closure, found `{Self}`",
          label = "expected an `Fn<{Args}>` closure, found `{Self}`"
      )]
      #[fundamental] // so that regex can rely that `&str: !FnMut`
      #[must_use = "closures are lazy and do nothing unless called"]
      pub trait Fn<Args>: FnMut<Args> {
          /// Performs the call operation.
          #[unstable(feature = "fn_traits", issue = "29625")]
          extern "rust-call" fn call(&self, args: Args) -> Self::Output;
      }

      #[lang = "fn_mut"]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[rustc_paren_sugar]
      #[rustc_on_unimplemented(
          on(
              Args = "()",
              note = "wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}"
          ),
          message = "expected a `{FnMut}<{Args}>` closure, found `{Self}`",
          label = "expected an `FnMut<{Args}>` closure, found `{Self}`"
      )]
      #[fundamental] // so that regex can rely that `&str: !FnMut`
      #[must_use = "closures are lazy and do nothing unless called"]
      pub trait FnMut<Args>: FnOnce<Args> {
          /// Performs the call operation.
          #[unstable(feature = "fn_traits", issue = "29625")]
          extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output;
      }


      #[lang = "fn_once"]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[rustc_paren_sugar]
      #[rustc_on_unimplemented(
          on(
              Args = "()",
              note = "wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}"
          ),
          message = "expected a `{FnOnce}<{Args}>` closure, found `{Self}`",
          label = "expected an `FnOnce<{Args}>` closure, found `{Self}`"
      )]
      #[fundamental] // so that regex can rely that `&str: !FnMut`
      #[must_use = "closures are lazy and do nothing unless called"]
      pub trait FnOnce<Args> {
          /// The returned type after the call operator is used.
          #[stable(feature = "fn_once_output", since = "1.12.0")]
          type Output;

          /// Performs the call operation.
          #[unstable(feature = "fn_traits", issue = "29625")]
          extern "rust-call" fn call_once(self, args: Args) -> Self::Output;
      }
    #+end_src

    这三个 trait 都标记了三个相同的属性.

    1. ~#[lang="fn/fn_mut/fn_once"]~: 表示其属于语言项(Lang Item), 分别以 ~fn~,
       ~fn_mut~, ~fn_once~ 名称来查找这三个 trait.
    2. ~#[rustc_paren_sugar]~: 表示这三个 trait 是对括号调用语法的特殊处理, 在编
       译器内部进行类型检查的时候, 仅会将最外层为圆括的情况识别为方法调用. 在类
       型签名或方法签名中有时候有尖括号, eg: ~<F:Fn(u8, u8) -> u8>~, 而此时尖括
       号你们的括号就不会被识别为方法调用.
    3. ~#[fundamental]~: 这是为了支持 trait 一致性而增加的属性, 加上此属性则被允
       许为 ~Box<T>~ 实现指定的 trait, 在此例中是这三个 ~Fn~ 系列的 trait

    函数调用分成三个 trait 与所有权系统有关:
    - ~FnOnce~ 调用常数为 ~self~, 这意味着它会转移方法接受者的所有权. 换句话说,
      就是这种方法调用只能被调用一次.
    - ~FnMut~ 调用常数为 ~&mut self~, 这意味着它会对方法接受者进行可变借用.
    - ~Fn~ 调用参数为 ~&self~, 这意味着它会对方法接受者进行不可变借用, 也就是说,
      这种方法调用可以被调用多次.

    现在函数调用被抽象成了三个 trait, 实现闭包就很简单了, 只需要用结构体代替闭包
    表达式, 然后按具体的需求为此结构体实现对应的 trait 即可. 这样的话, 每个闭包
    表达式实际上就是该闭包结构体的具体实例, 该结构体内部成员可以存储闭包捕获的变
    量, 然后在调用的时候使用即可.  
