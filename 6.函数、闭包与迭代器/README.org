* 函数、闭包与迭代器
  语言影响或觉得人类的思维方式.
  Rust 是一门混合范式的编程语言, 有机地融合了面向对象、函数式和方向编程范式. 它
  并非将这些特性进行简单堆砌, 而是通过高度一致性的类型系统融合了这三种范式的编程
  思想. 可以通过 ~impl~ 关键字配合结构体和 trait 来实现面向对象范式中的多态和封
  装, 也可以通过函数、高阶函数、闭包、模式匹配来实现函数式范式中的一些编程工具.
  Rust 支持 0 成本静态分发的泛型编程, 并且将它很好地融入了其他两种编程范式中, 提
  供了更高的抽象层次. 通过将这三种编程范式完美融合起来, Rust 语言拥有了更高程度
  的抽象以及更强的表达能力.

  函数式语言的历史要比面向对象语言悠久, 它源自古老的 LISP 语言, 其后发明的语言或
  多或少都受到了函数式编程思想的影响, eg: Python, Ruby, 以及更纯的函数式语言
  HasKell. 随着摩尔定律的失效, CPU 性能的提升转为主要依赖核数的增加, 多核时代到
  来后, 函数式编程因为其天生对并发友好的特性又逐渐受到了重视. 所以近年来很多新诞
  生的语言也吸收了函数式范式的诸多特性, eg: Elixir, Scala, Swift 都收到了 LISP
  和 HasKell 的影响, 对代数数据类型(algebraic data type)、模式匹配、高阶函数、闭
  包等特性各有所支持. 甚至一些年代久远的主流语言, eg: C++ 和 Java 也都开始吸收函
  数式语言的特性. Rust 作为一门在多核时代诞生的现代编程语言, 引入函数式编程范式
  完全是顺势而为的.

  本章内容主要从函数和闭包 2 个方面来探讨 Rust 对函数式编程范式的支持, 还会讲迭
  代器及其在闭包中的应用.
  
** 函数
   对于一段重复执行的代码, 可以将其定义为一个函数, 方便调用.

   *fn* 关键字后面为函数名称, 通常以 *蛇形命名法(snake_case)* 命名, 否则编译器会
   发出警告. 函数参数必须明确地指定类型, 如果有返回值也必须指定返回值的类型. 需
   要注意的是, Rust 中的函数参数 *不能指定默认值*. 函数体被包含于花括号之内, 出
   函数体之外的函数声明为 *函数签名*. 可以说, 一个函数是由函数签名和函数体组合
   而成的.

   一般来说, 函数定义时不允许直接使用语言中的保留字和关键字作为函数名. 但是在
   *Rust 2018* 中, 通过将原生标识操作符(Raw Identifier) *r#* 作为前缀, 即可使用
   关键字为函数命名, 该语法一般用于 FFI 中, 用于避免 C 函数名和 Rust 的关键字或
   保留字重名而引起的冲突.

   通过前面的张姐我们了解到, 函数 ucanshu 可以按值传递, 也可以按引用传递. 当参数按
   值传递时, 会转移所有权或执行复制(Copy)语义. 当参数按引用传递时, 所有权不会发
   生变化, 但是需要有生命周期参数. 当符合生命周期参数省略规则时, 编译器可以通过
   自动推断补齐参数的生命周期参数, 否则, 需要显示地为参数标明生命周期参数.

   函数参数也分为可变和不可变. Rust 的函数参数默认不可变, 当需要可变操作的时候,
   需要使用 ~mut~ 关键字来修饰.

*** 函数屏蔽
    当声明变量之后, 如果再次声明同名的变量绑定, 则之前的变量绑定会被屏蔽, 这叫做
    变量遮蔽(variable shadow). 变量可以如此, 但 *函数不能被多次定义*.

    可以通过显式地使用花括号将同名的函数分隔到不同的作用域中, 这样编译器就不会报
    错. 也就是说, 在同一个作用域中不能定义多个同名函数, 因为 *默认的函数定义只在
    当前作用域内有效*, 会屏蔽作用域外的同名函数.

*** 函数模式匹配
    函数中的参数等价于一个隐式的 let 绑定, 而 let 绑定本身是一个模式匹配的行为.
    所以函数参数也支持模式匹配.

    参数使用 ~ref~ 关键字来修饰:意味着要使用模式匹配来获取参数的不可变引用. 与
    ~ref~ 相对的是 ~ref mut~, ~ref mut~ 用来匹配可变引用.

    除了 ~ref~ 和 ~ref mut~, 函数参数也可以使用通配符(~_~)来忽略参数.

    实现某个 trait 中的方法时, 有时并不会用到其函数签名中声明的所有权参数, 这时
    可以使用通配符来进行忽略, 这样不会引起编译错误.

    Rust 中的 let 语句可以通过模式匹配解构元组(Tuple), 函数参数也可以. 若只想解
    构元组中的单个值, 则使用通配符将其他值忽略掉即可.

*** 函数返回单元值
    Rust 中的函数只能有唯一的返回值, 即使没有显式返回值的函数, 其实也相当于返回
    了一个单元值 ~()~. 如果乳摇返回多个值, 亦可使用元组类型.

    Rust 语言提供了 ~return~ 关键字来返回函数中的值. 对于只需要返回函数体最后一
    行 表达式所求值的函数, ~return~ 可以省略. 在某些控制结构中, eg: 循环或条件分
    支, 则需要显式地使用 ~return~ 关键字来返回.

    第二张中出现的函数返回类型为 "~!~" 的发散函数(diverging function), 此类函数
    *永远不会有任何返回值*.
    
*** 泛型函数
    Rust 的函数也支持泛型. 通过实现 泛型函数, 可以节省很多工作量.

    当编译器无法自动类型时, 需要显式地指定函数调用的类型, 使用 turbofish 操作符
    ~::<>~ 指定具体类型.

*** 方法与函数
    Rust 中的 *方法和函数是有区别的*. 方法来自面向对象的编程范式, 在语义上, 它代
    表某个实例对象的行为. 函数只是一段简单的代码, 它可以通过名字来进行调用. 方法
    也是通过名字来进行调用的, 但它必须关联一个 *方法接受者*.
    
*** 高阶函数
    在数学和计算机科学里均有高阶函数的定义. 在数学中, 高阶函数也叫算子或泛函.
    eg: 微积分中的导数就是一个函数到另一个函数的映射. 在计算机科学里, 高阶函数是
    指以函数作为参数或返回值的函数, 它也是函数式编程语言最基础的特性. Rust 语言
    也支持高阶函数, 因为函数在 Rust 中是一等公民.
    
    实现这一切的基础在于 Rust 支持类似 C/C++ 语言中的 *函数指针*.
    函数指针:　指向函数的指针, 其值为函数的地址.

    声明函数指针类型时, *必须显式指定函数指针类型 ~fn()~, 以及赋值的是函数名*.

    对于函数指针类型, 可以使用 ~type~ 关键字为其定义别名, 便于提升代码的可读性.

** 闭包
   *闭包(Closure)* 通常是指词法闭包, 是一个持有外部环境变量的函数. *外部环境* 是
   指闭包定义时所在的词法作用域. 外部环境变量, 在函数式编程范式中也被称为 *自由
   变量*, 是指并不是在闭包内定义的变量. *将自由变量和自身绑定的函数就是闭包*.

   *注意*: 此处闭包类型为 ~Fn(i32) -> i32~, 以大写字母 F 开头的 ~Fn~ 并不是函数
   指针类型 ~fn(i32) -> i32~, 它是一个 trait, 本章后面的章节有更详细的介绍.

   闭包包含以下来钟特性:

   - *延迟执行*: 返回的闭包只有在需要调用的时候才会执行
   - *捕获环境变量*: 闭包会获取其定义时所在作用域中的自由变量, 以供之后调用时使
     用.

*** 闭包的基本语法
    Rust 的闭包语法形式参考了 Ruby 语言的 lambda 表达式.

    闭包由 *管道符* (两个对称的竖线)和花括号(或圆括号)组合而成. 管道符里是闭包函
    数的参数, 可以像普通函数参数那样在冒号后面添加类型标注, 也可以省略为以下形
    式:
    #+begin_src rust
      let add = |a, b| -> i32 { a + b };
    #+end_src

    花括号里包含的是闭包函数执行体, 花括号和返回值也可以省略:
    #+begin_src rust
      let add = |a, b| a + b;
    #+end_src

    当闭包函数没有参数只有捕获的自由变量时, 管道符里的参数也可省略:
    #+begin_src rust
      let (a, b) = (1, 2);
      let add = || a + b;
    #+end_src

    闭包的参数可以是任意类型的. 
    
    # Rust 2018 已修复:
    # 但两个定义一模一样的闭包也并不一定属于同一种类型.

*** 闭包的实现
    闭包类型与 Rust 类型系统提供的常规类型不同, 它是由编译器制造的临时存在的闭包
    实例类型.

    *其实在 Rust 中, 闭包是一种语法糖*. 也就是说, 闭包不属于 Rust 语言提供的基本
    语法要素, 而是在基本语法功能之上又提供的一层方便开发者编程的语法. 闭包和普
    通函数的差别就是闭包可以捕获环境中的自由变量.

    若想要实现自己的闭包, 可以使用指针. 闭包 ~||{a + b}~ 的实现可以通过函数指针
    和捕获变量指针组合来实现. 指针放在栈上, 捕获变量放到堆上. 实际上, 早期的
    Rust 版本实现闭包就采用了类似的方式. 因为要把闭包捕获变量放到堆上, 所以称其
    为 *装箱(Boxed)闭包*. 这种方式带来的问题就是影响性能. Rust 是基于 LLVM 的语
    言, 这种闭包实现的方式使得 LLVM 难以对其进行内联和优化.

    
    所以 Rust 团队又对闭包的实现做了重大改进, 也就是当前版本中的闭包实现方式. 改
    进方案为 *非装箱(Unboxed)闭包*, 此方案是 Rust 语言一致性的再一次提现.

    非装箱闭包方案有三个目标:

    - 可以让用户更好地控制优化
    - 支持闭包按值和按引用绑定环境变量
    - 支持三种不同的闭包访问: 对应 ~self~, ~&self~ 和 ~&mut self~ 三种方法

    实现这三个目标的核心思想是: 通过增加 trait 将函数调用变为可重载的操作符.
    eg: 将 ~a(b, c, d)~ 这种函数调用变为如下形式:
    #+begin_src rust
      Fn::call(&a, (b, c, d));
      FnMut::call_mut(&mut a, (b, c, d));
      FnOnce::call_once(a, (b, c, d));
    #+end_src

    Rust 增加的这三个 trait 分别就是 ~Fn~, ~FnMut~ 和 ~FnOnce~.

    在 Rust 源码中的定义如下所示:
    #+begin_src rust
      #[lang = "fn"]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[rustc_paren_sugar]
      #[rustc_on_unimplemented(
          on(
              Args = "()",
              note = "wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}"
          ),
          message = "expected a `{Fn}<{Args}>` closure, found `{Self}`",
          label = "expected an `Fn<{Args}>` closure, found `{Self}`"
      )]
      #[fundamental] // so that regex can rely that `&str: !FnMut`
      #[must_use = "closures are lazy and do nothing unless called"]
      pub trait Fn<Args>: FnMut<Args> {
          /// Performs the call operation.
          #[unstable(feature = "fn_traits", issue = "29625")]
          extern "rust-call" fn call(&self, args: Args) -> Self::Output;
      }

      #[lang = "fn_mut"]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[rustc_paren_sugar]
      #[rustc_on_unimplemented(
          on(
              Args = "()",
              note = "wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}"
          ),
          message = "expected a `{FnMut}<{Args}>` closure, found `{Self}`",
          label = "expected an `FnMut<{Args}>` closure, found `{Self}`"
      )]
      #[fundamental] // so that regex can rely that `&str: !FnMut`
      #[must_use = "closures are lazy and do nothing unless called"]
      pub trait FnMut<Args>: FnOnce<Args> {
          /// Performs the call operation.
          #[unstable(feature = "fn_traits", issue = "29625")]
          extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output;
      }


      #[lang = "fn_once"]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[rustc_paren_sugar]
      #[rustc_on_unimplemented(
          on(
              Args = "()",
              note = "wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}"
          ),
          message = "expected a `{FnOnce}<{Args}>` closure, found `{Self}`",
          label = "expected an `FnOnce<{Args}>` closure, found `{Self}`"
      )]
      #[fundamental] // so that regex can rely that `&str: !FnMut`
      #[must_use = "closures are lazy and do nothing unless called"]
      pub trait FnOnce<Args> {
          /// The returned type after the call operator is used.
          #[stable(feature = "fn_once_output", since = "1.12.0")]
          type Output;

          /// Performs the call operation.
          #[unstable(feature = "fn_traits", issue = "29625")]
          extern "rust-call" fn call_once(self, args: Args) -> Self::Output;
      }
    #+end_src

    这三个 trait 都标记了三个相同的属性.

    1. ~#[lang="fn/fn_mut/fn_once"]~: 表示其属于语言项(Lang Item), 分别以 ~fn~,
       ~fn_mut~, ~fn_once~ 名称来查找这三个 trait.
    2. ~#[rustc_paren_sugar]~: 表示这三个 trait 是对括号调用语法的特殊处理, 在编
       译器内部进行类型检查的时候, 仅会将最外层为圆括的情况识别为方法调用. 在类
       型签名或方法签名中有时候有尖括号, eg: ~<F:Fn(u8, u8) -> u8>~, 而此时尖括
       号你们的括号就不会被识别为方法调用.
    3. ~#[fundamental]~: 这是为了支持 trait 一致性而增加的属性, 加上此属性则被允
       许为 ~Box<T>~ 实现指定的 trait, 在此例中是这三个 ~Fn~ 系列的 trait

    函数调用分成三个 trait 与所有权系统有关:
    - ~FnOnce~ 调用常数为 ~self~, 这意味着它会转移方法接受者的所有权. 换句话说,
      就是这种方法调用只能被调用一次.
    - ~FnMut~ 调用常数为 ~&mut self~, 这意味着它会对方法接受者进行可变借用.
    - ~Fn~ 调用参数为 ~&self~, 这意味着它会对方法接受者进行不可变借用, 也就是说,
      这种方法调用可以被调用多次.

    现在函数调用被抽象成了三个 trait, 实现闭包就很简单了, 只需要用结构体代替闭包
    表达式, 然后按具体的需求为此结构体实现对应的 trait 即可. 这样的话, 每个闭包
    表达式实际上就是该闭包结构体的具体实例, 该结构体内部成员可以存储闭包捕获的变
    量, 然后在调用的时候使用即可.  

    当 ~extern~ 关键字用在 ~fn~ 前面时, 表示使用指定的 ABI(Application Binary
    Interface, 程序二进制接口).

    ~rust-call~ ABI 可以将函数参数中的元组类型做动态扩展, 以便支持可变长参数. 因
    为在 ~Fn~, ~FnMut~, ~FnOnce~ 这三个 trait 里的方法要接收闭包的参数, 而编译器
    本身并不可能知道开发者给闭包设定的参数个数, 所以这里只能传元组, 然后由
    ~rust-call~ ABI 在底层做动态扩展.

    *注意*: 使用 ~rust-call~ ABI 需要声明 ~unboxed_closures~ 特性.

    调用 ~call~, ~call_mut~ 和 ~call_once~ 方法的时候必须显式指定一个单元值为参
    数.

    ~call_once~ 调用之后, 之前的实例所有权被转移, 无法再次被使用.

    显式指定闭包类型时, 类型必须使用 *trait 对象* (见 3.4节 - trait 对象).

*** 闭包与所有权
    闭包表达式会由编译器自动翻译为结构体实例, 并为其实现 ~Fn~, ~FnMut~, ~FnOnce~
    三个 trait 中的一个. 

    *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/247][issue]]
    这三个 trait 和所有权有关系. 更准确地说, 这三个 trait 的作用如下:
    - ~Fn~: 表示闭包 *至多只存在* 以不可变借用的方式来捕获环境中的自由变量, 同时
      也表示该闭包 *没有改变环境的能力*, 并且可以多次调用. 对应 ~&self~. 
    - ~FnMut~: 表示闭包 *存在* 以可变借用的方式来捕获环境中的自由变量, 同时意味
      着该闭包 *有改变环境的能力*, 也可以多次调用. 对应 ~&mut self~
    - ~FnOnce~: 表示闭包 *存在* 通过转移所有权来捕获环境中的自由变量, 同时意味着
      该闭包 *可能* 有改变环境的能力, *取决于是否存在以可变借用的方式来捕获的环
      境中的自由变量*, 只能调用一次, 因为闭包会消耗自身. 对应 ~self~.

    第五章讲所有权系统时, 对不同环境变量类型介绍过闭包捕获其环境变量的方式:
    - 对于复制语义类型, 以不可变引用(~&T~)来进行捕获
    - 对于移动语义类型, 执行移动语义, 转移所有权来进行捕获.
    - 对于可变绑定, 并且在闭包中包含对其进行修改的操作, 则以可变引用(~&mut T~)来
      进行捕获.

    也就是说, *闭包会根据环境变量类型来决定实现哪种 trait*.

    ~FnMut~ 继承了 ~FnOnce~, ~Fn~ 又继承了 ~FnMut~. 这意味着: 如果要实现 ~Fn~,
    就必须实现 ~FnMut~ 和 ~FnOnce~; 如果要实现 ~FnMut~, 就必须实现 ~FnOnce~.

**** 使用 move 关键字自动实现 Fn
     Rust 针对闭包提供了一个关键字 *move*, 使用此关键字的作用是:
     *强制让闭包所定义环境中的自由变量转移到闭包中*.

     *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/132][issue]]
     ~FnMut~ 闭包在使用 ~move~ 关键字的时候, 如果捕获变量的复制语义类型的, 则闭包会自动
     实现 Copy/Clone; 如果捕获变量是移动语义类型的, 则闭包不会自动实现
     Copy/Clone, 这也是处于保证内存安全的考虑.

**** 修改环境变量以自动实现 FnMut
     很多时候需要通过修改环境变量的闭包来自动实现 ~FnMut~.

     实现了 ~FnMut~ 的闭包, 必然会实现 ~FnOnce~, 但不会实现 ~Fn~.

**** 未捕获任何环境变量的闭包会自动实现 Fn
     没有捕获任何自由变量的闭包, 会自动实现 ~Fn~.

**** 规则总结
     综合上面的几种情况, 可以得出如下规则:
     - 如果闭包中没有捕获任何环境变量, 则默认实现 ~Fn~.
     - 如果闭包中捕获了复制语义类型的环境变量, 则:
       + 如果不需要修改环境变量, 无论是否使用 ~move~ 关键字, 均会自动实现 ~Fn~.
       + 如果需要修改环境变量, 则自动实现 ~FnMut~
     - 如果闭包中捕获了移动语义类型的环境变量, 则:
       + 如果不需要修改环境变量, 且没有使用 ~move~ 关键字, 则自动实现 ~FnOnce~
       + 如果不需要修改环境变量, 且使用了 ~move~ 关键字, 则自动实现 ~Fn~
       + 如果需要修改环境变量, 则自动实现 ~FnMut~
     - 使用 ~move~ 关键字, 如果捕获的变量是复制语义类型的, 则闭包会自动实现
       Copy/Clone, 否则不会自动实现 Copy/Clone.

     *社区总结*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/164#issuecomment-482908447][issue]]
     | 环境变量语义 | 环境变量操作 | 有无move | 闭包trait | 换变量怎么被处理 | 闭包能否Copy |
     |--------------+--------------+----------+-----------+------------------+--------------|
     | 复制         | 读           | Y        | Fn        | copy             | Y            |
     | 复制         | 读           | N        | Fn        | immutable borrow | Y            |
     | 复制         | 修改         | Y        | FnMut     | copy             | Y            |
     | 复制         | 修改         | N        | FnMut     | mutable borrow   | N            |
     |--------------+--------------+----------+-----------+------------------+--------------|
     | 移动         | 读           | Y        | Fn        | move             | N            |
     | 移动         | 读           | N        | Fn        | immutable borrow | Y            |
     | 移动         | 修改         | Y        | FnMut     | move             | N            |
     | 移动         | 修改         | N        | FnMut     | mutable borrow   | N            |
     | 移动         | 消耗         | Y        | FnOnce    | move             | N            |
     | 移动         | 消耗         | N        | FnOnce    | move             | N            |
     
*** 闭包作为函数参数和返回值
    闭包存在于很多语言中, 尤其是动态语言, 诸如 JavaScript, Python 和 Ruby 之类,
    闭包的使用非常广泛. 但是在这些动态语言中, 闭包捕获的环境变量基本都是对象(指
    面向对象的对象, 属于引用类型), 使用不当容易造成内存泄露. 并且在这些语言中,
    闭包是在堆中分配的, 运行时动态分发, 由 GC 来回收内存, 调用和回收闭包都会消耗
    多余的 CPU 时间, 更不用说使用内联技术来优化这些闭包了. 而 Rust 使用 trait 和
    匿名结构体提供的闭包机制是非常强大的. Rust 的闭包实现受到了现代 C++ 的启发,
    将捕获的变量放到结构体重, 这样的好处就是不会占用堆内存, 拥有更高的性能, 可以
    使用内联技术来消除函数调用开销并实现其他关键的优化, eg: 对编译器自动实现闭包
    的结构体进行优化等. 从而允许在任何环境(包括裸机)中使用闭包.

    Rust 的闭包实现机制使得每个闭包表达式都是一个独立的类型, 这样可能有一些不变,
    eg: 无法将不同的闭包保存到一个数组中, 但是可以通过闭包把闭包当作 trait 对象
    来解决这个问题.

    像这种在函数 ~boxed_closure~ 调用之后才会使用的闭包, 叫作 *逃逸闭包(escape
    closure)*. 因为该闭包捕获的环境变量 "逃离" 了 ~boxed_closure~ 函数的栈帧, 所
    以在函数栈帧销毁之后依然可用. 与之相对应, 如果是跟随函数一起调用的闭包, 则是
    *非逃逸闭包(non-escape closure)*.

**** 闭包作为函数参数
     闭包可以作为函数参数, 这一点直接提升了 Rust 语言的抽象表达能力. 令其有了完
     全不弱于 Ruby, Python 这类动态语言的抽象表达能力. 下面比较了 Rust 和 Ruby
     两种语言中的 any 方法, 该方法用于按指定条件确认数组中的元素是否存在.
     Rust 语言:
     #+begin_src rust
       v.any(|&x| x == 3);
     #+end_src

     Ruby 语言:
     #+begin_src ruby
       v.any?{|i| i == 3}
     #+end_src

     看的出来, Rust 语言和 Ruby 语言中对闭包的用法基本相似.

     因为闭包属于 trait 语法糖, 所以当它被用作参数传递时, 它可以被用作泛型的
     trait 限定, 也可以直接作为 trait 对象来使用.

     动态分发比静态分发的性能低一些, 但还是晚期可以和 C++ 媲美的. 动态分发闭包在
     实际中更加常用语回调函数(callback).

     eg: Rust 的 Web 开发框架 Rocket 的中间件实现就李永乐闭包作为回调函数:
     [[https://github.com/SergioBenitez/Rocket/blob/master/core/lib/src/fairing/ad_hoc.rs][Link]]
     #+begin_src rust
       pub struct AdHoc {
           name: &'static str,
           kind: AdHocKind,
       }

       enum AdHocKind {
           // 包含的值类型是一个 trait 对象的闭包
           Request(Box<dyn for<'a> Fn(&'a mut Request<'_>, &'a Data)
               -> BoxFuture<'a, ()> + Send + Sync + 'static>),
       }

       impl AdHoc {
           // 第二个参数为一个闭包 F, 表明接受 2 个参数
           // 第一个是可变引用, 第二个是不可变引用, 并且是可以在线程中安全传递的
           // `'static` 生命周期用来约束该闭包是一个 *逃逸闭包*, 只有逃逸闭包才能装箱
           pub fn on_request<F: Send + Sync + 'static>(name: &'static str, f: F) -> AdHoc
               where F: for<'a> Fn(&'a mut Request<'_>, &'a Data) -> BoxFuture<'a, ()>
           {
               AdHoc { name, kind: AdHocKind::Request(Box::new(f)) }
           }
       }

       #[crate::async_trait]
       impl Fairing for AdHoc {
           async fn on_request(&self, req: &mut Request<'_>, data: &Data) {
               // if let 语法, 如果匹配到闭包就调用
               // 此为动态分发闭包在实际中作为回调函数的示例
               if let AdHocKind::Request(ref callback) = self.kind {
                   callback(req, data).await;
               }
           }
       }
     #+end_src

     
**** 闭包作为函数返回值
     因为闭包是 trait 语法糖, 所以无法直接作为函数的返回值, 如果要把闭包作为返回
     值, 必须使用 trait 对象.

     *以下内容已过时(FnBox相关)*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/249][issue]]
     # 早期的 Rust 中, 如果要调用闭包 ~Box<FnOnce(i32)->i32>~, 就必须把
     # ~FnOnce(i32) -> i32~ 从 ~Box<T>~ 中移出来. 而此时 ~Box<T>~ 的 ~T~ 无法在编
     # 译期确定大小, 无法转移所有权, 就报错.

     # ~FnOnce~ 装箱为 ~Box<FnOnce>~ 之后, 其对应的由编译器生成的闭包结构体实例就
     # 是 ~Box<ClosureStruct>~ 类型(假如闭包结构体名为 ClosureStruct), 该闭包结构
     # 体实现 ~FnOnce~ 的 ~call_once~ 方法额接收者本来是 ~self~, 也就是闭包结构体
     # 实例, 现在变成了 ~Box<self>~, 也就是装箱的闭包结构体实例. 现在想从
     # ~Box<self>~ 里移出 ~self~ 这个闭包结构体实例来进行调用, 因为编译期无法确定
     # 其大小, 所以无法获取 ~self~. 而对于 ~Fn~ 和 ~FnMut~ 来说, 装箱以后分别对应
     # 的是 ~&Box<self>~ 和 ~&mut Box<self>~, 所以不会报错. 对于此问题, Rust 给出
     # 了 ~FnBox~ 解决方案.

     # #+begin_src rust
     #   #![feature(fnbox)]
     #   use std::boxed::FnBox;
     #   fn square() -> Box<FnBox(i32) -> i32> {
     #       Box::new(|i| { i * i })
     #   }

     #   fn main() {
     #       let square = square();
     #       assert_eq!(4, square(2));
     #   }
     # #+end_src

     # ~Fnbox~ 是一个调用语法糖, 因为使用了 ~#[rustc_paren_sugar]~ 属性, 该 trait
     # 实现了 ~call_box~ 方法, 第一个参数和之前的 ~Fn~, ~FnMut~, ~FnOnce~ 定义的方
     # 法有很大的不同, 该方法的第一个参数 ~self~ 是 ~Box<Self>~ 类型.

     # 理论上, ~self: SomeType<Self>~ 这种形式应该适用于任意类型(SomeType), 但实际
     # 上, 这里只支持 ~Box<T>~. 所以, ~self:Box<Self>~ 这种类型指定会自动解引用并
     # 移动 ~Self~ 的所有权, 因为 ~Box<T>~ 支持 DerefMove(第五章).

     # ~Self:Box<self>~ 是通过调用 ~call_box~ 来间接调用 ~call_once~ 的, 因为
     # ~Box<FnBox>~ 实现了 ~FnOnce~. 这看上去完全是一个 "曲线救国" 的方案, 所以,
     # 在装箱时使用 ~FnBox~ 来替代 ~FnOnce~ 只是临时的解决方案, 在现在的 Rust 版本
     # 中, 已弃用.

     # 出现这种问题的根本原因在于, Rust 中的函数返回值只能出现类型. 虽然有对象可用,
     # 但是性能上也会有所损耗. 为了解决此问题, Rust 团队提出了一个新的方案, 叫
     # ~impl Trait~ 语法, 该方案可以让函数 *直接返回一个 trait*.
     
     使用 ~impl Trait~ 语法, 该方案可以让函数 *直接返回一个 trait*. 此语法代表的
     是实现了指定 trait 的那些类型, 相当于泛型, 属于 *静态分发*.

     
*** 高阶生命周期
    闭包可以作为函数的参数和返回值, 那么闭包参数中如果含有引用的话, 声明周期参数
    该如何标注?

    Rust 针对无法直接获取关系的生命周期提供了 *高阶生命周期* (Higher-Ranked
    Lifetime), 也叫 *高阶 trait 限定* (Higher-Ranked Trait Bound, HRTB). 该方案
    提供了一个 ~for<>~ 语法.

    ~for<>~ 语法整体表示此生命周期参数 *只针对* 其后面所跟着的 "对象", 在本例中
    是 ~DoSomething<&'f usize>~, 就代表 ~bar~ 函数的生命周期和 ~DoSomething<&'f
    usize>~ 没有直接关系, 所以编译正常.

    实际开发中会经常使用闭包, 而闭包实现的三个 trait 本身也是泛型 trait, 所以肯
    定也存在闭包参数和返回值都是引用类型的情况.

    *注意*: 高阶声明周期的 ~for<>~ 语法 *只能用于标注生命周期参数*, 而不能用于其
    他泛型类型.

** 迭代器
   在 Rust 语言中, 闭包最常见的应用场景是: 在遍历集合容器中的元素的同时, 按闭包
   内指定的逻辑进行操作. 

   当循环语句迭代数据时, 必须使用一个变量来记录数据集合中每一次迭代所在的位置,
   而在许多编程语言中, 已经开始通过模式化的方式来返回迭代过程中集合的每一个元素.
   这种模式化的方式就叫 *迭代器(Iterator)* 模式, 使用迭代器可以极大地简化数据操
   作. 迭代器设计模式也被称为 *游标(Cursor)* 模式, 它提供了一种方法, 可以顺序访
   问一个集合容器中的元素, 而不需要暴露该容器的内部结构和实现细节.

*** 外部迭代器和内部迭代器
    迭代器分为两种: *外部迭代器(External Iterator)* 和 *内部迭代器(Internal
    Iterator)*.

    外部迭代器也叫主动迭代器(Active Iterator), 它独立于容器之外, 通过容器提供的
    方法(eg: next 方法就是所谓的游标)来迭代下一个元素, 并需要考虑容器内可迭代的
    剩余数量来进行迭代. *外部迭代器的一个重要特点是, 外部可以控制整个遍历进程*.
    eg: Python, Java 和 C++ 语言中的迭代器, 就是外部迭代器.

    内部迭代器则通过迭代器自身来控制迭代下一个元素, 外部无法干预. 这意味着, 只要
    调用了内部迭代器, 并通过闭包传入了相关操作, 就必须等待迭代器依次为其中每个元
    素执行完相关操作以后才可以停止遍历. eg: Ruby 语言中的 each 迭代器就是典型的
    内部迭代器.

    早期的(Rust 1.0 版本以前)Rust提供的是内部迭代器, 而内部迭代器无法通过外部控
    制迭代进程, 再加上 Rust 的所有权系统, 导致使用起来很复杂.

    内部迭代器与容器的绑定比较紧密, 并且无法从外部来控制其遍历进程. 更重要的是,
    对于开发者来说, 扩展性较差. Rust 官方和社区经过很长时间的论证, 决定改为外部
    迭代器, 也就是 ~for~ 循环.

    ~for~ 循环是一个典型的外部迭代器, 通过它可以遍历动态数组中的元素, 并且此遍历
    过程完全可以在动态数组之外进行控制. Rust 中的 ~for~ 循环其实是一个语法糖.

*** Iterator trait
    简单来说, ~for~ 循环就是利用迭代器模式实现的一个语法糖, 它属于外部迭代器. 迭
    代器也是 Rust 一致性的典型表现之一. 不出所料, Rust 中依然使用了 trait 来抽象
    迭代器模式.

    Iterator 源码示意:
    #+begin_src rust
      #[doc(spotlight)]
      #[must_use = "iterators are lazy and do nothing unless consumed"]
      pub trait Iterator {
          /// The type of the elements being iterated over.
          #[stable(feature = "rust1", since = "1.0.0")]
          type Item;

          #[lang = "next"]
          #[stable(feature = "rust1", since = "1.0.0")]
          fn next(&mut self) -> Option<Self::Item>;
      }
    #+end_src

    ~Iterator~ trait 是 Rust 中对迭代器模式的抽象接口. 其中 ~next~ 方法是实现一
    个迭代器时必须实现的方法, 基本都包含了默认实现. 该 trait 中还包含了一个关联
    类型 ~Item~, 并且 ~next~ 方法胡返回 ~Option<Self::Item>~ 类型. ~Item~ 和
    ~Self~ 可以看做占位类型, 它们表示实现该 trait 的具体类型的相关信息. 

    通过实现该 trait, 可以创建自定义的迭代器.

    对于一个真正的迭代器, 除了需要使用 next 方法获取下一个元素, 还需要知道迭代器
    的长度信息, 这对于优化迭代器很有帮助.
    
    在 ~Iterator~ trait 中还提供了一个方法叫 *size_hint*.
    ~Iterator~ trait 提供的 ~size_hint~ 方法源码示意:
    #+begin_src rust
      #[doc(spotlight)]
      #[must_use = "iterators are lazy and do nothing unless consumed"]
      pub trait Iterator {
          /// The type of the elements being iterated over.
          #[stable(feature = "rust1", since = "1.0.0")]
          type Item;

          #[inline]
          #[stable(feature = "rust1", since = "1.0.0")]
          fn size_hint(&self) -> (usize, Option<usize>) {
              (0, None)
          }
      }
    #+end_src

    ~size_hint~ 方法默认实现中, 其返回类型是一个元组 ~(usize, Option<usize>)~,
    此元组表示 *迭代器剩余长度的边界信息*. 元素中第一个元素表示下限(lower
    bound), 第二个元素表示上线(upper bound). 第二个元素是 ~Option<usize>~ 类型,
    代表已知上限或者上限超过 ~usize~ 的最大取值范围, eg: 无穷迭代. 此方法的默认
    返回值 ~(0, None)~ 适用于任何迭代器.

    通过 ~iter~ 方法转换为一个迭代器后, 每次调用 ~next~ 方法, 迭代器的剩余长度就
    会减少, 直到减为 0 为止. 方法 ~size_hint~ 返回的元组上限和下限是一致的.

    调用 ~iter~ 方法转换后的为一个 ~Iter~ 结构体, 本身成员就包含了起始与结束指针,
    ~size_hint~ 方法计算两者指针距离:
    #+begin_src rust
      #[stable(feature = "rust1", since = "1.0.0")]
      pub struct Iter<'a, T: 'a> {
          pub(super) ptr: NonNull<T>,
          pub(super) end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that
          // ptr == end is a quick test for the Iterator being empty, that works
          // for both ZST and non-ZST.
          pub(super) _marker: marker::PhantomData<&'a T>,
      }
    #+end_src

    方法 ~size_hint~ 的目的就是优化迭代器, 不要忘记 Rust 是一门系统级编程语言,
    性能永远是一项重要的指标. 迭代器和集合容器几乎形影不离, 实际开发中经常有使用
    迭代器来扩展集合容器的需求, 此时方法 ~size_hint~ 就派上用场了. 如果实现直到
    准确的迭代器长度, 就可以做到精确地扩展容器容量, 从而避免不必要的容量检查, 提
    高性能.

    ~extend~ 方法是被定义于 ~Extend~ trait 中的.
    ~Extend~ 和 ~String~ 类型实现 ~extend~ 方法的源码示意:
    #+begin_src rust
      #[stable(feature = "rust1", since = "1.0.0")]
      pub trait Extend<A> {
          #[stable(feature = "rust1", since = "1.0.0")]
          fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T);
      }

      #[stable(feature = "rust1", since = "1.0.0")]
      impl Extend<char> for String {
          fn extend<I: IntoIterator<Item = char>>(&mut self, iter: I) {
              // 首先使用 `into_iter()` 方法获取了一个迭代器
              let iterator = iter.into_iter();
              // 然后通过迭代器的 `size_hint()` 方法获取其长度
              let (lower_bound, _) = iterator.size_hint();
              // 取迭代器下限, 然后调用字符串的 `reverse()` 方法, 确保扩展的字节长度大于或等于给定的值
              // 这样做是为了避免频繁分配
              // `reverse()` 方法只是提供了一种保障, 并不做分配空间行为
              self.reserve(lower_bound);
              iterator.for_each(move |c| self.push(c));
          }
      }
    #+end_src

    ~Extend~ trait 是一个泛型 trait, 其中定义了 ~extend~ 方法, 这是一个泛型方法,
    其泛型参数 ~T~ 使用了 trait 限定 ~IntoIterator<Item=A>~, 这表示该泛型方法只
    接受实现了 ~IntoIterator~ 的类型. 而 ~String~ 类型正好针对 ~char~ 类型实现了
    该泛型 trait.

    现在可以看出来 ~size_hint()~ 方法的重要性了. 为了确保该方法可以获得迭代器长
    度的准确信息, Rust 又进入了两个 trait, 分别是 *ExactSizeIterator* 和
    *TrustedLen*, 它们均是 ~Iterator~ 的子 trait, 均被定义于 ~std::iter~ 模块中.

    ~ExtractSizeIterator~ 提供了两个额外的方法 ~len~ 和 ~is_empty~, 要实现 ~len~
    必须先实现 ~Iterator~, 这就要求 ~size_hint~ 方法必须提供准确的迭代器长度信息.

    ~TrustedLen~ 是试验性 trait, 还未正式公开, 但是在 Rust 源码内部, 它就像一个
    标签 trait, 只要实现了 ~TrustedLen~ 的迭代器, 其 ~size_hint~ 获取的长度信息
    均是可信任的, 有了该 trai他就完全避免了容器的容量检查, 从而提升了性能.

    ~ExactSizeIterator~ 和 ~TrustedLen~ 的区别在于, 后者应用于没有实现
    ~ExactSizeIterator~ 的大多数情况. 开发者可以根据具体的情况自定义实现
    ~ExtractSizeIterator~, 但是对于某些迭代器, 开发者并不能为其实现
    ~ExactSizeIterator~, 所以需要 ~TrustedLen~ 做进一步的限定.
    
*** IntoIterator trait 和迭代器
    上一节介绍了 ~Iterator~ trait, 我们了解到, 如果想迭代某个集合容器中的元素,
    必须将其转换为迭代器才可以使用. 并且在 ~for~ 循环语法糖中, 也使用了
    ~into_iter~ 之类的方法来获取一个迭代器. 要寻找迭代器到底是什么的答案, 必须先
    从 ~IntoIterator trait~ 开始.

    第三章讲过类型转换用到的 ~From~ 和 ~Into~ 两个 trait, 它们定义了两个方法, 分
    别是 ~from~ 和 ~into~, 这两个方法互为反操作. 对于迭代器来说, 并没有用到这两
    个 trait, 但是这里值得注意的是, Rust 中对于 trait 的命名也是具有高度一致性的.

    Rust 也提供了 ~FromIterator~ 和 ~IntoIterator~ 两个 trait, 它们也互为反操作.
    ~FromIterator~ 可以从迭代器转换为指定类型, 而 ~IntoIterator~ 可以从指定类型
    转换为迭代器. 关于 ~FromIterator~ 的细节会在 6.3.5 节(下 2 节)着重介绍, 这里
    先介绍 ~IntoIterator~.
    ~IntoIterator~ 源码示意:
    #+begin_src rust
      #[rustc_diagnostic_item = "IntoIterator"]
      #[stable(feature = "rust1", since = "1.0.0")]
      pub trait IntoIterator {
          #[stable(feature = "rust1", since = "1.0.0")]
          type Item;

          #[stable(feature = "rust1", since = "1.0.0")]
          type IntoIter: Iterator<Item = Self::Item>;

          #[lang = "into_iter"]
          #[stable(feature = "rust1", since = "1.0.0")]
          fn into_iter(self) -> Self::IntoIter;
      }
    #+end_src

    方法 ~into_iter()~ 是在该 trait 中定义的. ~into_iter~ 的参数是 ~self~, 代表
    该方法会转移方法接受者的所有权. 同时, 该方法会返回 ~Self::IntoIter~ 类型.
    ~Self::IntoIter~ 是关联类型, 并且指定了 trait 限定
    ~Iterator<Item=Self::Item>~, 意味着必须是实现了 ~Iterator~ 的类型才能作为迭
    代器.

    最常用的集合容器就是 ~Vec<T>~ 类型, 它实现了 ~IntoIterator~, 可以通过
    ~into_iter~ 方法转换为迭代器. 

    #+begin_src rust
      #[stable(feature = "rust1", since = "1.0.0")]
      impl<T> IntoIterator for Vec<T> {
          type Item = T;
          type IntoIter = IntoIter<T>;

          #[inline]
          fn into_iter(self) -> IntoIter<T> {
              unsafe {
                  let mut me = ManuallyDrop::new(self);
                  let begin = me.as_mut_ptr();
                  let end = if mem::size_of::<T>() == 0 {
                      arith_offset(begin as *const i8, me.len() as isize) as *const T
                  } else {
                      begin.add(me.len()) as *const T
                  };
                  let cap = me.buf.capacity();
                  IntoIter {
                      buf: NonNull::new_unchecked(begin),
                      phantom: PhantomData,
                      cap,
                      ptr: begin,
                      end,
                  }
              }
          }
      }
    #+end_src

    最终返回的是一个定义于 ~std::vec~ 模块中的 ~IntoIter~ 结构体.
    该结构体包含下列 4 个成员字段:
    - *Buf*: 通过 ~Vec<T>~ 类型的动态数组起始地址 ~begin~ 生成一个内部使用的
      Shared 指针, 指向该动态数组中实际存储肚饿数据.
    - *Cap*: 获得该动态数组的容量大小, 也就是内存占用大小
    - *Ptr*: 指定了 ~begin~ 的值, 代表迭代器的起始指针.
    - *End*: 代表迭代器的终点指针, 根据 ~Vec<T>~ 动态数组的长度 ~len~ 和起始地址
      ~begin~ 计算 offset 获得
    
    ~IntoIter~ 结构体也实现了 ~Iterator~ trait, 拥有了 ~next~, ~size_hint~ 和
    ~count~ 三个方法,  它是一个名副其实的迭代器.

    简单而言, 就是 ~Vec<T>~ 实现了 ~IntoIterator~, 因此可以通过 ~into_iter~ 方法
    将一个 ~Vec<T>~ 类型的动态数组转换为一个 ~IntoIter~ 结构体. ~IntoIter~ 结构
    体拥有该动态数组的全部信息, 并且获得了该动态数组的所有权. 同时, ~IntoIter~
    结构体实现了 ~Iterator~ trait, 允许其通过 ~next~, ~size_hint~ 和 ~count~ 方
    法对齐进行迭代处理. 所以, ~IntoIter~ 就是 ~Vec<T>~ 转换而成的迭代器.

    转换 ~IntoIter~ 迭代器的代价就是 *要转移容器的所有权*, 在实际开发中, 有很多
    情况是不能转移所有权的. 因此, Rust 还提供了另外两个迭代器专门处理这种情况,
    分别是: *Iter* 和  *IterMut*. 这三种迭代器类型和所有权如如下对应关系:
    - *IntoIter*: 转移所有权, 对应 ~self~.
    - *Iter*: 获得不可变借用, 对应 ~&self~.
    - *IterMut*: 获得可变借用, 对应 ~&mut self~.

    ~Iter~ 和 ~IterMut~ 迭代器的典型应用就是 ~slice~ 类型.
    ~Iter~ 迭代器的源码示意:
    #+begin_src rust
      #[stable(feature = "rust1", since = "1.0.0")]
      pub struct Iter<'a, T: 'a> {
          pub(super) ptr: NonNull<T>,
          pub(super) end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that
          // ptr == end is a quick test for the Iterator being empty, that works
          // for both ZST and non-ZST.
          pub(super) _marker: marker::PhantomData<&'a T>,
      }
    #+end_src

    迭代器 ~Iter~ 中包含 ~ptr~ 和 ~end~ 指针, 均为不可变的裸指针 ~*const T~, 用
    于计算迭代器的长度, 而 ~_marker~ 字段只是编译期标记, 是为了让生命周期参数
    ~'a~ 有用武之地, 通过编译. 关于 ~PhantomData~ 的更多内容会在第 13 章中详细介
    绍.

    ~Iter~ 迭代器也被称为不可变迭代器, 因为它不能改变原来容器中的数据.
    ~IterMut~ 迭代器源码示意:
    #+begin_src rust
      #[stable(feature = "rust1", since = "1.0.0")]
      pub struct IterMut<'a, T: 'a> {
          pub(super) ptr: NonNull<T>,
          pub(super) end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that
          // ptr == end is a quick test for the Iterator being empty, that works
          // for both ZST and non-ZST.
          pub(super) _marker: marker::PhantomData<&'a mut T>,
      }
    #+end_src

    迭代器 ~IterMut~ 中包含的 ~ptr~ 和 ~end~ 指针均为可变裸指针, 意味着此迭代器
    可以改变容器内的值.

    Rust 中的迭代器不仅有 ~IntoIter~, ~Iter~ 和 ~IterMut~ 三种. eg: ~String~ 类
    型和 ~HashMap~ 类型均有 *Drain* 迭代器, 可以迭代删除指定范围内的值, 为字符串
    和 ~HashMap~ 的处理提供方便. 不管 Rust 中的迭代器有多少种, 重要的是, 这些迭
    代器的实现都遵循上述规律, 这也是 Rust 高度一致性的设计所带来的好处. 反过来,
    不管是 ~Slice~ 类型的数组, 还是 ~Vec<T>~ 类型的动态数组, 亦或是 ~HashMap~ 等
    容器, 迭代器模式都将其同意抽象地看待成一种数据流容器, 通过对迭代器提供的 "游
    标" 进行增减就可以遍历流中的每一个元素.

*** 迭代器适配器
    迭代器将数组容器的操作抽象为了统一的数据流.
    
    在软件世界中, 通过 *适配器模式* 同样可以将一个接口转换成所需的另一个接口. 适
    配器模式能够使得接口不兼容的类型在一起工作. 适配器也有一个别名, 叫 *包装器
    (Wrapper)*. Rust在迭代器基础上增加了适配器模式, 这就极大地增强了迭代器的表现
    力.

**** Map 适配器
     迭代器的 ~map~ 方法创建一个新的迭代器 ~iter~. 这个迭代器就是迭代器适配器.
     定义于 ~std::iter::Iterator~ 中的 ~map~ 方法源码:
     #+begin_src rust
       #[doc(spotlight)]
       #[must_use = "iterators are lazy and do nothing unless consumed"]
       pub trait Iterator {
           #[stable(feature = "rust1", since = "1.0.0")]
           type Item;

           #[inline]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn map<B, F>(self, f: F) -> Map<Self, F>
           where
           // 注意: 此处 `Self` 限定为 `Sized`
           // 否则 `Self` 在编译期无法确定大小就会报错
               Self: Sized,
           // F 为闭包, 限定为 `FnMut(Self::Item) -> B`
           // Self::Item 是指为实现 `Iterator` 具体类型设置的关联类型 `Item`
               F: FnMut(Self::Item) -> B,
           {
               Map::new(self, f)
           }
       }
     #+end_src

     ~map~ 是 ~Iterator trait~ 中实现的方法, 返回的结构体 ~Map~ 就是一个迭代器适
     配器.

     迭代器适配器 ~Map~ 源码示意:
     #+begin_src rust
       #[must_use = "iterators are lazy and do nothing unless consumed"]
       #[stable(feature = "rust1", since = "1.0.0")]
       #[derive(Clone)]
       pub struct Map<I, F> {
           iter: I,
           f: F,
       }

       #[stable(feature = "rust1", since = "1.0.0")]
       impl<B, I: Iterator, F> Iterator for Map<I, F>
       where
           F: FnMut(I::Item) -> B,
       {
           type Item = B;

           #[inline]
           fn next(&mut self) -> Option<B> {
               // 注意: 调用的 `map` 方法是 `next()` 方法返回的 `Option<T>` 中实现的另一个 `map` 方法
               // 后面的章节会介绍该方法
               // 通过 `map()` 方法传入 `Map` 中存储的闭包, 就可以对每个元素指向相应的逻辑
               // 最终再返回一个 `Option<T>` 类型
               self.iter.next().map(&mut self.f)
           }

           #[inline]
           fn size_hint(&self) -> (usize, Option<usize>) {
               self.iter.size_hint()
           }
       }
     #+end_src

     看的出来, ~Map~ 是一个泛型结构体, 它只有连个字段, 一个是 *iter*, 一个 *f*,
     分别存储的是迭代器和传入的闭包. 然后为其实现饿了 ~Iterator~ trait, ~Map~ 就
     成为了一个地道的迭代器. 与一般迭代器不同的地方在于, 其核心方法 ~next~ 和
     ~size_hint~ 都是调用其 *内部存储的原始迭代器* 的响应方法. 
     
     该元阿莫上方使用了 ~#[must_use="..."]~ 属性, 该属性是用来发出警告, 提示开发
     者迭代器适配器是惰性的, 也就是说, 如果没有对迭代器产生任何 "消费" 行为, 它
     是不会发生真正的迭代的. 而调用 ~next~ 方法就属于 "消费" 行为. Rust 中所有的
     迭代器适配器都使用了 ~must_use~ 来发出警告.

     执行过程: 数组 ~a~ 通过 ~into_iter()~ 方法创建了迭代器 ~IntoIter~ 并转移所
     有权, 然后 ~IntoIter~ 再调用 ~Iterator~ trait 中实现的 ~map~ 方法, 传入闭
     包, ~IntoIter~ 迭代器创建了一个迭代器适配 ~Map~. ~Map~ 中存储了迭代器
     ~IntoIter~ 和传入的闭包 ~F~, 然后通过 ~next~ 方法遍历 "消费" 其元素, 依次产
     生新的数据.

**** 其他适配器
     除了 ~Map~, Rust 标准库还提供了很多迭代器适配器, 都定义于 ~std::iter~ 模块
     中. 下面是一个迭代器适配器常用列表.
     - *Map*: 通过对原始迭代器中的每个元素调用指定闭包来产生一个新的迭代器
     - *Chain*: 通过连接 2 个迭代器来茶壶跟你讲一个新的迭代器.
     - *Cloned*: 通过拷贝原始迭代器中全部元素来创建新的迭代器.
     - *Cycle*: 创建一个用于循环迭代的迭代器, 当迭代完毕后, 再返回第一个元素开始
       迭代.
     - *Enumerate*: 创建一个包含计数的迭代器, 它会返回一个元素 ~(i, val)~ 其中
       ~i~ 是 usize 类型, 为迭代器的当前索引, ~val~ 是迭代器返回的值
     - *Filter*: 创建一个基于谓词判断式(predicate, 山城布尔值的表达式)过滤元素的
       迭代器.
     - *FlatMap*: 创建一个类似 ~Map~ 的结构的迭代器, 但是其中不会含有任何嵌套.
     - *FilterMap*: 相当于 ~Filter~ 和 ~Map~ 两个迭代器依次使用后的效果.
     - *Fuse*: 创建一个可以快速结束遍历的迭代器. 在遍历迭代器时, 只要返回过一次
       ~None~, 那么之后所有的遍历结果都为 ~None~. 该迭代器适配器可以用于优化.
     - *Rev*: 创建一个可以反向遍历的迭代器.

     *rev* 源码示意:
     #+begin_src rust
       #[doc(spotlight)]
       #[must_use = "iterators are lazy and do nothing unless consumed"]
       pub trait Iterator {
           #[stable(feature = "rust1", since = "1.0.0")]
           type Item;

           #[inline]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn rev(self) -> Rev<Self>
           where
               // 注意: 此处的 `Self` trait 限定中包含了一个 `DoubleEndedIterator`
               Self: Sized + DoubleEndedIterator,
           {
               Rev::new(self)
           }
       }
     #+end_src

     *Rev* 迭代器适配器源码示意:
     #+begin_src rust
       #[derive(Clone, Debug)]
       #[must_use = "iterators are lazy and do nothing unless consumed"]
       #[stable(feature = "rust1", since = "1.0.0")]
       pub struct Rev<T> {
           iter: T,
       }

       #[stable(feature = "rust1", since = "1.0.0")]
       impl<I> Iterator for Rev<I>
       where
           I: DoubleEndedIterator,
       {
           // 指定了 `DoubleEndIterator` 限定. 并且将关联类型 `Item` 通过无歧义完全限定语法指定了 `Iterator` 中的关联类型.
           type Item = <I as Iterator>::Item;

           #[inline]
           fn next(&mut self) -> Option<<I as Iterator>::Item> {
               // 此处调用了 `Rec` 中存储的迭代器的 `next_back` 方法. 这个方法实际上是在 `DoubleEndedIterator` 中定义的
               self.iter.next_back()
           }
       }
     #+end_src

     ~Rev~ 泛型结构体中只有一个成员字段 ~iter~, 只用来保存迭代器. 在为其实现
     ~Iterator~ 时, 指定了 ~DoubleEndIterator~ 限定. 并且将关联类型 ~Item~ 通过
     无歧义完全限定语法指定了 ~Iterator~ 中的关联类型.

     ~DoubleEndIterator~ 源码示意:
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       pub trait DoubleEndedIterator: Iterator {
           fn next_back(&mut self) -> Option<Self::Item>;
       }
     #+end_src
     
     看得出来, ~DoubleEndIterator~ 是 ~Iterator~ 的子 trait, 这样定义实际是为了
     扩展 ~Iterator~. ~next_back~ 和 ~next~ 方法签名非常相似, 反转遍历正是基于此
     方法来实现的.

     在执行 ~next_back()~ 方法之后, 迭代器的 "游标" *还是会回到上一次* ~next~ 执
     行的位置继续执行 ~next~, 这也是该方法命名为 ~next_back~ 的原因.

     至此, 我们就知道了 ~Rev~ 迭代器适配器的工作机制: 在 ~next~ 迭代中, 调用
     ~next_back()~ 方法. 只有实现了 ~DoubleEndIterator~ 的迭代器才有
     ~next_back()~ 方法, 也就是说, 只有实现了 ~DoubleEndIterator~ 的迭代器才能调
     用 ~Iterator::rev~ 方法进行反向遍历.
     
*** 消费器
   Rust 中的迭代器都是惰性的, 也就是说, 它们不会自动发生遍历行为, 除非调用
   ~next~ 方法去消费其中的数据. 最直接消费迭代器数据的方法就是使用 ~for~ 循环,
   前面可以了解到, ~for~ 循环会隐式地调用迭代器的 ~next~ 方法, 从而达到循环的目
   的.

   为了编程的便利性和更高的性能, Rust 也提供了 ~for~ 循环之外的用于消费迭代器内
   数据的方法, 它们叫做消费器(Consumer). 下面列出了 Rust 标准库
   ~std::iter::Iterator~ 中实现的常用消费器:
   - *any*: 其功能类似我们实现的 ~any~ 方法的功能, 可以查找容器中是否存在满足条
     件的元素
   - *fold*: 来源于函数式编程语言. 该方法接受 2 个参数, 第一个为初始值, 第二个为
     带有两个参数的闭包. 其中闭包的第一个参数被称为累加器, 它会将闭包每次迭代执
     行的结果进行累计, 并最终作为 ~fold~ 方法的返回值. 在其他语言中, 也被用作
     ~reduce~ 或 ~inject~
   - *collect*: 专门用来将迭代器转换为的指定集合类型. eg:
     ~collect::<Vec<i32>>()~ 这样的 turbofish 语法为其指定了类型, 最终迭代器就会
     被转换为 ~Vec<i32>~ 这样的数组. 因此, 它也被称为 "收集器".

**** any 和 fold
     ~any~ 和 ~fold~ 的源码示意:
     #+begin_src rust
       #[doc(spotlight)]
       #[must_use = "iterators are lazy and do nothing unless consumed"]
       pub trait Iterator {
           /// The type of the elements being iterated over.
           #[stable(feature = "rust1", since = "1.0.0")]
           type Item;

           #[inline]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn fold<B, F>(mut self, init: B, mut f: F) -> B
           where
               Self: Sized,
               F: FnMut(B, Self::Item) -> B,
           {
               let mut accum = init;
               while let Some(x) = self.next() {
                   accum = f(accum, x);
               }
               accum
           }

           #[inline]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn any<F>(&mut self, f: F) -> bool
           where
               Self: Sized,
               F: FnMut(Self::Item) -> bool,
           {
               #[inline]
               fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<(), ()> {
                   move |(), x| {
                       if f(x) { ControlFlow::BREAK } else { ControlFlow::CONTINUE }
                   }
               }

               self.try_fold((), check(f)) == ControlFlow::BREAK
           }
       }
     #+end_src

     看得出来, ~any~ 和 ~fold~ 的内部都包含了一个 ~for~ 循环, 它们实际上是通过
     ~for~ 循环来实现内部迭代器的. 内部迭代器的特点是: 一次遍历到底, 不支持
     ~return~, ~break~ 或 ~continue~ 操作, 因此可以避免一些相应的检查, 更有利于
     底层 LLVM 的优化.
     
     Rust 除了提供 ~any~ 和 ~fold~ 两个消费器(内部迭代器), 还提供了其他的内部迭
     代器, eg: ~all~, ~for_each~ 和 ~position~ 等, 可以在 ~std::iter::Iterator~
     的文档中找到它们的用法和源码. 在众多的消费器中, 最特殊的应该算 ~collect~ 消
     费器了.

**** collect 消费器
     通过签名的几个示例我们已经知道, ~collect~ 消费器有 "收集" 功能, 在语义上可
     以理解为将迭代器中的元素收集到指定的集合容器中, eg: 前面示例中所看到的
     ~collect::<Vec<i32>>()~, 就是将迭代器元素收集到 ~Vec<i32>~ 类型的动态数组容
     器中. 通过 turbofish 语法还可以指定其他的集合容器, eg:
     ~collect::<HashMap<i32, i32>>()~ 等.
     
     ~collect~ 源码示意
     #+begin_src rust
       #[doc(spotlight)]
       #[must_use = "iterators are lazy and do nothing unless consumed"]
       pub trait Iterator {
           /// The type of the elements being iterated over.
           #[stable(feature = "rust1", since = "1.0.0")]
           type Item;

           #[inline]
           #[stable(feature = "rust1", since = "1.0.0")]
           #[must_use = "if you really need to exhaust the iterator, consider `.for_each(drop)` instead"]
           fn collect<B: FromIterator<Self::Item>>(self) -> B
           where
               Self: Sized,
           {
               FromIterator::from_iter(self)
           }
       }
     #+end_src

     ~FromIterator~ 和 ~IntoIterator~ 是互为逆操作的两个 trait.

     ~FromIterator~ 源码示意:
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       #[rustc_on_unimplemented(
           message = "a value of type `{Self}` cannot be built from an iterator \
                      over elements of type `{A}`",
           label = "value of type `{Self}` cannot be built from `std::iter::Iterator<Item={A}>`"
       )]
       pub trait FromIterator<A>: Sized {
           #[stable(feature = "rust1", since = "1.0.0")]
           fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self;
       }
     #+end_src

     该 trait 只定义了唯一的泛型方法 ~from_iter~, 它的方法签名中使用了 trait 限
     定 ~IntoIterator<Item=A>~, 表示只有实现了 ~IntoIterator~ 的类型才可以作为其
     参数. 集合容器只需要实现该 trait, 就可以拥有使用 ~collect~ 消费器手机迭代器
     元素的能力.

     这里需要注意的是: 直接调用 ~MyVec::from_iter()~ 方法和使用 ~collect~ 方法的
     效果是一样的.
