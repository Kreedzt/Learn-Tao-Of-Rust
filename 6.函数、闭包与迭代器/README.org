* 函数、闭包与迭代器
  语言影响或觉得人类的思维方式.
  Rust 是一门混合范式的编程语言, 有机地融合了面向对象、函数式和方向编程范式. 它
  并非将这些特性进行简单堆砌, 而是通过高度一致性的类型系统融合了这三种范式的编程
  思想. 可以通过 ~impl~ 关键字配合结构体和 trait 来实现面向对象范式中的多态和封
  装, 也可以通过函数、高阶函数、闭包、模式匹配来实现函数式范式中的一些编程工具.
  Rust 支持 0 成本静态分发的泛型编程, 并且将它很好地融入了其他两种编程范式中, 提
  供了更高的抽象层次. 通过将这三种编程范式完美融合起来, Rust 语言拥有了更高程度
  的抽象以及更强的表达能力.

  函数式语言的历史要比面向对象语言悠久, 它源自古老的 LISP 语言, 其后发明的语言或
  多或少都受到了函数式编程思想的影响, eg: Python, Ruby, 以及更纯的函数式语言
  HasKell. 随着摩尔定律的失效, CPU 性能的提升转为主要依赖核数的增加, 多核时代到
  来后, 函数式编程因为其天生对并发友好的特性又逐渐受到了重视. 所以近年来很多新诞
  生的语言也吸收了函数式范式的诸多特性, eg: Elixir, Scala, Swift 都收到了 LISP
  和 HasKell 的影响, 对代数数据类型(algebraic data type)、模式匹配、高阶函数、闭
  包等特性各有所支持. 甚至一些年代久远的主流语言, eg: C++ 和 Java 也都开始吸收函
  数式语言的特性. Rust 作为一门在多核时代诞生的现代编程语言, 引入函数式编程范式
  完全是顺势而为的.

  本章内容主要从函数和闭包 2 个方面来探讨 Rust 对函数式编程范式的支持, 还会讲迭
  代器及其在闭包中的应用.
  
** 函数
   对于一段重复执行的代码, 可以将其定义为一个函数, 方便调用.

   *fn* 关键字后面为函数名称, 通常以 *蛇形命名法(snake_case)* 命名, 否则编译器会
   发出警告. 函数参数必须明确地指定类型, 如果有返回值也必须指定返回值的类型. 需
   要注意的是, Rust 中的函数参数 *不能指定默认值*. 函数体被包含于花括号之内, 出
   函数体之外的函数声明为 *函数签名*. 可以说, 一个函数是由函数签名和函数体组合
   而成的.

   一般来说, 函数定义时不允许直接使用语言中的保留字和关键字作为函数名. 但是在
   *Rust 2018* 中, 通过将原生标识操作符(Raw Identifier) *r#* 作为前缀, 即可使用
   关键字为函数命名, 该语法一般用于 FFI 中, 用于避免 C 函数名和 Rust 的关键字或
   保留字重名而引起的冲突.

   通过前面的张姐我们了解到, 函数 ucanshu 可以按值传递, 也可以按引用传递. 当参数按
   值传递时, 会转移所有权或执行复制(Copy)语义. 当参数按引用传递时, 所有权不会发
   生变化, 但是需要有生命周期参数. 当符合生命周期参数省略规则时, 编译器可以通过
   自动推断补齐参数的生命周期参数, 否则, 需要显示地为参数标明生命周期参数.

   函数参数也分为可变和不可变. Rust 的函数参数默认不可变, 当需要可变操作的时候,
   需要使用 ~mut~ 关键字来修饰.

*** 函数屏蔽
    当声明变量之后, 如果再次声明同名的变量绑定, 则之前的变量绑定会被屏蔽, 这叫做
    变量遮蔽(variable shadow). 变量可以如此, 但 *函数不能被多次定义*.

    可以通过显式地使用花括号将同名的函数分隔到不同的作用域中, 这样编译器就不会报
    错. 也就是说, 在同一个作用域中不能定义多个同名函数, 因为 *默认的函数定义只在
    当前作用域内有效*, 会屏蔽作用域外的同名函数.

*** 函数模式匹配
    函数中的参数等价于一个隐式的 let 绑定, 而 let 绑定本身是一个模式匹配的行为.
    所以函数参数也支持模式匹配.

    参数使用 ~ref~ 关键字来修饰:意味着要使用模式匹配来获取参数的不可变引用. 与
    ~ref~ 相对的是 ~ref mut~, ~ref mut~ 用来匹配可变引用.

    除了 ~ref~ 和 ~ref mut~, 函数参数也可以使用通配符(~_~)来忽略参数.

    实现某个 trait 中的方法时, 有时并不会用到其函数签名中声明的所有权参数, 这时
    可以使用通配符来进行忽略, 这样不会引起编译错误.

    Rust 中的 let 语句可以通过模式匹配解构元组(Tuple), 函数参数也可以. 若只想解
    构元组中的单个值, 则使用通配符将其他值忽略掉即可.

*** 函数返回单元值
    Rust 中的函数只能有唯一的返回值, 即使没有显式返回值的函数, 其实也相当于返回
    了一个单元值 ~()~. 如果乳摇返回多个值, 亦可使用元组类型.

    Rust 语言提供了 ~return~ 关键字来返回函数中的值. 对于只需要返回函数体最后一
    行 表达式所求值的函数, ~return~ 可以省略. 在某些控制结构中, eg: 循环或条件分
    支, 则需要显式地使用 ~return~ 关键字来返回.

    第二张中出现的函数返回类型为 "~!~" 的发散函数(diverging function), 此类函数
    *永远不会有任何返回值*.
    
*** 泛型函数
    Rust 的函数也支持泛型. 通过实现 泛型函数, 可以节省很多工作量.

    当编译器无法自动类型时, 需要显式地指定函数调用的类型, 使用 turbofish 操作符
    ~::<>~ 指定具体类型.

*** 方法与函数
    Rust 中的 *方法和函数是有区别的*. 方法来自面向对象的编程范式, 在语义上, 它代
    表某个实例对象的行为. 函数只是一段简单的代码, 它可以通过名字来进行调用. 方法
    也是通过名字来进行调用的, 但它必须关联一个 *方法接受者*.
    
*** 高阶函数
    在数学和计算机科学里均有高阶函数的定义. 在数学中, 高阶函数也叫算子或泛函.
    eg: 微积分中的导数就是一个函数到另一个函数的映射. 在计算机科学里, 高阶函数是
    指以函数作为参数或返回值的函数, 它也是函数式编程语言最基础的特性. Rust 语言
    也支持高阶函数, 因为函数在 Rust 中是一等公民.
    
    实现这一切的基础在于 Rust 支持类似 C/C++ 语言中的 *函数指针*.
    函数指针:　指向函数的指针, 其值为函数的地址.

    声明函数指针类型时, *必须显式指定函数指针类型 ~fn()~, 以及赋值的是函数名*.

    对于函数指针类型, 可以使用 ~type~ 关键字为其定义别名, 便于提升代码的可读性.

** 闭包
   *闭包(Closure)* 通常是指词法闭包, 是一个持有外部环境变量的函数. *外部环境* 是
   指闭包定义时所在的词法作用域. 外部环境变量, 在函数式编程范式中也被称为 *自由
   变量*, 是指并不是在闭包内定义的变量. *将自由变量和自身绑定的函数就是闭包*.

   *注意*: 此处闭包类型为 ~Fn(i32) -> i32~, 以大写字母 F 开头的 ~Fn~ 并不是函数
   指针类型 ~fn(i32) -> i32~, 它是一个 trait, 本章后面的章节有更详细的介绍.

   闭包包含以下来钟特性:

   - *延迟执行*: 返回的闭包只有在需要调用的时候才会执行
   - *捕获环境变量*: 闭包会获取其定义时所在作用域中的自由变量, 以供之后调用时使
     用.

*** 闭包的基本语法
    Rust 的闭包语法形式参考了 Ruby 语言的 lambda 表达式.

    闭包由 *管道符* (两个对称的竖线)和花括号(或圆括号)组合而成. 管道符里是闭包函
    数的参数, 可以像普通函数参数那样在冒号后面添加类型标注, 也可以省略为以下形
    式:
    #+begin_src rust
      let add = |a, b| -> i32 { a + b };
    #+end_src

    花括号里包含的是闭包函数执行体, 花括号和返回值也可以省略:
    #+begin_src rust
      let add = |a, b| a + b;
    #+end_src

    当闭包函数没有参数只有捕获的自由变量时, 管道符里的参数也可省略:
    #+begin_src rust
      let (a, b) = (1, 2);
      let add = || a + b;
    #+end_src

    闭包的参数可以是任意类型的. 
    
    # Rust 2018 已修复:
    # 但两个定义一模一样的闭包也并不一定属于同一种类型.

*** 闭包的实现
    闭包类型与 Rust 类型系统提供的常规类型不同, 它是由编译器制造的临时存在的闭包
    实例类型.

    *其实在 Rust 中, 闭包是一种语法糖*. 也就是说, 闭包不属于 Rust 语言提供的基本
    语法要素, 而是在基本语法功能之上又提供的一层方便开发者编程的语法. 闭包和普
    通函数的差别就是闭包可以捕获环境中的自由变量.

    若想要实现自己的闭包, 可以使用指针. 闭包 ~||{a + b}~ 的实现可以通过函数指针
    和捕获变量指针组合来实现. 指针放在栈上, 捕获变量放到堆上. 实际上, 早期的
    Rust 版本实现闭包就采用了类似的方式. 因为要把闭包捕获变量放到堆上, 所以称其
    为 *装箱(Boxed)闭包*. 这种方式带来的问题就是影响性能. Rust 是基于 LLVM 的语
    言, 这种闭包实现的方式使得 LLVM 难以对其进行内联和优化.

    
    所以 Rust 团队又对闭包的实现做了重大改进, 也就是当前版本中的闭包实现方式. 改
    进方案为 *非装箱(Unboxed)闭包*, 此方案是 Rust 语言一致性的再一次提现.

    非装箱闭包方案有三个目标:

    - 可以让用户更好地控制优化
    - 支持闭包按值和按引用绑定环境变量
    - 支持三种不同的闭包访问: 对应 ~self~, ~&self~ 和 ~&mut self~ 三种方法

    实现这三个目标的核心思想是: 通过增加 trait 将函数调用变为可重载的操作符.
    eg: 将 ~a(b, c, d)~ 这种函数调用变为如下形式:
    #+begin_src rust
      Fn::call(&a, (b, c, d));
      FnMut::call_mut(&mut a, (b, c, d));
      FnOnce::call_once(a, (b, c, d));
    #+end_src

    Rust 增加的这三个 trait 分别就是 ~Fn~, ~FnMut~ 和 ~FnOnce~.

    在 Rust 源码中的定义如下所示:
    #+begin_src rust
      #[lang = "fn"]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[rustc_paren_sugar]
      #[rustc_on_unimplemented(
          on(
              Args = "()",
              note = "wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}"
          ),
          message = "expected a `{Fn}<{Args}>` closure, found `{Self}`",
          label = "expected an `Fn<{Args}>` closure, found `{Self}`"
      )]
      #[fundamental] // so that regex can rely that `&str: !FnMut`
      #[must_use = "closures are lazy and do nothing unless called"]
      pub trait Fn<Args>: FnMut<Args> {
          /// Performs the call operation.
          #[unstable(feature = "fn_traits", issue = "29625")]
          extern "rust-call" fn call(&self, args: Args) -> Self::Output;
      }

      #[lang = "fn_mut"]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[rustc_paren_sugar]
      #[rustc_on_unimplemented(
          on(
              Args = "()",
              note = "wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}"
          ),
          message = "expected a `{FnMut}<{Args}>` closure, found `{Self}`",
          label = "expected an `FnMut<{Args}>` closure, found `{Self}`"
      )]
      #[fundamental] // so that regex can rely that `&str: !FnMut`
      #[must_use = "closures are lazy and do nothing unless called"]
      pub trait FnMut<Args>: FnOnce<Args> {
          /// Performs the call operation.
          #[unstable(feature = "fn_traits", issue = "29625")]
          extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output;
      }


      #[lang = "fn_once"]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[rustc_paren_sugar]
      #[rustc_on_unimplemented(
          on(
              Args = "()",
              note = "wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}"
          ),
          message = "expected a `{FnOnce}<{Args}>` closure, found `{Self}`",
          label = "expected an `FnOnce<{Args}>` closure, found `{Self}`"
      )]
      #[fundamental] // so that regex can rely that `&str: !FnMut`
      #[must_use = "closures are lazy and do nothing unless called"]
      pub trait FnOnce<Args> {
          /// The returned type after the call operator is used.
          #[stable(feature = "fn_once_output", since = "1.12.0")]
          type Output;

          /// Performs the call operation.
          #[unstable(feature = "fn_traits", issue = "29625")]
          extern "rust-call" fn call_once(self, args: Args) -> Self::Output;
      }
    #+end_src

    这三个 trait 都标记了三个相同的属性.

    1. ~#[lang="fn/fn_mut/fn_once"]~: 表示其属于语言项(Lang Item), 分别以 ~fn~,
       ~fn_mut~, ~fn_once~ 名称来查找这三个 trait.
    2. ~#[rustc_paren_sugar]~: 表示这三个 trait 是对括号调用语法的特殊处理, 在编
       译器内部进行类型检查的时候, 仅会将最外层为圆括的情况识别为方法调用. 在类
       型签名或方法签名中有时候有尖括号, eg: ~<F:Fn(u8, u8) -> u8>~, 而此时尖括
       号你们的括号就不会被识别为方法调用.
    3. ~#[fundamental]~: 这是为了支持 trait 一致性而增加的属性, 加上此属性则被允
       许为 ~Box<T>~ 实现指定的 trait, 在此例中是这三个 ~Fn~ 系列的 trait

    函数调用分成三个 trait 与所有权系统有关:
    - ~FnOnce~ 调用常数为 ~self~, 这意味着它会转移方法接受者的所有权. 换句话说,
      就是这种方法调用只能被调用一次.
    - ~FnMut~ 调用常数为 ~&mut self~, 这意味着它会对方法接受者进行可变借用.
    - ~Fn~ 调用参数为 ~&self~, 这意味着它会对方法接受者进行不可变借用, 也就是说,
      这种方法调用可以被调用多次.

    现在函数调用被抽象成了三个 trait, 实现闭包就很简单了, 只需要用结构体代替闭包
    表达式, 然后按具体的需求为此结构体实现对应的 trait 即可. 这样的话, 每个闭包
    表达式实际上就是该闭包结构体的具体实例, 该结构体内部成员可以存储闭包捕获的变
    量, 然后在调用的时候使用即可.  

    当 ~extern~ 关键字用在 ~fn~ 前面时, 表示使用指定的 ABI(Application Binary
    Interface, 程序二进制接口).

    ~rust-call~ ABI 可以将函数参数中的元组类型做动态扩展, 以便支持可变长参数. 因
    为在 ~Fn~, ~FnMut~, ~FnOnce~ 这三个 trait 里的方法要接收闭包的参数, 而编译器
    本身并不可能知道开发者给闭包设定的参数个数, 所以这里只能传元组, 然后由
    ~rust-call~ ABI 在底层做动态扩展.

    *注意*: 使用 ~rust-call~ ABI 需要声明 ~unboxed_closures~ 特性.

    调用 ~call~, ~call_mut~ 和 ~call_once~ 方法的时候必须显式指定一个单元值为参
    数.

    ~call_once~ 调用之后, 之前的实例所有权被转移, 无法再次被使用.

    显式指定闭包类型时, 类型必须使用 *trait 对象* (见 3.4节 - trait 对象).

*** 闭包与所有权
    闭包表达式会由编译器自动翻译为结构体实例, 并为其实现 ~Fn~, ~FnMut~, ~FnOnce~
    三个 trait 中的一个. 

    *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/247][issue]]
    这三个 trait 和所有权有关系. 更准确地说, 这三个 trait 的作用如下:
    - ~Fn~: 表示闭包 *至多只存在* 以不可变借用的方式来捕获环境中的自由变量, 同时
      也表示该闭包 *没有改变环境的能力*, 并且可以多次调用. 对应 ~&self~. 
    - ~FnMut~: 表示闭包 *存在* 以可变借用的方式来捕获环境中的自由变量, 同时意味
      着该闭包 *有改变环境的能力*, 也可以多次调用. 对应 ~&mut self~
    - ~FnOnce~: 表示闭包 *存在* 通过转移所有权来捕获环境中的自由变量, 同时意味着
      该闭包 *可能* 有改变环境的能力, *取决于是否存在以可变借用的方式来捕获的环
      境中的自由变量*, 只能调用一次, 因为闭包会消耗自身. 对应 ~self~.

    第五章讲所有权系统时, 对不同环境变量类型介绍过闭包捕获其环境变量的方式:
    - 对于复制语义类型, 以不可变引用(~&T~)来进行捕获
    - 对于移动语义类型, 执行移动语义, 转移所有权来进行捕获.
    - 对于可变绑定, 并且在闭包中包含对其进行修改的操作, 则以可变引用(~&mut T~)来
      进行捕获.

    也就是说, *闭包会根据环境变量类型来决定实现哪种 trait*.

    ~FnMut~ 继承了 ~FnOnce~, ~Fn~ 又继承了 ~FnMut~. 这意味着: 如果要实现 ~Fn~,
    就必须实现 ~FnMut~ 和 ~FnOnce~; 如果要实现 ~FnMut~, 就必须实现 ~FnOnce~.

**** 使用 move 关键字自动实现 Fn
     Rust 针对闭包提供了一个关键字 *move*, 使用此关键字的作用是:
     *强制让闭包所定义环境中的自由变量转移到闭包中*.

     *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/132][issue]]
     ~FnMut~ 闭包在使用 ~move~ 关键字的时候, 如果捕获变量的复制语义类型的, 则闭包会自动
     实现 Copy/Clone; 如果捕获变量是移动语义类型的, 则闭包不会自动实现
     Copy/Clone, 这也是处于保证内存安全的考虑.

**** 修改环境变量以自动实现 FnMut
     很多时候需要通过修改环境变量的闭包来自动实现 ~FnMut~.

     实现了 ~FnMut~ 的闭包, 必然会实现 ~FnOnce~, 但不会实现 ~Fn~.

**** 未捕获任何环境变量的闭包会自动实现 Fn
     没有捕获任何自由变量的闭包, 会自动实现 ~Fn~.

**** 规则总结
     综合上面的几种情况, 可以得出如下规则:
     - 如果闭包中没有捕获任何环境变量, 则默认实现 ~Fn~.
     - 如果闭包中捕获了复制语义类型的环境变量, 则:
       + 如果不需要修改环境变量, 无论是否使用 ~move~ 关键字, 均会自动实现 ~Fn~.
       + 如果需要修改环境变量, 则自动实现 ~FnMut~
     - 如果闭包中捕获了移动语义类型的环境变量, 则:
       + 如果不需要修改环境变量, 且没有使用 ~move~ 关键字, 则自动实现 ~FnOnce~
       + 如果不需要修改环境变量, 且使用了 ~move~ 关键字, 则自动实现 ~Fn~
       + 如果需要修改环境变量, 则自动实现 ~FnMut~
     - 使用 ~move~ 关键字, 如果捕获的变量是复制语义类型的, 则闭包会自动实现
       Copy/Clone, 否则不会自动实现 Copy/Clone.

     *社区总结*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/164#issuecomment-482908447][issue]]
     | 环境变量语义 | 环境变量操作 | 有无move | 闭包trait | 换变量怎么被处理 | 闭包能否Copy |
     |--------------+--------------+----------+-----------+------------------+--------------|
     | 复制         | 读           | Y        | Fn        | copy             | Y            |
     | 复制         | 读           | N        | Fn        | immutable borrow | Y            |
     | 复制         | 修改         | Y        | FnMut     | copy             | Y            |
     | 复制         | 修改         | N        | FnMut     | mutable borrow   | N            |
     |--------------+--------------+----------+-----------+------------------+--------------|
     | 移动         | 读           | Y        | Fn        | move             | N            |
     | 移动         | 读           | N        | Fn        | immutable borrow | Y            |
     | 移动         | 修改         | Y        | FnMut     | move             | N            |
     | 移动         | 修改         | N        | FnMut     | mutable borrow   | N            |
     | 移动         | 消耗         | Y        | FnOnce    | move             | N            |
     | 移动         | 消耗         | N        | FnOnce    | move             | N            |
     
*** 闭包作为函数参数和返回值
    闭包存在于很多语言中, 尤其是动态语言, 诸如 JavaScript, Python 和 Ruby 之类,
    闭包的使用非常广泛. 但是在这些动态语言中, 闭包捕获的环境变量基本都是对象(指
    面向对象的对象, 属于引用类型), 使用不当容易造成内存泄露. 并且在这些语言中,
    闭包是在堆中分配的, 运行时动态分发, 由 GC 来回收内存, 调用和回收闭包都会消耗
    多余的 CPU 时间, 更不用说使用内联技术来优化这些闭包了. 而 Rust 使用 trait 和
    匿名结构体提供的闭包机制是非常强大的. Rust 的闭包实现受到了现代 C++ 的启发,
    将捕获的变量放到结构体重, 这样的好处就是不会占用堆内存, 拥有更高的性能, 可以
    使用内联技术来消除函数调用开销并实现其他关键的优化, eg: 对编译器自动实现闭包
    的结构体进行优化等. 从而允许在任何环境(包括裸机)中使用闭包.

    Rust 的闭包实现机制使得每个闭包表达式都是一个独立的类型, 这样可能有一些不变,
    eg: 无法将不同的闭包保存到一个数组中, 但是可以通过闭包把闭包当作 trait 对象
    来解决这个问题.

    像这种在函数 ~boxed_closure~ 调用之后才会使用的闭包, 叫作 *逃逸闭包(escape
    closure)*. 因为该闭包捕获的环境变量 "逃离" 了 ~boxed_closure~ 函数的栈帧, 所
    以在函数栈帧销毁之后依然可用. 与之相对应, 如果是跟随函数一起调用的闭包, 则是
    *非逃逸闭包(non-escape closure)*.

**** 闭包作为函数参数
     闭包可以作为函数参数, 这一点直接提升了 Rust 语言的抽象表达能力. 令其有了完
     全不弱于 Ruby, Python 这类动态语言的抽象表达能力. 下面比较了 Rust 和 Ruby
     两种语言中的 any 方法, 该方法用于按指定条件确认数组中的元素是否存在.
     Rust 语言:
     #+begin_src rust
       v.any(|&x| x == 3);
     #+end_src

     Ruby 语言:
     #+begin_src ruby
       v.any?{|i| i == 3}
     #+end_src

     看的出来, Rust 语言和 Ruby 语言中对闭包的用法基本相似.

     因为闭包属于 trait 语法糖, 所以当它被用作参数传递时, 它可以被用作泛型的
     trait 限定, 也可以直接作为 trait 对象来使用.

     动态分发比静态分发的性能低一些, 但还是晚期可以和 C++ 媲美的. 动态分发闭包在
     实际中更加常用语回调函数(callback).

     eg: Rust 的 Web 开发框架 Rocket 的中间件实现就李永乐闭包作为回调函数:
     [[https://github.com/SergioBenitez/Rocket/blob/master/core/lib/src/fairing/ad_hoc.rs][Link]]
     #+begin_src rust
       pub struct AdHoc {
           name: &'static str,
           kind: AdHocKind,
       }

       enum AdHocKind {
           // 包含的值类型是一个 trait 对象的闭包
           Request(Box<dyn for<'a> Fn(&'a mut Request<'_>, &'a Data)
               -> BoxFuture<'a, ()> + Send + Sync + 'static>),
       }

       impl AdHoc {
           // 第二个参数为一个闭包 F, 表明接受 2 个参数
           // 第一个是可变引用, 第二个是不可变引用, 并且是可以在线程中安全传递的
           // `'static` 生命周期用来约束该闭包是一个 *逃逸闭包*, 只有逃逸闭包才能装箱
           pub fn on_request<F: Send + Sync + 'static>(name: &'static str, f: F) -> AdHoc
               where F: for<'a> Fn(&'a mut Request<'_>, &'a Data) -> BoxFuture<'a, ()>
           {
               AdHoc { name, kind: AdHocKind::Request(Box::new(f)) }
           }
       }

       #[crate::async_trait]
       impl Fairing for AdHoc {
           async fn on_request(&self, req: &mut Request<'_>, data: &Data) {
               // if let 语法, 如果匹配到闭包就调用
               // 此为动态分发闭包在实际中作为回调函数的示例
               if let AdHocKind::Request(ref callback) = self.kind {
                   callback(req, data).await;
               }
           }
       }
     #+end_src

     
**** 闭包作为函数返回值
     因为闭包是 trait 语法糖, 所以无法直接作为函数的返回值, 如果要把闭包作为返回
     值, 必须使用 trait 对象.

     *以下内容已过时(FnBox相关)*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/249][issue]]
     # 早期的 Rust 中, 如果要调用闭包 ~Box<FnOnce(i32)->i32>~, 就必须把
     # ~FnOnce(i32) -> i32~ 从 ~Box<T>~ 中移出来. 而此时 ~Box<T>~ 的 ~T~ 无法在编
     # 译期确定大小, 无法转移所有权, 就报错.

     # ~FnOnce~ 装箱为 ~Box<FnOnce>~ 之后, 其对应的由编译器生成的闭包结构体实例就
     # 是 ~Box<ClosureStruct>~ 类型(假如闭包结构体名为 ClosureStruct), 该闭包结构
     # 体实现 ~FnOnce~ 的 ~call_once~ 方法额接收者本来是 ~self~, 也就是闭包结构体
     # 实例, 现在变成了 ~Box<self>~, 也就是装箱的闭包结构体实例. 现在想从
     # ~Box<self>~ 里移出 ~self~ 这个闭包结构体实例来进行调用, 因为编译期无法确定
     # 其大小, 所以无法获取 ~self~. 而对于 ~Fn~ 和 ~FnMut~ 来说, 装箱以后分别对应
     # 的是 ~&Box<self>~ 和 ~&mut Box<self>~, 所以不会报错. 对于此问题, Rust 给出
     # 了 ~FnBox~ 解决方案.

     # #+begin_src rust
     #   #![feature(fnbox)]
     #   use std::boxed::FnBox;
     #   fn square() -> Box<FnBox(i32) -> i32> {
     #       Box::new(|i| { i * i })
     #   }

     #   fn main() {
     #       let square = square();
     #       assert_eq!(4, square(2));
     #   }
     # #+end_src

     # ~Fnbox~ 是一个调用语法糖, 因为使用了 ~#[rustc_paren_sugar]~ 属性, 该 trait
     # 实现了 ~call_box~ 方法, 第一个参数和之前的 ~Fn~, ~FnMut~, ~FnOnce~ 定义的方
     # 法有很大的不同, 该方法的第一个参数 ~self~ 是 ~Box<Self>~ 类型.

     # 理论上, ~self: SomeType<Self>~ 这种形式应该适用于任意类型(SomeType), 但实际
     # 上, 这里只支持 ~Box<T>~. 所以, ~self:Box<Self>~ 这种类型指定会自动解引用并
     # 移动 ~Self~ 的所有权, 因为 ~Box<T>~ 支持 DerefMove(第五章).

     # ~Self:Box<self>~ 是通过调用 ~call_box~ 来间接调用 ~call_once~ 的, 因为
     # ~Box<FnBox>~ 实现了 ~FnOnce~. 这看上去完全是一个 "曲线救国" 的方案, 所以,
     # 在装箱时使用 ~FnBox~ 来替代 ~FnOnce~ 只是临时的解决方案, 在现在的 Rust 版本
     # 中, 已弃用.

     # 出现这种问题的根本原因在于, Rust 中的函数返回值只能出现类型. 虽然有对象可用,
     # 但是性能上也会有所损耗. 为了解决此问题, Rust 团队提出了一个新的方案, 叫
     # ~impl Trait~ 语法, 该方案可以让函数 *直接返回一个 trait*.
     
     使用 ~impl Trait~ 语法, 该方案可以让函数 *直接返回一个 trait*. 此语法代表的
     是实现了指定 trait 的那些类型, 相当于泛型, 属于 *静态分发*.

     
*** 高阶生命周期
    闭包可以作为函数的参数和返回值, 那么闭包参数中如果含有引用的话, 声明周期参数
    该如何标注?

    Rust 针对无法直接获取关系的生命周期提供了 *高阶生命周期* (Higher-Ranked
    Lifetime), 也叫 *高阶 trait 限定* (Higher-Ranked Trait Bound, HRTB). 该方案
    提供了一个 ~for<>~ 语法.

    ~for<>~ 语法整体表示此生命周期参数 *只针对* 其后面所跟着的 "对象", 在本例中
    是 ~DoSomething<&'f usize>~, 就代表 ~bar~ 函数的生命周期和 ~DoSomething<&'f
    usize>~ 没有直接关系, 所以编译正常.

    实际开发中会经常使用闭包, 而闭包实现的三个 trait 本身也是泛型 trait, 所以肯
    定也存在闭包参数和返回值都是引用类型的情况.

    *注意*: 高阶声明周期的 ~for<>~ 语法 *只能用于标注生命周期参数*, 而不能用于其
    他泛型类型.
