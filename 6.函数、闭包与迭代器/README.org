* 函数、闭包与迭代器
  语言影响或觉得人类的思维方式.org
  Rust 是一门混合范式的编程语言, 有机地融合了面向对象、函数式和方向编程范式. 它
  并非将这些特性进行简单堆砌, 而是通过高度一致性的类型系统融合了这三种范式的编程
  思想. 可以通过 ~impl~ 关键字配合结构体和 trait 来实现面向对象范式中的多态和封
  装, 也可以通过函数、高阶函数、闭包、模式匹配来实现函数式范式中的一些编程工具.
  Rust 支持 0 成本静态分发的泛型编程, 并且将它很好地融入了其他两种编程范式中, 提
  供了更高的抽象层次. 通过将这三种编程范式完美融合起来, Rust 语言拥有了更高程度
  的抽象以及更强的表达能力.

  函数式语言的历史要比面向对象语言悠久, 它源自古老的 LISP 语言, 其后发明的语言或
  多或少都受到了函数式编程思想的影响, eg: Python, Ruby, 以及更纯的函数式语言
  HasKell. 随着摩尔定律的失效, CPU 性能的提升转为主要依赖核数的增加, 多核时代到
  来后, 函数式编程因为其天生对并发友好的特性又逐渐受到了重视. 所以近年来很多新诞
  生的语言也吸收了函数式范式的诸多特性, eg: Elixir, Scala, Swift 都收到了 LISP
  和 HasKell 的影响, 对代数数据类型(algebraic data type)、模式匹配、高阶函数、闭
  包等特性各有所支持. 甚至一些年代久远的主流语言, eg: C++ 和 Java 也都开始吸收函
  数式语言的特性. Rust 作为一门在多核时代诞生的现代编程语言, 引入函数式编程范式
  完全是顺势而为的.

  本章内容主要从函数和闭包 2 个方面来探讨 Rust 对函数式编程范式的支持, 还会讲迭
  代器及其在闭包中的应用.
  
** 函数
   对于一段重复执行的代码, 可以将其定义为一个函数, 方便调用.

   *fn* 关键字后面为函数名称, 通常以 *蛇形命名法(snake_case)* 命名, 否则编译器会
   发出警告. 函数参数必须明确地指定类型, 如果有返回值也必须指定返回值的类型. 需
   要注意的是, Rust 中的函数参数 *不能指定默认值*. 函数体被包含于花括号之内, 出
   函数体之外的函数声明为 *函数签名*. 可以说, 一个函数是由函数签名和函数体组合
   而成的.

   一般来说, 函数定义时不允许直接使用语言中的保留字和关键字作为函数名. 但是在
   *Rust 2018* 中, 通过将原生标识操作符(Raw Identifier) *r#* 作为前缀, 即可使用
   关键字为函数命名, 该语法一般用于 FFI 中, 用于避免 C 函数名和 Rust 的关键字或
   保留字重名而引起的冲突.

   通过前面的张姐我们了解到, 函数 ucanshu 可以按值传递, 也可以按引用传递. 当参数按
   值传递时, 会转移所有权或执行复制(Copy)语义. 当参数按引用传递时, 所有权不会发
   生变化, 但是需要有生命周期参数. 当符合生命周期参数省略规则时, 编译器可以通过
   自动推断补齐参数的生命周期参数, 否则, 需要显示地为参数标明生命周期参数.

   函数参数也分为可变和不可变. Rust 的函数参数默认不可变, 当需要可变操作的时候,
   需要使用 ~mut~ 关键字来修饰.

*** 函数屏蔽
    当声明变量之后, 如果再次声明同名的变量绑定, 则之前的变量绑定会被屏蔽, 这叫做
    变量遮蔽(variable shadow). 变量可以如此, 但 *函数不能被多次定义*.

    可以通过显式地使用花括号将同名的函数分隔到不同的作用域中, 这样编译器就不会报
    错. 也就是说, 在同一个作用域中不能定义多个同名函数, 因为 *默认的函数定义只在
    当前作用域内有效*, 会屏蔽作用域外的同名函数.

*** 函数模式匹配
    函数中的参数等价于一个隐式的 let 绑定, 而 let 绑定本身是一个模式匹配的行为.
    所以函数参数也支持模式匹配.

    参数使用 ~ref~ 关键字来修饰:意味着要使用模式匹配来获取参数的不可变引用. 与
    ~ref~ 相对的是 ~ref mut~, ~ref mut~ 用来匹配可变引用.

    除了 ~ref~ 和 ~ref mut~, 函数参数也可以使用通配符(~_~)来忽略参数.

    实现某个 trait 中的方法时, 有时并不会用到其函数签名中声明的所有权参数, 这时
    可以使用通配符来进行忽略, 这样不会引起编译错误.

    Rust 中的 let 语句可以通过模式匹配解构元组(Tuple), 函数参数也可以. 若只想解
    构元组中的单个值, 则使用通配符将其他值忽略掉即可.

*** 函数返回单元值
    Rust 中的函数只能有唯一的返回值, 即使没有显式返回值的函数, 其实也相当于返回
    了一个单元值 ~()~. 如果乳摇返回多个值, 亦可使用元组类型.

    Rust 语言提供了 ~return~ 关键字来返回函数中的值. 对于只需要返回函数体最后一
    行 表达式所求值的函数, ~return~ 可以省略. 在某些控制结构中, eg: 循环或条件分
    支, 则需要显式地使用 ~return~ 关键字来返回.

    第二张中出现的函数返回类型为 "~!~" 的发散函数(diverging function), 此类函数
    *永远不会有任何返回值*.
    
*** 泛型函数
    Rust 的函数也支持泛型. 通过实现 泛型函数, 可以节省很多工作量.

    当编译器无法自动类型时, 需要显式地指定函数调用的类型, 使用 turbofish 操作符
    ~::<>~ 指定具体类型.

*** 方法与函数
    Rust 中的 *方法和函数是有区别的*. 方法来自面向对象的编程范式, 在语义上, 它代
    表某个实例对象的行为. 函数只是一段简单的代码, 它可以通过名字来进行调用. 方法
    也是通过名字来进行调用的, 但它必须关联一个 *方法接受者*.
    
*** 高阶函数
    在数学和计算机科学里均有高阶函数的定义. 在数学中, 高阶函数也叫算子或泛函.
    eg: 微积分中的导数就是一个函数到另一个函数的映射. 在计算机科学里, 高阶函数是
    指以函数作为参数或返回值的函数, 它也是函数式编程语言最基础的特性. Rust 语言
    也支持高阶函数, 因为函数在 Rust 中是一等公民.
    
    实现这一切的基础在于 Rust 支持类似 C/C++ 语言中的 *函数指针*.
    函数指针:　指向函数的指针, 其值为函数的地址.

    声明函数指针类型时, *必须显式指定函数指针类型 ~fn()~, 以及赋值的是函数名*.

    对于函数指针类型, 可以使用 ~type~ 关键字为其定义别名, 便于提升代码的可读性.
