* 模块化编程
  模块化编程, 是指可以把整个代码分成小块的、分散的、独立的代码块, 这些独立的代码
  块就被称为 *模块*. 把一个复杂的软件系统按一定的信息分割为彼此独立的模块, 有利
  于控制和客服系统的复杂性. 模块化开发除支持多人协作之外, 还支持各部分独立开发、
  测试和系统集成, 甚至可以限制程序错误的影响范围. 总的来说, 模块化编程有如下三点
  好处:

  - *增强维护性*: 一个设计良好的模块, 独立性更高, 对外界的依赖更少, 更方便维护
  - *隔离性*: 拥有各自的命名空间, 避免命名冲突, 限制错误范围等.
  - *代码复用*: 通过引入现成的模块来避免代码复制

  但是只有模块还不足以高效编写结构化的软件系统. 为了方便地继承第三方开发的功能模
  块, 一个简单的解决办法就是按照约定的目录结构来组织模块, 并把此目录结构进一步打
  包成一个独立的模块, 以方便外部集成. 这种按约定的目录结构打包的模块, 就被称为 
  *包*. 在编写一个包的时候, 也难免会依赖第三方包, 而这些被依赖的包也随时可能被更
  新、修改、升级, 所以一般使用版本化管理. 包与包之间的版本依赖关系, 手工处理起来
  比较麻烦, 所以需要使用包管理工具来解决依赖、打包、编译、安装等功能. 
  
  Rust 作为现代化的编程语言, 强有力地支持模块化编程. Rust 中的包管理工具叫做
  *Cargo*, 第三方包叫做 *crate*. Rust 拥抱开源, 所有的第三方包都可以在 Github 上
  面找到, 并且可以通过 Cargo 直接诶发布到包仓库平台 crates.io 上面.

** 包管理
   与其他大多数语言不同的是: 使用 Rust 编写代码的最基本单位是包(crate). Rust 语言
   内置了包管理器 Cargo, 通过使用 Cargo 可以方便地创建包.

   *Cargo 一共做了 4 件事情*:
   1. 使用两个元数据(metadata)文件来记录各种项目信息
   2. 获取并构建项目的依赖关系
   3. 使用正确的参数调用 rustc 或其他构建工具来构建项目
   4. 为 Rust 生态系统开发建立了统一标准的工作流

   通过 Cargo 提供的命令可以很方便地管理包
   
*** 使用 Cargo 创建包
    使用 ~cargo new csv-read --lib~ 命令可以创建一个包, 该包包含的文件有
    ~Cargo.toml~ 和 ~src/lib.rs~, 其中 ~Cargo.toml~ 是包的配置文件, 是使用
    *TOML* 语言编写的. TOML 语言的特色是: 规范简单、语义明显、阅读性高. TOML 专
    门被设计为可以无歧义地映射为哈希表, 从而可以更容易地被解析为各种语言中的数据
    结构. 而 ~Cargo.toml~ 正是元数据文件之一.

    #+begin_src toml
      [package]
      # 包名
      name = "csv-read"
      version = "0.1.0"
      authors = ["Kreedzt <zhaozisong1@live.com>"]
      # Rust 版本
      edition = "2018"

      # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

      [dependencies]

    #+end_src
    
    以上展示了 ~Cargo.toml~ 文件的内容(manifest 文件), 里面记录了用于编译整个包所
    用到的元数据.

    从 Rust 1.30 版本开始, 默认创建的 crate 都会带有 *edition* 选项, 其默认设置
    为 "2018". 这代表默认 crate 使用 *Rust 2018* 版本. 如果有需要, 也可以将其修
    改为 "2015", 以便支持 *Rust 2015 版本*.

    在 ~src/lib.rs~ 中, 初始内容只有 tests 模块. 在 Rust 中使用关键字 mod 来定义
    模块. ~#[cfg(test)]~ 属性为条件编译, 告诉编译器只在运行调试(cargo test 命令)
    时才编译执行. 在 tests 模块中, 生成了一个示例方法 ~it_works()~. 只要进入该包
    的根目录下, 然后执行 ~cargo test~ 命令, 即可看到测试正常运行.

    Rust 也支持在文档注释里写测试

    测试完成后, 项目会多一个 *Cargo.lock* 文件和 target 文件夹. Cargo.lock 是另
    外一个元数据文件, 它和 Cargo.toml 的不同点如下:

    - Cargo.toml 是由开发者编写的, 从广义上来描述项目所需要的各种信息, 包括第三
      方包的依赖
    - Cargo.lock 只记录依赖包的详细信息, 不需要开发者维护, 而是由 Cargo 自动维护
      的.

    target 文件夹是专门用于存储编译后的目标文件的. 编译默认为 *Debug* 模式, 在该
    模式下编译器不会对代码进行任何优化, 所以编译时间较短, 代码运行速度较慢. 也可
    以使用 *--release* 参数来使用发布模式, 在该模式下, 编译器会对代码进行优化,
    使得编译时间变慢, 但是代码运行速度会变快.

    *警告*: 内容有改动, 见 [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/17][issue]]
    使用 *cargo new --lib* 命令创建的是库文件(生成静态或动态链接库), 它并非可执行
    文件. 使用 *cargo new* 或增加 *--lib* 参数创建的包可被编译为可执行文件.

    在包的根目录下执行 ~cargo build~ 命令可以编译包, ~cargo run~ 可以编译并允许
    该包.

*** 使用第三方包
    在日常开发中, 经常会使用到第三方包. 在 Rust 中使用第三方包非常简单, 只需要在
    Cargo.toml 中的 *[dependencies]* 下面添加想依赖的包即可

    *注意*:
    - 使用 ~extern crate~ 声明引用第三方包是 Rust 2015 版本的写法. 2018 版本中,
      可以省略
    - 使用包名时, 使用下划线替代中横线(强制替换)
    
**** 使用正则表达式 regex 包
     regex 包支持大部分正则功能, 但 *不支持环视(look-around)* 和 *反向引用
     (backreference)*. 这是因为 regex 注重性能和安全, 而环视和反向引用更容易被黑
     客利用制造 *ReDos* 攻击. 如果一定要使用环视和反向引用, 则可以使用
     *fancy-regex* 包.

     regex 包支持多种正则表达式标记, 意义如下:
     - *i*: 匹配时不区分大小写
     - *m*: 多行模式, "^" 和 "$" 对应行首行尾
     - *s*: 允许通配符 "." 匹配 "\n"
     - *U*: 交换 "x*" 和 "x*?" 的意义
     - *u*: 允许支持 Unicode(默认启用).
     - *x*: 忽略 空格并允许注释(以 "#" 开头)

**** 惰性静态初始化 lazy_static 包
     在编程中, 经常会有对全局常量或变量的需求. 
     Rust 支持两种全局类型: *普通常量(Constant)* 和 *静态变量(Static)*. 它们的异
     同之处在于以下几点:

     - 都是在编译期求值的, 所以不来用于存储需要动态分配内存的类型. eg:
       ~HashMap~, ~Vector~ 等
     - 普通常量是可以被内联的, 它没有确定的内存地址, 不可变.
     - 静态变量不能呗内联, 它又精确的内存地址, 拥有静态生命周期.
     - 静态变量可以通过内部包含 ~UnsafeCell~ 等的容器实现内部可变性
     - 静态变量还有其他限制: eg: 不包货任何析构函数、包含的值类型必须实现了
       ~Sync~ 以保证线程安全、不能引用其他静态变量
     - 普通常量也不能引用静态变量.

     *在存储的数据比较大、需要引用地址或具有可变性的情况下使用静态变量*; 否则, 
     *应该优先使用普通常量*. 但也有一些情况是这两种全局类型无法满足的, eg: 想使
     用全局的 ~HashMap~ 或 ~Vector~, 或者在使用正则表达式时只让其编译一次来提升
     性能. 在这种情况下, 推荐使用 lazy_static 包.

     利用 lazy_static 包可以把定义全局静态变量延迟到运行时, 而非编译时, 所以冠之
     以 "惰性(lazy)". 
     
     使用 ~mod~ 关键字定义的模块, 内部定义的变量或方法默认是私有的. 要喜爱那个药
     模块外调用内部常量或方法, 必须通过 *pub* 关键字将可见性改为公开的.

     在使用 ~lazy_static!~ 宏时, 必须严格按照宏内语法的格式来书写, 否则会引发线
     程恐慌.

     想在多线程访问变量, 然而变量类型没有实现 ~Sync~ 时, 必须使用 *同步锁* 或 
     *互斥锁* 来包装.

     ~RwLock~ 与 ~Mutex~ 区别:
     - ~Rwlock~ 读写锁是 *多读单写* 锁, 也叫共享独占锁. 它允许多个线程读, 单个线
       程写. 但是在写的时候, 只能有一个线程占有写锁; 而在读的时候, 允许任意线程
       获取读锁. 读锁和写锁 *不能被同时获取*
     - ~Mutex~ 互斥锁: 只允许 *单个线程读和写*

     所以在读数据比较频繁远远大于写数据的情况下, 使用 ~RwLock~ 读写锁可以给程序
     带来更高的并发支持. 在下一章会对它们做更详细的介绍.

     使用 ~RwLock~ 时, 操作数据要注意 *读写隔离*, 读锁和写锁不能同一作用域获取,
     否则会造成死锁情况. 在 Rust 中, 叫做 "*中毒(Poison)*".

     *其他注意事项*:
     - 使用 ~lazy_static!~ 宏定义的全局静态变量如果有析构函数, 则是 *不会被调用
       的*, 因为是静态生命周期
     - 在 ~lazy_static!~ 宏中不能定义太多的全局静态变量, 否则会引发线程恐慌. 这
       是因为在 ~lazy_static!~ 宏中调用了内部的宏, *Rust 对宏的递归调用有次数限
       制*. 可以通过在当前编写的包中加上 ~#![recurison_limit="128"]~ 属性修改上
       限, 默认值为 32.

     在不久的将来, Rust 的 CTFE(编译时函数执行)功能进一步完善之后, 在某些场景中
     也许就不需要使用 lazy_static 包了.
     
**** 指定第三方包的依赖关系
     Rust 包使用的是 *语义化版本号* (SemVer). 基本格式为 "X.Y.Z", 版本号递增规则
     如下:

     - X: 主版本号(major). 当做了不兼容或颠覆性的更新时, 修改此版本号
     - Y: 次版本号(minor). 当做了向下兼容的功能性修改时, 修改此版本号.
     - Z: 修订版本号(patch). 当做了向下兼容的问题修正时, 修改此版本号

     语义化版本号是为了解决 "依赖地狱" 的问题. 随着系统规模的增长, 加入的第三方
     包就会越来越多, 包之间的依赖关系也会越来越复杂, 容易造成 "依赖地狱".

     指定版本号范围的标记有以下几种:
     - *补注号(^)*: 允许新版本号在不修改[major, minor, patch] 中最左边非零数字的
       情况下才能更新.
     - *通配符(*)*: 可以用在 [major, minor, patch] 的任何一个上面.
     - *波浪线(~)*: 允许修改 [major, minor, patch] 中没有明确指定的版本号.
     - *手动指定*: 通过 >, >=, <, <=, = 来指定版本号
       
     #+begin_example
       // := 表示等价于
       // 补注号示例
       ^1.2.3  :=  >=1.2.3  <2.0.0
       ^1.2  :=  >=1.2.0  <2.0.0
       ^1  :=  >=1.0.0  <2.0.0
       ^0.2.3  :=  >=0.2.3  <0.3.0
       ^0.0.3  :=  >=0.0.3  <0.0.4
       ^0.0  :=  >=0.0.0  <0.1.0

       // 通配符示例
       :=  >= 0.0.0
       1.*  :=  >=1.0.0  <2.0.0
       1.2.*  :=  >=1.2.0  <1.3.0

       // 波浪线示例
       ~1.2.3  :=  >=1.2.3  <1.3.0
       ~1.2  :=  >=1.2.0  <1.3.0
       ~1  :=  >=1.0.0  <2.0.0

       // 手动指定
       >= 1.2.0
       > 1
       < 2
       = 1.2.3

       // 手动指定多个版本
       >= 1.2, < 1.5
     #+end_example
     
     可以直接指定 git 仓库地址
     #+begin_src toml
       [dependencies]
       rand = { git = "https://github.com/rust-lang-nursery/rand" }
     #+end_src

     可以使用 path 来指定本地包
     #+begin_src toml
       [dependencies]
       hello_world = { path = "hello_world", version = "0.1.0" }
     #+end_src

     
