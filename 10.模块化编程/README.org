* 模块化编程
  模块化编程, 是指可以把整个代码分成小块的、分散的、独立的代码块, 这些独立的代码
  块就被称为 *模块*. 把一个复杂的软件系统按一定的信息分割为彼此独立的模块, 有利
  于控制和客服系统的复杂性. 模块化开发除支持多人协作之外, 还支持各部分独立开发、
  测试和系统集成, 甚至可以限制程序错误的影响范围. 总的来说, 模块化编程有如下三点
  好处:

  - *增强维护性*: 一个设计良好的模块, 独立性更高, 对外界的依赖更少, 更方便维护
  - *隔离性*: 拥有各自的命名空间, 避免命名冲突, 限制错误范围等.
  - *代码复用*: 通过引入现成的模块来避免代码复制

  但是只有模块还不足以高效编写结构化的软件系统. 为了方便地继承第三方开发的功能模
  块, 一个简单的解决办法就是按照约定的目录结构来组织模块, 并把此目录结构进一步打
  包成一个独立的模块, 以方便外部集成. 这种按约定的目录结构打包的模块, 就被称为 
  *包*. 在编写一个包的时候, 也难免会依赖第三方包, 而这些被依赖的包也随时可能被更
  新、修改、升级, 所以一般使用版本化管理. 包与包之间的版本依赖关系, 手工处理起来
  比较麻烦, 所以需要使用包管理工具来解决依赖、打包、编译、安装等功能. 
  
  Rust 作为现代化的编程语言, 强有力地支持模块化编程. Rust 中的包管理工具叫做
  *Cargo*, 第三方包叫做 *crate*. Rust 拥抱开源, 所有的第三方包都可以在 Github 上
  面找到, 并且可以通过 Cargo 直接诶发布到包仓库平台 crates.io 上面.

** 包管理
   与其他大多数语言不同的是: 使用 Rust 编写代码的最基本单位是包(crate). Rust 语言
   内置了包管理器 Cargo, 通过使用 Cargo 可以方便地创建包.

   *Cargo 一共做了 4 件事情*:
   1. 使用两个元数据(metadata)文件来记录各种项目信息
   2. 获取并构建项目的依赖关系
   3. 使用正确的参数调用 rustc 或其他构建工具来构建项目
   4. 为 Rust 生态系统开发建立了统一标准的工作流

   通过 Cargo 提供的命令可以很方便地管理包
   
*** 使用 Cargo 创建包
    使用 ~cargo new csv-read --lib~ 命令可以创建一个包, 该包包含的文件有
    ~Cargo.toml~ 和 ~src/lib.rs~, 其中 ~Cargo.toml~ 是包的配置文件, 是使用
    *TOML* 语言编写的. TOML 语言的特色是: 规范简单、语义明显、阅读性高. TOML 专
    门被设计为可以无歧义地映射为哈希表, 从而可以更容易地被解析为各种语言中的数据
    结构. 而 ~Cargo.toml~ 正是元数据文件之一.

    #+begin_src toml
      [package]
      # 包名
      name = "csv-read"
      version = "0.1.0"
      authors = ["Kreedzt <zhaozisong1@live.com>"]
      # Rust 版本
      edition = "2018"

      # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

      [dependencies]

    #+end_src
    
    以上展示了 ~Cargo.toml~ 文件的内容(manifest 文件), 里面记录了用于编译整个包所
    用到的元数据.

    从 Rust 1.30 版本开始, 默认创建的 crate 都会带有 *edition* 选项, 其默认设置
    为 "2018". 这代表默认 crate 使用 *Rust 2018* 版本. 如果有需要, 也可以将其修
    改为 "2015", 以便支持 *Rust 2015 版本*.

    在 ~src/lib.rs~ 中, 初始内容只有 tests 模块. 在 Rust 中使用关键字 mod 来定义
    模块. ~#[cfg(test)]~ 属性为条件编译, 告诉编译器只在运行调试(cargo test 命令)
    时才编译执行. 在 tests 模块中, 生成了一个示例方法 ~it_works()~. 只要进入该包
    的根目录下, 然后执行 ~cargo test~ 命令, 即可看到测试正常运行.

    Rust 也支持在文档注释里写测试

    测试完成后, 项目会多一个 *Cargo.lock* 文件和 target 文件夹. Cargo.lock 是另
    外一个元数据文件, 它和 Cargo.toml 的不同点如下:

    - Cargo.toml 是由开发者编写的, 从广义上来描述项目所需要的各种信息, 包括第三
      方包的依赖
    - Cargo.lock 只记录依赖包的详细信息, 不需要开发者维护, 而是由 Cargo 自动维护
      的.

    target 文件夹是专门用于存储编译后的目标文件的. 编译默认为 *Debug* 模式, 在该
    模式下编译器不会对代码进行任何优化, 所以编译时间较短, 代码运行速度较慢. 也可
    以使用 *--release* 参数来使用发布模式, 在该模式下, 编译器会对代码进行优化,
    使得编译时间变慢, 但是代码运行速度会变快.

    *警告*: 内容有改动, 见 [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/17][issue]]
    使用 *cargo new --lib* 命令创建的是库文件(生成静态或动态链接库), 它并非可执行
    文件. 使用 *cargo new* 或增加 *--lib* 参数创建的包可被编译为可执行文件.

    在包的根目录下执行 ~cargo build~ 命令可以编译包, ~cargo run~ 可以编译并允许
    该包.

    
