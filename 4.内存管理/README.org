* 内存管理
  在现代计算机体系中, 内存是很重要的部件之一, 程序的运行离不开内存. 不同的编程语
  言对内存有着不同的管理方式. 按照内存的管理方式可将编程语言大致分为两类: *手动
  管理类* 和 *自动内存管理类*. 手动内存管理类需要开发者手动使用 malloc 和 free
  等函数显式管理内存, eg: C 语言. 自动内存管理类使用 GC (Garbage Collection, 垃
  圾回收) 来对内存进行自动化管理, 而无需开发者手动开辟和释放内存, eg: Java, C#,
  Ruby, Python 等语言都是靠 GC 自动化管理内存的.

  手动内存管理的优势在于性能, 因为可以直接操控内存, 但同时也带来不少问题. 有人的
  地方就有 Bug, 会有忘记释放内存的情况, 就有可能频繁地造成内存泄露. 手动内存管理
  的另一个场景问题就是悬垂指针(Dangling Pointer). 如果某个指针引用的内存被非法释
  放掉了, 而该指针却依旧指向被释放的内存, 这种情况下下的指针就叫悬垂指针. 如果将
  悬垂指针分配给某个其他的对象, 将会产生无法预料的后果.

  GC 自动内存管理接管了开发者分配和回收内存的任务, 并帮助提升了代码的抽象度和可
  靠性. 像悬垂指针之类的问题完全可以避免, 因为一个别引用的对象内存永远不会被释放,
  只有当它不被引用时才可被回收. GC 使用了各种精确的算法来解决内存分配和回收的问
  题, 但并不代表能解决所有的问题. GC 最大的问题是会引起 "世界暂停", GC 在工作的
  时候必须保证程序不会引人新的 "垃圾", 所以要使运行中的程序暂停, 这就造成了性能
  问题.

  所以, 编程语言的使用现状就是: 对性能要求高并且需要对内存进行精确操控的系统级开
  发, 一般只能选择 C和 C++ 之类的语言, 存在的问题是: 如果开发者稍不留神就会造成
  内存不安全问题. 其他类型的开发就选择 Java, Python, Ruby 之类的高级语言, 一般不
  会出现内存不安全的问题, 但是它们的性能确降低了不少.

  Rust 作为一门强大的系统编程语言, 允许开发者直接操控内存. 所以了解内存如何工作
  对于编写高效的 Rust 代码至关重要.

** 通用概念
   现代操作系统在保护模式下都采用虚拟内存管理技术. 虚拟内存是一种对物理存储设备
   的统一抽象, 其中物理存储设备包括物理内存, 磁盘, 寄存器, 告诉缓存等. 这样统一
   抽象的好处是: 方便同时运行多道程序, 使得每个进程都有各自独立的进程地址空间,
   并且可以通过操作系统调度将外存当做内存来使用. 这就引出了一个新的概念: *虚拟内
   存空间*.

   虚拟地址空间是线性空间, 用户所接触导的地址都是虚拟地址, 而不是真实的物理地址.
   利用这种虚拟地址不但能保护操作系统, 让进程在各自的地址空间内操作内存, 更重要
   的是, 用户程序可以使用比物理内存更大的地址空间. 虚拟地址空间被人为地分为 2 部
   分: *用户空间* 和 *内核空间*, 它们的比例是 3:1(Linux) 或 2:2(Windows). 以
   Linux 系统为例, 32 位计算机的地址大小空间是 4GB, 寻址范围是: 0x00000000 ~
   0xFFFFFFFF. 然后通过内存分页等底层复杂的机制来把虚拟地址翻译为物理地址:
   #+begin_example
                          虚拟地址空间
                        -------------                          0xFFFFFFFF
                        |   内核空间  | 0xC0000000             -------------
                        --------------                       | 1GB 内核空间|
     --------           |   栈↓      |             0xC0000000 -------------
     |  主存 |           |            |                       |           |
     --------           |            |                       |            |
     |  磁盘 |           -------------                        | 3GB 用户空间|
     --------  抽象 ->   |mmap内存映射区|                       |           |
     | 寄存器 |           -------------                        |           |
     --------           |             |                       ------------- 
     |高速缓存|           |            |                        0x00000000
     --------           |    堆↑      |
                        ---------------
                        |    其他      |
                        ---------------
   #+end_example

   上图是 Linux 虚拟地址空间的示意图, 其中值得注意的是用户空间中的 *栈(stack)*
   和 *堆(heap)*. 图中箭头的方向代表 *内存增长的方向*, 栈向下(由高地址向低地址)
   增长, 堆向上(由低地址向高地址)增长, 这样的设计是为了更加有效地利用内存.

*** 栈
    *栈(stack)*, 也被称为堆栈, 但是为了避免歧义, 本书只称其为栈. 栈一般有两种定
    义: 一种是数据结构, 一种是指栈内存.

    在数据结构中, 栈是一种特殊的线性表, 其特殊性在于先顶了插入和删除数据只能在线
    性表固定的一端进行.

    物理内存本身并不区分堆和栈, 但是虚拟内存空间需要分出一部分内存, 用于支持 CPU
    入栈或出栈的指令操作, 这部分空间就是 *栈内存*. 栈内存拥有和栈数据结构详图的
    特性, 支持入栈和出栈操作, 属于压入的操作使得栈顶的地址减少, 数据弹出的操作使
    得栈顶的地址增多, 栈顶由栈指针寄存器 ESP 保存, 起初栈顶指向栈底的位置, 当有
    数据入栈时, 栈顶地址向下增长, 地址由高地址编程低地址; 当有数据被弹出时, 栈顶
    地址向上增长, 地址由低地址变成高地址. 因此, 降低 ESP 的地址等价于开辟空间,
    增加 ESP 的地址等价于回收栈空间.

    *栈内存最重要的作用是在程序运行过程中保存函数调用所要维护的信息*. 存储每次调
    用函数调用所需信息的记录单元被称为 *栈帧(Stack Frame)*, 有时也被称为 *活动记
    录(Activate Record)*. 因此栈内存帧分割成了 N 个记录块, 而且这些记录块都是大
    小不一的. 
    
    *内容有修改*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/148][issue]]
    #+begin_example

                栈
              |   |                 | 参数       |
       栈底 -> | · |                 | 返回地址    |
              | · |     EBP ----->   | 旧的 EBP   |
              | · | ---->  当前栈帧   | 保存的寄存器 |
              | · |                 |  局部变量   |  
              | · |     ESP ----->   | 其他数据    |
              | · |
       栈顶 -> -----
    #+end_example

    栈帧一般包括三方面的内容:

    - 函数的返回地址和参数
    - *临时变量*: 包括函数内部的非静态局部变量和编译器产生的临时变量
    - 保存的上下文

    EBP 指针是 *帧指针(Frame Pointer)*, 它指向当前栈帧的一个固定的位置, 而 ESP
    始终指向栈顶. EBP 指向的值是调用该函数之前的旧的 EBP 值, 这样在函数返回时,
    就可以通过该值恢复到调用之前的值. 由 EBP 指针和 ESP 指针构成的区域就是一个栈
    帧, 一般是指 *当前栈帧*.

    栈帧的分配非常快, 其中的局部变量都是预分配内存, 在栈上分配的值都是可以预先确
    定大小的类型. 当函数结束调用的时候, 栈帧会被自动释放. 
    所以 *栈上数据的生命周期都是在一个函数调用周期内的*.

    #+begin_example
                调用 foo 函数前
                 ------------------
      EBP --> 0  | 初始 EBP |  main
      ESP --> -4 | x =  42 |  栈帧
                 ------------------

                 调用 foo 函数后
                    --------------------------
                    |     初始 EBP     |
                 +8 |    x  =  42     |  main
                 +4 |     返回地址      |  栈帧
                    --------------------------
      EBP  -->    0 |保存 main 函数的 EBP|
                 -4 |       x         |  foo
                 -8 |       y         |  栈帧
      ESP  -->  -12 |       z         |
                    --------------------------
                          ↑ 入栈
    #+end_example
    
    *额外内容讨论*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/175][issue]]

    在上述过程中, 调用 main 和 foo 函数时, 栈顶 ESP 地址会降低, 因为要分配栈内存,
    栈向下增长, 当 foo 函数执行完毕时, ESP 地址会增长, 因为栈内存会被释放.

    *随着栈内存的释放, 函数中的局部变量也会被释放*, 所以可想而知, 全局变量不会被
    存储到栈中. 该过程来说简单, 但其实底层涉及寻址, 寄存器, 汇编指令等复杂的写作
    过程, 这些都是由编译器或解释器自动完成的, 对于上层开发者来说, 只需要了解栈内
    存的工作机制即可.

    栈内存的工作方式是一个通用概念, 不仅仅适用于 Rust 语言, 也适用于其他编程语言.
    
*** 堆
    与栈类似, *堆* 一般也有两种定义, 一种是指数据结构, 另一种是指堆内存.

    在数据结构中, 堆表示一种特殊的树形数据结构, 特殊之处在于此树是一颗 *完全二叉
    树*, 它的特点是父节点的值要么都大于两个子节点的值, 称为 *大顶堆*; 要么都小于
    两个子节点的值, 称为 *小顶堆*. 一般用于实现堆排序或优先队列. 栈数据结构和栈
    内存在特性上还有所关联, 但 *堆数据结构和堆内存并无直接的联系*.

    栈内存中保存的数据, 生命周期都比较短, 会随着函数调用的完成而消亡. 但很多情况
    下会需要能相对长久地保存在内存中的数据, 以便跨函数使用, 这就是堆内存发挥作用
    的地方. 堆内存是一块巨大的内存空间, 占了虚拟内存空间的绝大部分. *程序不可以
    主动申请栈内存*, 但是可以主动申请堆内存. 在堆内存中存放的数据会在程序运行过
    程中一直存在, 除非该内存被主动释放掉.

    *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/176][issue]]
    在 C 语言中, 程序员可以通过调用 malloc 函数来申请堆内存, 并可以通过 free 函
    数来释放它; 在 C++ 语言中, 可以使用 new 和 delete 操作符. 包含 GC 的编程语言则
    是由 GC 来分配和回收堆内存的.

    在实际工作中, 对于实现直到大小的类型, 可以分配到栈中, eg: 固定大小的数组. 但
    是如果要使用动态大小的数组, 则需要使用堆内存. 开发者只能通过指针来掌握已分配
    的内存, 这本身就带来了安全隐患, 如果指针指向的堆内存被释放掉但指针没有被正确
    处理, 或者改指针指向一个不合法的内存, 就会带来内存不安全问题. 所以面向对象大
    师 Bertrand Meyer 才会说: "要么保证软件质量, 要么使用指针, 两者不可兼得."

    堆是一大块内存空间, 程序通过 malloc 申请得到的内存空间是大小不一, 不连续且无
    序的, 所以如何管理堆内存是一个问题. 这就涉及堆分配算法, 堆分配算法就本质而言
    可以分为 2 大类: *空闲链表(Free List)* 和 *位图标记(Bitmap)*.

    空闲链表实际上就是把堆中空闲的内存地址记录为链表, 当系统受到程序申请时, 会遍
    历该链表; 当找到适合的空间堆节点时, 会将此节点从链表中删除; 当空间被回收以后,
    再将其加到空闲链表中. 空闲链表的优势是实现简单, 但如果链表遭到破坏, 整个堆就
    无法正常工作.

    位图的核心思想是将整个堆分为大量大小相等的块. 当程序申请内存时, 总数分配整数
    个块的空间. 每块内存都用一个二进制位来表示其状态, 如果该内存被占用, 则相应位
    图中的位置置为 1; 如果该内存空闲,, 则相应位图中的位置置为 0. 位图的优势是速
    度快, 如果单个内存块数据遭到破坏, 也不会影响整个堆, 但缺点是容易产生内存碎片.

    不管是什么算法, 分配的都是虚拟地址空间. 所以当堆空间被释放时, 并不代表指物理
    空间也马上被释放. 堆内存分配函数 malloc 和回收函数 free 背后是内存分配器
    (memory allocator), eg: glibc 的内存分配器 ptmallac2, 或者 FreeBSD 平台的
    jemalloc. 这些内存分配器负责申请和回收堆内存, 当堆内存释放时, 内存被归还给了
    内存分配器. 内存分配器会对空闲的内存进行统一 "整理", 在适合(eg: 空闲内存达到
    2048KB)的时候, 才会把内存归还给系统, 也就是指释放物理空间.

    Rust 编译器目前自带两个默认分配器: *alloc_system* 和 *alloc_jemalloc*. 在
    *Rust 2015* 下, 编译器产生的二进制文件默认使用 alloc_jemalloc(某些平台可能不
    支持jemalloc), 而对于静态或动态链接库, 默认使用 alloc_system, 并且可以由开发
    者自己指派 Jemalloc 或其他第三方分配器.

    Jemalloc 的优势有以下几点:
    - 分配或回收内存更快速
    - 内存碎片更少
    - 多核友好
    - 良好的可伸缩性

    该分配器是现代化的业界留下的内存分配解决方案, 它整块批发内存(称为 chunk)以供
    程序使用, 而非频繁地使用系统调用(eg: brk 或 mmap)来向操作系统申请内存. 其内
    存管理采用层级架构, 分别是线程缓存 tcache, tcache 负责当前线程所使用内存块的
    申请和释放, 避免线程间锁的竞争和同步. tcache 是对 arena 中内存块的缓存, 当没
    有 tcache 时则使用 arena 分配内存. arena 采用内存池思想对内存区域金旭亮合理
    划分和管理, 在包装有效低碎片的前提下实现了不同大小内存块的高效管理. 当 arena
    中有不能分配的超大内存时, 再使用 mmap 从系统内存中申请, 并使用红黑树进行管理.

    即使堆分配算法再好, 也只是解决了堆内存合理分配和回收的问题, 其 *访问性能远不
    如栈内存*. 存放在堆上的数据要通过其存放于栈上的指针进行访问, 这就至少多了一
    层内存中的跳转.

    所以, *能放在栈上的数据最好不要放到堆上*. 因此, Rust 的类型默认都是放到栈上
    的.
    
*** 内存布局
    内存中数据的排列方式成为 *内存布局*. 不同的排列方式, 占用的内存不同, 也会间
    接影响 CPU 访问内存的效率. 为了权衡空间占用情况和访问效率, 引入了内存对齐规
    则.

    CPU 在单位时间内能处理的一组二进制数成为 *字*, 这组二进制数的位数称为
    *字长*. 若是 32 位 CPU, 其字长 32 位, 也就是 4个 字节. 一般来说, 字长越大,
    计算机处理信息的速度就越快, eg: 64 位 CPU 就比 32 位 CPU 效率更高.

    以 32 位 CPU 为例, CPU 每次只能从内测中读取 4 个字节的数据, 所以每次只能对 4
    的倍数的地址进行读取.

    假设现有一整数类型的数据, 其地址并不是 4 的倍数, 设为 0x3, 则该类型存储在地
    址范围是 0x3 ~ 0x7 的存储空间中. 因此, CPU 如果想读取该数组,. 则需要分别在
    0x1 和 0x5 处进行两次读取, 而且还需要对读取到的数据进行处理才能得到该整数,
    如下图所示. CPU 的处理速度比内存中读取数据的速度要快得多, 因此 *减少 CPU 对
    内存空间的访问是提高程序性能的关键*.
    
    #+begin_example

        0x1   0x2   0x3   0x4   0x5   0x6   0x7   0x8
      --------------------------------------------------
         |     |     | /// | /// | /// | /// |     |
      --------------------------------------------------
         ↑                       ↑
    #+end_example

    因此, *采取内存对齐策略是提高程序性能的关键*. 上图展示的整数类型, 因为是 32
    位 CPU, 所以只需要按 4 字节对齐, CPU 只需要读取一次.
    
    #+begin_example

        0x1   0x2   0x3   0x4   0x5   0x6   0x7   0x8   0x9
      --------------------------------------------------------
         |     |     |     |     | /// | /// | /// | /// |
      --------------------------------------------------------
                                 ↑                       ↑ 

    #+end_example
    
    因为对齐的是字节, 所以内存对齐也叫 *字节对齐*. 内存对齐是编译器或虚拟机(eg:
    JVM) 的工作, 不需要人为指定, 但是作为开发者需要了解内存对齐的规则, 这有助于
    编写出合理利用内存的高性能程序.

    内存对齐包括基本数据对齐和结构体(或联合体)数据对齐. 对于基本数据类型, 默认对
    齐方式是按其大小进行对齐, 也被称为 *自然对齐*. eg: Rust 中 u32 类型占 4 字节,
    则它默认对齐方式为 4 字节对齐. 对于内部含有多个基本类型的结构体来说, 对齐规
    则稍微有点复杂.

    假设对齐字节数为 N(N = 1, 2, 4, 8, 16), 每个成员内存长度为 Len, Max(Len) 为
    最大成员内存长度. 在没有外部明确规定下, N 默认按照 Max(Len) 对齐. 字节对齐规
    则:

    - 结构体的起始地址能够被 Max(Len) 整除
    - 结构体中每个成员相对于结构体起始地址的偏移量, 即对齐值, 应该是 Min(N, Len)
      的倍数, 若不满足对齐值的要求, 编译器会在成员之间填充若干个字节.
    - 结构体的总长度应该是 Min(N, Max(Len)) 的倍数, 若不满足总长度要求, 则编译器
      会在为最后一个成员分配空间后, 在其后面填充若干个字节.

      
    *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/56][issue]]
    #+begin_example
      内存对齐之前:
      1  1111  11
      -  ----  --    共 7 字节
      a   b    c

      对齐后(发生了重排):
       1111  11  1x
       ----  --  --   共 8 字节
         b    c   a
    #+end_example

    结构体 A 中最长的成员是 b, 占 4 个字节. 那么对于成员 a 来说, 它的对齐值为
    Min(4, 1), 即 1, 所以 a 需要补齐一个字节的空间, 那么 a 现在大小就是 2 字节的.
    成员 b 是已经对齐的, 成员 c 是结构体中最后一位成员, 当前结构体 A 的总长度为
    a, b, c 之和, 占 8 个字节, 正好是 Min(4, 4), 也就是  4 的倍数, 所以成员 c 不
    需要再不济. 而结构体 A 实际占用 也是 8 个字节.

    额外的对齐示例: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/223][对于u8情况下的内存对齐情况]]

    联合体(Union) 和结构体不同的地方在于, 联合体中的所有成员都共享一段内存, 所有
    成员的首地址都是一样的, 单位了能够容纳所有成员, 就必须可以容纳其中最长的成员.
    所以联合体以最长成员为对齐数.
