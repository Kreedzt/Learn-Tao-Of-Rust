* 安全并发  
** 通用概念
   并发(Concurrency)的概念很容易和并行(Parallelism)混淆, 事实上它们是不同的概念.

   谷歌著名工程师罗布派克(Rob Pike)说过: "并发就是 *同时应对(Dealing With)* 多件
   事情的能力, 并行是 *同时执行(Doing)* 多件事情的能力".

   将任务分配在不同的时间片内交替完成就是 *并发, 关注点在于任务的切分, 这是一种
   逻辑架构、一种能力*. 每个单位都是事情执行的个体, 相互无影响, 各自独立工作, 这
   就是 *并行, 关注点在于同时执行, 这是具体的实施状态*. 并发并不要求一定要并行,
   利用并并发可以制造出并行的假象.

   在实际编程中, 对任务进行分解才是重点, 一旦将任务分解正确, 到了执行层面, 并行
   就会自然发生, 也容易保证程序的正确性. 如何分解任务是并发设计要解决的问题, 所
   以, 通过更关注并发而非并行.

   使用并发主要出于 2 个主要原因: *性能* 和 *容错*.

   随着多核计算机的普及, 为了利用日益增长的计算能力, 就必须要编写并发程序. 并发
   编程越来越受重视, 甚至可能成为一种新的编程范式, Go 语言的横空出世就证明了这一
   点. 另外, 并发编程还可以将程序分为不同的功能区域, 让程序更容易理解和测试, 从
   而减少程序出错的可能性.

   在计算机中, 通常使用一些独立的运行实体对并发进行支持, 分为如下两类:
   - 操作系统提供的进程和线程
   - 编程语言内置的用户级线程

*** 多进程和多线程
    进程是资源分配的最小单元, 线程是程序执行时的最小单元.

    从操作系统的角度来看, 进程代表操作系统分配的内存、CPU 时间片等资源的基本单位,
    它为程序提供基本的运行环境. 不同的应用程序可以按业务划分为不同的进程. 从用户
    的角度来看, 进程代表运行中的应用程序, 它是动态条件下由操作系统维护的资源管理
    实体, 而非静态的应用程序文件. 每个进程都享有自己独立的内存单元, 从而极大地提
    高了程序的运行效率.

    可以使用多进程来提供并发, eg: Mater-Worker 模式, 由 Master 进程来管理 Worker
    子进程, Worker 子进程执行任务. Master 和 Worker 之间通常使用 Socket 来进行进
    程间通信(IPC). 这样的好处就是具有极高的健壮性, 当某个 Worker 子进程出现问题
    时, 不会影响到其他子进程. 但缺点也非常明显, 其中最让人诟病的是进程会占用相当
    可观的系统资源. 除此之外, 进程还有切换复杂、CPU 利用率低、创建和销毁复杂等缺
    点.

    为了寻求比进程更小的资源占用, 线程应运而生. 线程是进程内的实体, 它无法独立存
    在, 必须依靠进程, 线程的资源资源都来源于进程, 包括内存. 每个进程至少拥有一个
    线程, 这个线程就是主线程. 每个进程也可以生成若干个线程来并发执行多任务, 但只
    能有一个主线程, 线程和线程之间可以共享同一个进程内的资源. 一个线程也可以创建
    或销毁另一个线程, 所以线程会有创建、就绪、运行、阻塞和死亡 5 种状态. 每个线
    程也有自己独享的资源, eg:线程栈. 线程和进程一样, 都受操作系统内核的调度. 线
    程拥有进程难以企及的优点, eg: 占用内存少, 切换简单, CPU 利用率搞, 创建/销毁
    简单、快速等. 线程的缺点也是非常明显的, eg: 编程相当复杂, 调试困难等. 正是由
    于这些缺点, 导致多线程并发编程成为众多开发者心中的痛.

*** 事件驱动、异步回调和协程
    多线程虽然比多进程更省资源, 但其依然存在昂贵的系统内核调度代价. 互联网的发展
    让这个问题更加突出. 在服务器领域有一个非常出名的 *C10K* 问题, 主要是指单台服
    务器要同时处理 10K 量级的并发连接, 解决此问题最直接的就是多进程(线程)并发,
    每个进程(线程)处理一个连接. 但是, 这种处理方式显然是有问题的, 因为服务器根本
    没有这么多资源可以分配给如此多的进程(线程).

    为了解决 C10K 问题, *事件驱动编程* 应运而生, 最知名的就是 Linux 退出的
    *epoll* 技术. 事件驱动也可以称为事件轮询, 它的优点在于编程更加容易, 不用做并
    发设计的考虑, 不需要引入锁, 不需要考虑内部调度, 只需要依赖于事件, 最重要的是
    不会阻塞. 所以它可以很方便地和编程语言相集成, eg: Node.js, 也就是第一个事件
    驱动编程模型语言. 在 Node.js 中, 仅仅使用单线程就可以拥有强大的并发处理能力,
    其力量来源就是 *事件驱动* 和 *异步回调(Callback)*. 通过内置的事件循环机制,
    不断地从事件队列中查询是否有事件发生, 当读取到时间时, 就会调用和此事件关联的
    回调函数, 整个过程是非阻塞的.

    事件驱动和回调函数虽然解决了 C10K 的问题, 但是对于开发者来说还远远没有那么完
    美. 问题就出在回调函数上面, 如果编写业务比较复杂的代码, 开发者将陷入 "*回调
    地狱(Callback Hell)*" 中, 代码中充斥着各种回调嵌套, 很快就会变成一团乱麻. 回
    调函数的这种写法, 并不符合人类的思维直觉, 所以使用起来比较痛苦.

    为了避免 "回调低于", 不停地有新方案被提出, eg: *Promise* 和 *Future*, 这两种
    方案从不同的角度来处理回调函数. Promise 站在任务处理者的角度, 将异步任务完成
    或失败的状态标记到 Promise 对象中. Future 则站在任务调用者的角度, 来检测任务
    是否完成, 如果完成则直接获取结果, 如果未完成则阻塞直到获取到结果, 或者编写回
    调函数避免阻塞, 根据相应地完成状态执行此回调函数. 虽然 Promise 和 Future 可
    以进一步缓解回调函数的问题, 但它们还是不够完美, 代码中依然充斥着各种冗余.

    为了进一步完善基于事件驱动的编程体验, 一种叫作 *协程* 的解决方案浮出水面. 协
    程的概念很古老, 甚至可以追溯到 20 世纪 60 年代的 COBOL 语言, 但是因为时代使
    然, 协程并未称为像线程那样的通用编程元素. 然而, 随着事件编程的兴起, 协程又有
    了用武之地.

    协程为协同任务提供了一种抽象, 这种抽象本质上就是控制流的出让和恢复. 协程的这
    种机制, 正好符合现实世界中人类异步处理实物的直觉. eg: 程序员可以暂停自己写代
    码的过程, 进行场景切换, 去参加产品经理组织的会议, 当会议结束后, 再切回之前的
    场景继续编写代码. 虽然处理了不同的事件, 但对于程序员来说, 都是顺序执行的. 可
    以看出, 协程和事件驱动属于绝配. 当事件来临时, 出让当前的控制权, 切换场景, 完
    成该事件, 然后再切换回之前的场景, 恢复之前的工作. 如果说事件驱动编程和异步回
    调是站在开发者的角度来进行编程的. 开发者将自身代入各事件中, 看上去就是顺序执
    行的. 总的来说, 协程可以让开发者用写同步(顺序)代码的方式编写可异步执行的代码.

    在现代编程语言中, 实现协程的方法有很多, 但其中的区别只在于是否有适合的应用场
    景. 场景的有 Go 语言的 *go 程(goroutines)*, Erlang 语言的 *轻量级线程(LWP)*.
    另外, 像 Python、Ruby、JavaScript 这样的语言也实现了协程, 当然 Rust 语言也支
    持协程. 协程是以线程为龙骑的, 协程的特点是内存占用比线程更小, 上下文切换的开
    销更小、没有昂贵的系统内核调度, 这也意味着协程的运行效率更加高效. 协程非常轻
    量, 也被称为用户态线程, 所以可大量使用. 但协程也不是 "银弹", 它虽然充分挖掘
    了单线程的利用率, 在单线程下可以处理高并发 I/O, 但却无法利用多核.

    当然, 可以将协程和多线程配合使用, 来充分利用多核. 但是, 从单线程迁移到多线程
    并不会只带来好处, 它也会带来更多的风险.

*** 线程安全
    线程其实是对底层硬件运行过程的直接抽象, 这种抽象方式既有优点又有缺点. *优点*
    在于很多编程语言都对其提供了支持, 并且没有对其使用方式加以限制, 开发者可以自
    由地实现多线程并发程序, 充分利用多核. *缺点* 包含两个方面: 一方面, 线程的调
    度完全由系统内核来控制, 完全随机, 这就导致多个线程的运行顺序是完全无法预测的,
    有可能产生奇怪的结果; 另一方面, 编程正确的多线程并发程序对开发者的要求太高,
    对多线程编程没有充足知识储备的开发者很容易写出满是 Bug 的多线程代码, 并且还
    很难重现和调试.

    多线程存在问题主要是因为资源共享, eg:　共享内存、文件、数据库等. 实际上, 只
    有当一个或多个线程对这些资源进行写操作时才会出现问题, 如果只读不写, 资源不会
    发生变化, 自然也不会存在安全问题. 假如一个方法、数据结构或库在多线程环境中不
    会出现任何问题, 则可以称之为 *线程安全*.

    所以, 多线程编程的重点就是如何写出线程安全的代码.

**** 竞态条件与临界区
     要想写出线程安全的代码, 必须先了解安全的边界在哪里.

     在单线程环境中, ~unsafe_seq()~ 函数不会有任何问题, 但是将其放到多线程环境中,
     则会有问题. 实际上, ~V+=1~ 操作上在运行过程中并非单个指令, 而是可以分为三
     步:
     1) 从内存中将 ~V~ 的初始值放入寄存器中
     2) 将寄存器中的 ~V~ 的值加 1.
     3) 将加 1 后的值写入内存.

     这三步操作无法保证在同一个线程中被一次执行完成. 因为系统内核调度的存在, 很
     有可能在线程 A 执行第二步操作之后, 从线程 A 切换到了线程 B, 而线程 B 此时并
     不知道线程 A 已经执行了第一步操作, 它又重复将 ~V~ 的初始值放入寄存器中, 当
     又切换回线程 A 后, 线程 A 会继续执行第三步操作, 此时就从寄存器中读取了错误
     的值.

     这种常见的并发安全问题, 叫作 *竞态条件(Race Condition)*. 当某个计算的正确性
     取决于多个线程交替执行的顺序时, 就会产生竞态条件. 也就是说, 想计算出正确的
     结果, 全靠运气. 最常见的竞态条件类型是: "*读取-修改-写入*" 和 "*先检查后执
     行*" 操作. 代码 11-1 展示的就是 "读取-修改-写入" 竞态条件; 而 "先检查后执行
     " 竞态条件则出现在需要判断某个条件为真之后才采取相应地动作时. 产生竞态条件
     的区域, 就叫做 *临界区*.

     在代码清单 11-1 中展示的代码也同时引起了 *数据竞争(Data Race)*. "数据竞争"
     这个术语很容易和竞态条件相混淆. 当一个线程写一个变量而另一个线程读这个变量
     时, 如果这两个线程没有进行同步, 则会发生数据竞争. 因为竞态条件的存在, 读操
     作很可能在操作之前就完成了, 那么读到的数据就是错误的.
     *并非所有的竞态条件都是数据竞争, 也并非所有的数据竞争都是竞态条件*.

     简单来说, 当有多个线程对同一个变量同时进行读写操作, 且至少有一个线程对该变
     量进行写操作时, 则会发生数据竞争. 也就是说, 如果所有的线程都是读操作, 则不
     会发生数据竞争. 数据竞争的后果是早成该变量的值不可知, 多线程程序的运行结果
     将完全不可预测, 甚至直接崩溃.

     11-2 用于转账操作的函数(伪代码):
     #+begin_example
       trans1(amount, account_from, account_to) {
           if (account_from.balance < amount) return FALSE;
           account_to.balance += amount;
           account_from.balance -= amount;
           return TRUE;
       }
     #+end_example
     
     在多线程环境中, 这个伪代码示例既包含了竞态条件, 又包含了数据竞争, 转账结果
     将不可预测. 为了解决该问题, 采用某种同步操作, eg: 使用互斥量(Mutex)或某种禁
     用中断操作的事务, 将包含数据竞争的操作变为原子性操作.
     
     11-3 改进转帐操作的函数:
     #+begin_example
       trans2(amount, account_from, account_to) {
           atomic { bal = account_from.balance; }
           if (bal < amount) return FALSE;
           atomic { account_to.balance += amount; }
           atomic { account_from.balance -= amount; }
           return TRUE;
       }
     #+end_example

     使用 atomic 块表示将其范围内的操作变为原子性的某种手段. 总之, 现在数据竞争
     被消除了. 但还存在竞态条件, 不同的线程依然可以乱序执行代码第 4 行和第 5 行
     的操作. 这个交易函数 ~trans2()~ 的正确性, 在不同的线程执行顺序下, 会出现不
     同的结果. 所以还需要继续对其改进.

     11-4 继续改进转账操作的函数
     #+begin_example
       trans3(amount, account_from, account_to) {
           atomic {
               if (account_from.balance < amount) return FALSE;
               account_to.balance += amount;
               account_from.balance -= amount;
               return TRUE;
           }
       }
     #+end_example

     在 ~trans3()~ 函数中, 通过 atomic 块将 整个函数的执行过程赋予原子性, 这样就
     完全消除了数据竞争和竞态条件. 可以看出, *消除竞态条件的关键在于判断出正确的
     临界区*.

     还可以对其进一步改进, 创建一个有数据竞争但无竞态条件的函数.
     11-5 进一步改进转账操作的函数
     #+begin_example
       trans4(amount, account_from, account_to) {
           account_from.activity = true;
           account_to.activity = true;
           atomic {
               if (account_from.balance < amount) return FALSE;
               account_to.balance += amount;
               account_from.balance -= amount;
               return TRUE;
           }
       }
     #+end_example
     
     在 ~trans4()~ 函数中增加了两行伪代码, 如第二行和第三行所示, 这两行代码表示
     这两个账号上会出现某些状态变更的行为. 这两行代码会出现数据竞争, 但不存在竞
     态条件. 但这里的数据竞争并不会影响到交易行为的正确性, 所以是无害的.

     通过上面的 4 段伪代码, 刻意区分了数据竞争和竞态条件之间的区别. 在多线程编程
     中, 数据竞争是最常见、最严重、最难调试的并发问题之一, 可能会引起崩溃会内存
     不安全.

     接下来看看 Rust 多线程代码实际产生竞态条件和数据竞争问题的例子(11-6)

     正常情况下, 对该段代码进行编译执行, 期待的数据结果是 main 主线程和 child 子
     线程一共输出 0 ~ 20 的数字. 但实际执行多次会看到不同的输出结果, 基本会出现
     以下两种情况:
     - 在 main 主线程输出的结果中会莫名其妙地少一位, 并不是 0 ~ 10 的连续值
     - child 子线程输出的结果和 main 主线程输出的结果有重复

     可以看出, 该段代码在多线程环境中的行为和结果完全无法预测, 完全无法保证正确
     性.

**** 同步、互斥和原子类型
     综上所述, 产生竞态条件主要是因为线程乱序执行, 发生数据竞争主要是因为多线程
     同时对桶一块内存进行读写. 那么, 要消除竞态条件, 只需要保证线程按指定顺序来
     访问即可. 要避免数据竞争, 只需要保证相关数据结构操作的原子性即可. 所以, 很
     多编程语言都通过提供同步机制来消除竞态条件, 使用互斥和原子类型来避免数据竞
     争.

     同步是指保证多线程按指定顺序执行的手段. 互斥是指用一时刻只允许单个线程对临
     界资源进行访问, 对其他线程具有排他性, 线程之间的关系表示为互斥. 而原子类型
     是指修改临界数据结构的内部实现, 确保对它们做任何更新, 在外界原来都是原子性
     的, 不可中断.

     通常可以使用 *锁*, *信号量(Semaphores)*, *屏障(Barrier)* 和 *条件变量
     (Condition Variable)* 机制来实现同步. 根据不同的并发场景分为很多不同类型的
     锁, 有互斥锁(Mutex)、读写锁(RwLock)和自旋锁(Spinlock)等. 锁的作用是可以保护
     临界区, 同时达到同步和互斥的效果. 不同的锁表现不同, 比如互斥锁, 每次只允许
     单个线程访问临界资源; 读写锁可以同时支持多核线程读或单个线程写; 自旋锁和互
     斥锁类似, 但当获取锁失败时, 它不会让线程睡眠, 而是不断地轮询直到获取成功.

     *信号量* 可以在线程间传递信号, 也叫作信号灯, 它可以为资源访问进行计数. 信号
     量是一个非负整数, 所有通过它的线程都会将该整数 -1, 如果信号量为 0, 那么其他
     线程只能等待. 当线程执行完毕离开临界区时, 信号量会再次 +1. 当信号量只允许设
     置 0 和 1 时, 效果相当于互斥锁.

     *屏障* 可以让一系列线程在某个指定的点进行同步. 通过让参数指定屏障区域的线程
     等待, 知道所有参与线程都到达指定的点. 而 *条件变量* 用来自动阻塞一个线程,
     直到出现指定的条件, 通常和互斥锁配合使用.

     通过一些锁机制, eg: 互斥锁, 也可以用来避免数据竞争. 本质上, 是通过锁来保护
     指定区域的原子性的. 有些语言也提供了原子类型来保证原子性, eg: Java、C++ 以
     及 Rust. 具有原子性的操作一定是不可分割的, 要么全部完成, 要么声明都不做. 原
     子类型使用起来简单, 但其背后的机制缺一点也不简单, 了解其背后的机制有助于更
     好地使用原子类型.
     
**** 原子类型与多线程内存模型
     在计算机中程序需要经过 CPU、CPU 多级缓存和内存等协同工作才能顺利执行, 在这
     种体系结构之下, 如果是多核系统, 其中一个 CPU 核心修改了变量, 那么如果通知其
     他核心是一个重要的问题. 并且为了提高性能, 现代处理器和编程语言的编译器都对
     程序进行了极度优化, eg: *乱序执行* 和 *指令重排*, 所以机器并非按照实际编写
     的那样来执行. 在多线程编程中, 只有保持顺序一致性, 才能保证程序的正确性. 所
     谓 *顺序一致性*, 主要约定了 2 件事:
     - 在单线程内部指令都是按程序确定的顺序来执行的
     - 多线程程序在执行过程中虽然是交替执行的, 但从全局来看, 也是按某种确定的顺
       序来执行的.

     显然, 在硬件层面并没有支持顺序一致性, 所以需要编程语言和计算机系统(包括编译
     器、CPU 等)  之间达成 "契约", 该契约规定了多线程访问同一个内存位置时的语义,
     以及某个线程对内存位置的更新何时才能被其他线程看到. 这个契约就是 *多线程内
     存模型*. 通过该内存模型, 程序员就可以使用编程语言提供的同步原语(eg: C++ 和
     Rust 提供的 Atomic 类型)来保证多线程下的顺序一致性, 这也是无锁并发编程的基
     础.

     Rust 的多线程内存模型来源于 C++ 11, 而 C++ 11 中实现的 Atomic 类型是通过
     store 和 load 这两个 CPU 指令进行数据存取(寄存器和内存之间)的, 并且额外接受
     一个 *内存序列(Memory Order)* 作为参数. C++ 11 支持 6 种内存排序约束, 而
     Rust 是基于 LLVM 实现的, 所以 Rust 通过 LLVM 原子内存排序约束来实现不同级别
     的原子性.

**** 为什么多线程这么难
     既然有了这么多避免竞态条件和数据竞争的手段, 那么为什么提到多线程还会让广大
     开发者心生恐惧呢? 主要由以下几点原因:

     - 虽然可以使用锁来同步, 但卡覅啊中有可能忘记加锁
     - 即使没有忘记加锁, 也可能出现死锁的情况
     - 多线程程序难以调试, 如果出现了问题很难再现

     总的来说, 主要因为开发者自身很难驾驭多线程编程. 即便是技艺高超的开发者, 也
     难以保证写出没有问题的多线程代码. 难以驾驭背后的原因下雨, 开发者总是有意无
     意地将不改共享的数据错误地共享, 将其暴露在多个线程可以操作的危险区. Rust 语
     言的出现正是要解决这个问题的.  
