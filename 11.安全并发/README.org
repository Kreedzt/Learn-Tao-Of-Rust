* 安全并发  
** 通用概念
   并发(Concurrency)的概念很容易和并行(Parallelism)混淆, 事实上它们是不同的概念.

   谷歌著名工程师罗布派克(Rob Pike)说过: "并发就是 *同时应对(Dealing With)* 多件
   事情的能力, 并行是 *同时执行(Doing)* 多件事情的能力".

   将任务分配在不同的时间片内交替完成就是 *并发, 关注点在于任务的切分, 这是一种
   逻辑架构、一种能力*. 每个单位都是事情执行的个体, 相互无影响, 各自独立工作, 这
   就是 *并行, 关注点在于同时执行, 这是具体的实施状态*. 并发并不要求一定要并行,
   利用并并发可以制造出并行的假象.

   在实际编程中, 对任务进行分解才是重点, 一旦将任务分解正确, 到了执行层面, 并行
   就会自然发生, 也容易保证程序的正确性. 如何分解任务是并发设计要解决的问题, 所
   以, 通过更关注并发而非并行.

   使用并发主要出于 2 个主要原因: *性能* 和 *容错*.

   随着多核计算机的普及, 为了利用日益增长的计算能力, 就必须要编写并发程序. 并发
   编程越来越受重视, 甚至可能成为一种新的编程范式, Go 语言的横空出世就证明了这一
   点. 另外, 并发编程还可以将程序分为不同的功能区域, 让程序更容易理解和测试, 从
   而减少程序出错的可能性.

   在计算机中, 通常使用一些独立的运行实体对并发进行支持, 分为如下两类:
   - 操作系统提供的进程和线程
   - 编程语言内置的用户级线程

*** 多进程和多线程
    进程是资源分配的最小单元, 线程是程序执行时的最小单元.

    从操作系统的角度来看, 进程代表操作系统分配的内存、CPU 时间片等资源的基本单位,
    它为程序提供基本的运行环境. 不同的应用程序可以按业务划分为不同的进程. 从用户
    的角度来看, 进程代表运行中的应用程序, 它是动态条件下由操作系统维护的资源管理
    实体, 而非静态的应用程序文件. 每个进程都享有自己独立的内存单元, 从而极大地提
    高了程序的运行效率.

    可以使用多进程来提供并发, eg: Mater-Worker 模式, 由 Master 进程来管理 Worker
    子进程, Worker 子进程执行任务. Master 和 Worker 之间通常使用 Socket 来进行进
    程间通信(IPC). 这样的好处就是具有极高的健壮性, 当某个 Worker 子进程出现问题
    时, 不会影响到其他子进程. 但缺点也非常明显, 其中最让人诟病的是进程会占用相当
    可观的系统资源. 除此之外, 进程还有切换复杂、CPU 利用率低、创建和销毁复杂等缺
    点.

    为了寻求比进程更小的资源占用, 线程应运而生. 线程是进程内的实体, 它无法独立存
    在, 必须依靠进程, 线程的资源资源都来源于进程, 包括内存. 每个进程至少拥有一个
    线程, 这个线程就是主线程. 每个进程也可以生成若干个线程来并发执行多任务, 但只
    能有一个主线程, 线程和线程之间可以共享同一个进程内的资源. 一个线程也可以创建
    或销毁另一个线程, 所以线程会有创建、就绪、运行、阻塞和死亡 5 种状态. 每个线
    程也有自己独享的资源, eg:线程栈. 线程和进程一样, 都受操作系统内核的调度. 线
    程拥有进程难以企及的优点, eg: 占用内存少, 切换简单, CPU 利用率搞, 创建/销毁
    简单、快速等. 线程的缺点也是非常明显的, eg: 编程相当复杂, 调试困难等. 正是由
    于这些缺点, 导致多线程并发编程成为众多开发者心中的痛.

*** 事件驱动、异步回调和协程
    多线程虽然比多进程更省资源, 但其依然存在昂贵的系统内核调度代价. 互联网的发展
    让这个问题更加突出. 在服务器领域有一个非常出名的 *C10K* 问题, 主要是指单台服
    务器要同时处理 10K 量级的并发连接, 解决此问题最直接的就是多进程(线程)并发,
    每个进程(线程)处理一个连接. 但是, 这种处理方式显然是有问题的, 因为服务器根本
    没有这么多资源可以分配给如此多的进程(线程).

    为了解决 C10K 问题, *事件驱动编程* 应运而生, 最知名的就是 Linux 退出的
    *epoll* 技术. 事件驱动也可以称为事件轮询, 它的优点在于编程更加容易, 不用做并
    发设计的考虑, 不需要引入锁, 不需要考虑内部调度, 只需要依赖于事件, 最重要的是
    不会阻塞. 所以它可以很方便地和编程语言相集成, eg: Node.js, 也就是第一个事件
    驱动编程模型语言. 在 Node.js 中, 仅仅使用单线程就可以拥有强大的并发处理能力,
    其力量来源就是 *事件驱动* 和 *异步回调(Callback)*. 通过内置的事件循环机制,
    不断地从事件队列中查询是否有事件发生, 当读取到时间时, 就会调用和此事件关联的
    回调函数, 整个过程是非阻塞的.

    事件驱动和回调函数虽然解决了 C10K 的问题, 但是对于开发者来说还远远没有那么完
    美. 问题就出在回调函数上面, 如果编写业务比较复杂的代码, 开发者将陷入 "*回调
    地狱(Callback Hell)*" 中, 代码中充斥着各种回调嵌套, 很快就会变成一团乱麻. 回
    调函数的这种写法, 并不符合人类的思维直觉, 所以使用起来比较痛苦.

    为了避免 "回调低于", 不停地有新方案被提出, eg: *Promise* 和 *Future*, 这两种
    方案从不同的角度来处理回调函数. Promise 站在任务处理者的角度, 将异步任务完成
    或失败的状态标记到 Promise 对象中. Future 则站在任务调用者的角度, 来检测任务
    是否完成, 如果完成则直接获取结果, 如果未完成则阻塞直到获取到结果, 或者编写回
    调函数避免阻塞, 根据相应地完成状态执行此回调函数. 虽然 Promise 和 Future 可
    以进一步缓解回调函数的问题, 但它们还是不够完美, 代码中依然充斥着各种冗余.

    为了进一步完善基于事件驱动的编程体验, 一种叫作 *协程* 的解决方案浮出水面. 协
    程的概念很古老, 甚至可以追溯到 20 世纪 60 年代的 COBOL 语言, 但是因为时代使
    然, 协程并未称为像线程那样的通用编程元素. 然而, 随着事件编程的兴起, 协程又有
    了用武之地.

    协程为协同任务提供了一种抽象, 这种抽象本质上就是控制流的出让和恢复. 协程的这
    种机制, 正好符合现实世界中人类异步处理实物的直觉. eg: 程序员可以暂停自己写代
    码的过程, 进行场景切换, 去参加产品经理组织的会议, 当会议结束后, 再切回之前的
    场景继续编写代码. 虽然处理了不同的事件, 但对于程序员来说, 都是顺序执行的. 可
    以看出, 协程和事件驱动属于绝配. 当事件来临时, 出让当前的控制权, 切换场景, 完
    成该事件, 然后再切换回之前的场景, 恢复之前的工作. 如果说事件驱动编程和异步回
    调是站在开发者的角度来进行编程的. 开发者将自身代入各事件中, 看上去就是顺序执
    行的. 总的来说, 协程可以让开发者用写同步(顺序)代码的方式编写可异步执行的代码.

    在现代编程语言中, 实现协程的方法有很多, 但其中的区别只在于是否有适合的应用场
    景. 场景的有 Go 语言的 *go 程(goroutines)*, Erlang 语言的 *轻量级线程(LWP)*.
    另外, 像 Python、Ruby、JavaScript 这样的语言也实现了协程, 当然 Rust 语言也支
    持协程. 协程是以线程为龙骑的, 协程的特点是内存占用比线程更小, 上下文切换的开
    销更小、没有昂贵的系统内核调度, 这也意味着协程的运行效率更加高效. 协程非常轻
    量, 也被称为用户态线程, 所以可大量使用. 但协程也不是 "银弹", 它虽然充分挖掘
    了单线程的利用率, 在单线程下可以处理高并发 I/O, 但却无法利用多核.

    当然, 可以将协程和多线程配合使用, 来充分利用多核. 但是, 从单线程迁移到多线程
    并不会只带来好处, 它也会带来更多的风险.
