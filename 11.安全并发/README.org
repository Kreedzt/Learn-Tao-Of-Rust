* 安全并发  
** 通用概念
   并发(Concurrency)的概念很容易和并行(Parallelism)混淆, 事实上它们是不同的概念.

   谷歌著名工程师罗布派克(Rob Pike)说过: "并发就是 *同时应对(Dealing With)* 多件
   事情的能力, 并行是 *同时执行(Doing)* 多件事情的能力".

   将任务分配在不同的时间片内交替完成就是 *并发, 关注点在于任务的切分, 这是一种
   逻辑架构、一种能力*. 每个单位都是事情执行的个体, 相互无影响, 各自独立工作, 这
   就是 *并行, 关注点在于同时执行, 这是具体的实施状态*. 并发并不要求一定要并行,
   利用并并发可以制造出并行的假象.

   在实际编程中, 对任务进行分解才是重点, 一旦将任务分解正确, 到了执行层面, 并行
   就会自然发生, 也容易保证程序的正确性. 如何分解任务是并发设计要解决的问题, 所
   以, 通过更关注并发而非并行.

   使用并发主要出于 2 个主要原因: *性能* 和 *容错*.

   随着多核计算机的普及, 为了利用日益增长的计算能力, 就必须要编写并发程序. 并发
   编程越来越受重视, 甚至可能成为一种新的编程范式, Go 语言的横空出世就证明了这一
   点. 另外, 并发编程还可以将程序分为不同的功能区域, 让程序更容易理解和测试, 从
   而减少程序出错的可能性.

   在计算机中, 通常使用一些独立的运行实体对并发进行支持, 分为如下两类:
   - 操作系统提供的进程和线程
   - 编程语言内置的用户级线程

*** 多进程和多线程
    进程是资源分配的最小单元, 线程是程序执行时的最小单元.

    从操作系统的角度来看, 进程代表操作系统分配的内存、CPU 时间片等资源的基本单位,
    它为程序提供基本的运行环境. 不同的应用程序可以按业务划分为不同的进程. 从用户
    的角度来看, 进程代表运行中的应用程序, 它是动态条件下由操作系统维护的资源管理
    实体, 而非静态的应用程序文件. 每个进程都享有自己独立的内存单元, 从而极大地提
    高了程序的运行效率.

    可以使用多进程来提供并发, eg: Mater-Worker 模式, 由 Master 进程来管理 Worker
    子进程, Worker 子进程执行任务. Master 和 Worker 之间通常使用 Socket 来进行进
    程间通信(IPC). 这样的好处就是具有极高的健壮性, 当某个 Worker 子进程出现问题
    时, 不会影响到其他子进程. 但缺点也非常明显, 其中最让人诟病的是进程会占用相当
    可观的系统资源. 除此之外, 进程还有切换复杂、CPU 利用率低、创建和销毁复杂等缺
    点.

    为了寻求比进程更小的资源占用, 线程应运而生. 线程是进程内的实体, 它无法独立存
    在, 必须依靠进程, 线程的资源资源都来源于进程, 包括内存. 每个进程至少拥有一个
    线程, 这个线程就是主线程. 每个进程也可以生成若干个线程来并发执行多任务, 但只
    能有一个主线程, 线程和线程之间可以共享同一个进程内的资源. 一个线程也可以创建
    或销毁另一个线程, 所以线程会有创建、就绪、运行、阻塞和死亡 5 种状态. 每个线
    程也有自己独享的资源, eg:线程栈. 线程和进程一样, 都受操作系统内核的调度. 线
    程拥有进程难以企及的优点, eg: 占用内存少, 切换简单, CPU 利用率搞, 创建/销毁
    简单、快速等. 线程的缺点也是非常明显的, eg: 编程相当复杂, 调试困难等. 正是由
    于这些缺点, 导致多线程并发编程成为众多开发者心中的痛.

*** COMMENT 事件驱动、异步回调和协程
