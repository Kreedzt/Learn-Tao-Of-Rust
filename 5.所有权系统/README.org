* 所有权系统
  只有确定了权利归属, 才能防止纠纷的发生.
  通过法律划分出明确的权属界限, 才能理清每个人的行为界限, 合理保障个人的自由空间,
  利益范围和生命安全.

  内存管理不外如是. 栈内存的生命周期是短暂的, 会随着栈展开(常见的是函数调用)的过
  程而被自动清理. 而堆内存是动态的, 其分配和重新分配并不遵循某个固定的模式, 所以
  需要使用指着拿来对齐进行跟踪. Rust 受现在 C++ 的启发, 同样引入了智能指针来管理
  堆内存. 智能指针在堆上开辟内存空间, 并拥有其所有权, 通过存储于栈中的指针来管理
  堆内存. 智能指针的 RAII 机制利用栈的特点, 在栈元素被自动清空时自动调用析构函数,
  来释放智能指针所管理的堆内存空间.

  现在 C++ 的 RAII 机制解决了无 GC 自动管理内存的基本问题, 但并没有解决全部问题,
  还存在着很多安全隐患.

  #+begin_src c++
    #include <iostream>
    #include <memory>

    using namespace std;

    int main()
    {
      unique_ptr<int> orig(new int(5));
      cout << *orig << endl;
      auto stolen = move(orig);
      cout << *orig << endl;
    }
  #+end_src

  执行结果:
  #+begin_example
    [1]    97674 segmentation fault  ./a.out
  #+end_example

  Rust 代码并没有显式地移动任何类似现代 C++ 中的 move 函数来转移所有权, 缺拥有和
  现代 C++ 一样的效果. 现在 C++ 中的 RAII 机制虽然也有所有权的概念, 但其作用范围
  非常有限, 仅智能指针有所有权, 并且现代 C++ 编译器也并没有依据所有权进行严格检
  查, 所以才会出现解引用空指针的运行时错误 segmentation fault. 而在 Rust 中, 所
  有权是系统性的概念, 是 Rust 语言中的基础设施. Rust 中的每个值都必定有一个唯一
  的控制者(即所有者). 所有权的转移都是按系统性的规则隐式地自动完成的.

  Rust 的所有权系统与法律上 "定分止争" 的思想不谋而合的. 所有权系统让每个值都有
  了明确的权属界限, 它们的行为也有了明确的权属界限, 这样内存安全就有了基本的保障.
  如果说所有权系统是内存管理的 "法律", 那么 Rust 编译器就是 "严格的执法者", 两者
  有机统一, 保障了内存安全. 如果代码中有违反所有权机制的行为, 编译器就会检查出来,
  让错误在编译期就无所遁形, 而不用等到运行时.
  
** 通用概念
   *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/104][issue]]

   当前计算机内存栈和堆的分配机制, 决定了编程语言中的值主要是分为 2 类: *值类型
   (Value)* 和 *引用类型(Reference)*. 像 C, C++, Java, JavaScript, C# 等语言都明
   确对值类型和引用类型作了区别, 而一些纯面向对象语言只剩下了引用类型的概念, eg:
   Ruby 和 Python 中, 一切皆对象, 而对象就是引用类型.

   *值类型一般是指可以将数据都保存到同一位置的类型*, 一些原生类型, eg: 数值, 布
   尔值, 结构体等都是值类型. 因此 *对值类型的操作效率一般比较高*, 使用完立即会被
   回收. 值类型作为 *右值(在值表达式中)* 执行赋值操作时, 会 *自动复制* 一个新的
   值副本. 并且该副本和原始的值没有直接关系, 互不影响

   *引用类型则会存在一个指向实际存储区域的指针*. eg: 通常一些引用类型会将数据存
   储在栈中, 而栈中只存放指向堆中数据的地址(指针). 因此对引用类型的操作效率一般
   比较低, 使用完交给 GC 回收, 这样更安全一些. 但是没有 GC 的语言则需要靠手工来
   回收, 就多了很多风险.

   基本的原生类型, 结构体和枚举体都属于值类型. 普通引用类型, 原生之后怎类型等都
   属于引用类型. 但随着语言的发展, 类型越来越丰富, 值类型和引用类型已经难以描述
   完全部情况. 
   
   为了更加精准地对这种情况进行描述, *值语义(Value Semantic)* 和 *引用语义
   (Reference Semantic)* 被引入, 定义如下:

   - 值语义: 复制(赋值操作)以后, 两个数据对象拥有的存储空间是独立的, 相互之间互
     不影响
   - 引用语义: 复制(赋值操作)以后, 两个数据对象, 相互之间互为别名. 操作其中任意
     一个数据对象, 则会影响到另一个.

   值语义可以保证变量值的 *独立性* (Independence): 如果项修改某个变量, 只能通过
   它本身来修改; 而如果修改了它本身, 并不影响其复制品. 也就是说, 如果只能通过变
   量本身来修改值, 那么它就是具有值语义的变量.

   对于引用语义的数据对象, 赋值操作时按位复制, 可能存在内存不安全风险. eg: 只复
   制了栈上的指针, 堆上的数据就多了一个管理者, 多了一层内存安全的隐患.

   按位复制: 只是复制 *值*, 而不会复制 *值中所包含指针指向的数据*. 也可以说, 它
   是浅复制的一种特定形式. 它不会进行深复制. eg: Rust 中的 String 字符串来说, 其
   本质是一个智能指针, 在栈上存储着元信息, 但是在堆里存储的具体的数据. 若对齐进
   行按位复制, 只会复制其栈上的元信息, 而不会复制其堆里的数据. 如果想深复制, 只
   能显式地调用其 clone 函数.

   对于整数类型, 当它作为右值赋给新的变量时, 编译器会默认自动调用 clone 方法进行
   *按位复制*. 被复制以后, 就是两个不同的值, *互不影响*.

   这是因为整数类型实现了 Copy trait, 对于实现 Copy 的类型, 其 clone 方法必须是
   按位复制的. 对于拥有值语义的整数类型, 整个数据存储于栈中, 按位复制以后, 不会
   对原有数据造成破坏, 不存在内存安全的问题.

   反观 C++, 当对象作为右值参与赋值的时候, 一般会建议开发者自定义实现复制构造函
   数, 但开发者很有可能忘记这样做, 那么这种情况下, 编译器就会默认实现复制构造函
   数来进行按位复制, 就会出现悬垂指针的内存安全问题, 解决的办法是自定义深复制构
   造函数, 将堆上的数据也复制一遍. 而 Rust 通过 Copy 这个标记 trait, 将类型 *按
   值语义和引用语义做了精准的分类*, 帮助编译器检测出潜在的内存安全问题.

   智能指针 ~Box<T>~ 封装了原生指针, 是典型的引用类型. ~Box<T>~ 无法实现 Copy,
   意味着它被 Rust 标记为了引用语义, *禁止实现按位复制*.

   值得注意的是, 虽然引用语义类型不能实现 Copy, 但可以实现 Clone 的 clone 方法,
   以实现深复制, 在需要的时候可以显式调用.
   
** 所有权机制
   *有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/104][issue]]

   在 Rust 中, 由 Copy trait 来区分只语义和引用语义. 但为了描述的更加精准, Rust
   也引入了新的语义: *复制(Copy)* 和 *移动(Move)* 语义. 复制语义对应值语义, 也就
   是说, 实现了 Copy 的类型, 在进行按位复制的时候, 是安全的. 移动语义对应引用语
   义. 复制语义对应值语义, 也就是说, 在传统语言(eg: C++)中本来是引用语义的类型,
   在 Rust 中不允许按位复制, 只允许移动所有权, 只有这样才能保证安全. 这样划分是
   因为引入了所有权机制, 在所有权机制下同时保证内存安全和性能. Rust 的数据默认存
   储在栈上.

   对于默认可以安全地在栈上进行按位复制的类型, 就只需要按位复制, 也方便管理内存.
   对于默认只可在堆上存储的数据, 因为无法安全地进行按位复制, 如果要保证内存安全,
   就 *必须进行深度复制*. 当然, 也可以把实现 Copy 的类型, 通过 Rust 提供的特定
   API (eg: Box 语法) 将其放到堆上, 但它既然是实现了 Copy, 就是可以安全进行按位
   复制的类型. 深度复制需要在堆内存中重新开辟空间, 这会带来更多的性能开销. 如果
   堆上的数据不变, 只需在栈上移动堆内存的指针地址, 不仅保证了内存安全, 还可以拥
   有在栈上进行复制的等同性能.

   所以, 对于 Rust 而言, 可以实现 Copy trait 的类型, 则表示它拥有复制语义, 在赋
   值或传入函数等行为时, 默认会进行按位复制. 它和传统概念中的值语义类型相对应,
   因为两个独立不关联的值, 操作其中一个, 不影响另外一个, 是安全的. 对于不能实现
   Copy trait 的类型, 它实际上和传统的引用语义类型相对应, 只不过在 Rust 中, 如果
   只是简单地按位复制, 则会出现悬垂指针问题. 所以, 为了安全, 它必须是移动语义.
   移动语义实际上在告诉编译器, 该类型不要简单的按位复制, 那样不安全. 所以, 其他
   语言中的引用语义到了 Rust 中, 就成了移动语义. 但是被移动的值, *相当于已经废
   弃* 了, 无法使用. 如果从这个角度看, 如果认为 Rust 语言中并不存在引用语义类型,
   只有值语义类型, 也是可以的. 另外, 需要注意: RUst 中 *默认的引用和指针也都实现
   了 Copy*. 

   *一个值的所有权被转移给另外一个变量绑定的过程, 就叫做所有权转移*.

   Rust 中每个值都有一个所有者, 更进一步说就是: Rust 中分配的每块内存都有其所有
   者, 所有者负责该内存的释放和读写权限, 并且每次每个值只能有唯一的所有者. 这就
   是 Rust 的 *所有权机制(OwnerShip)*.

*** 所有权的类型系统理论
    Rust 的所有权在类型系统理论中称为 *仿射类型(affine type)*, 它属于类型理论中
    *子结构类型系统(Substructural Type System)* 的概念. 子结构类型系统又是 *子结
    构逻辑(Substructural Logic)* 在类型系统中的应用. 而子结构逻辑属于证明理论里
    的推理规则, 其规则包含如下几点:

    - 线性逻辑(Linear Logic), 如果包含每个变量符合某种特定的 "结构", 它就内涵一
      种规则: *必须且只能使用一次*.
    - 仿射逻辑(Affine Logic), 和线性逻辑是类似地, 但它的规则是: *最多使用一次*.
      看上去线性逻辑更严格一些
    - 其他数据
      
    子结构逻辑规则则用于推理. 基于仿射类型, Rust 实现了所有权机制, 在需要移动的
    时候自己移动, 维护了内存安全.  

*** 所有权的特点
    所有者拥有以下三种权限:
    - 控制资源(不仅仅是内存)的释放
    - 出借所有权, 博阿含不可变(共享)和可变(独占)的
    - 转移所有权

    对于实现 Copy 的类型, 也就是复制语义类型来说, 按位复制并不会出现内存问题, 并
    且可以简化内存管理. 所以在赋值操作时, 作为右值的变量会默认进行按位复制. 但是
    对于禁止实现 Copy 的类型, 依旧是移动语义类型来说, 如果对其执行按位复制, 就会
    出现悬垂指针问题, 所以在进行赋值操作时, 作为右值的变量会默认执行移动语义来转
    移所有权, 从而保证了内存安全.

    对于可以实现 Copy 的复制语义类型来说, 所有权并未改变. 对于符合类型来说, 是复
    制还是移动, 取决于其成员的类型.

    枚举体和结构体是类似的, 当成员均为复制语义类型时, 不会自动实现 Copy. 而对于
    *元组类型* 来说, 其本身实现了 Copy, 如果元素均为复制语义类型, 则默认是按位复
    制的, 否则会执行移动语义.

    数组, Option 类型与元组类型都遵循这样的规则: 如果元组都是复制语义类型, 也就
    是都实现了 Copy, 那么它们就可以按位复制, 否则就转移所有权.

** 绑定, 作用域和生命周期
   Rust 使用 let 关键字来声明 "变量". let 有 let binding 之意, 声明的 "变量" 实
   际上不是传统意义上的变量, 而是指一种 *绑定语义*.

*** 不可变与可变
    "共享可变状态是万恶之源", 这句在业界流传已久的名言诉说着这样一个事实: 可变状
    态决不能共享, 否则会增加函数直接的耦合度, 函数中的变量状态在任何时候发生改变
    都将变得难以控制, 从而让函数产生 "副作用". 可变状态也更不利于多线程并发程序,
    容易引发数据竞争.

    在很多传统的编程语言中, 变量均为默认可变的, 开发者很难避免 "共享可变状态".
    随着近几年来函数式语言的逐渐流程, 其显著的优点也开始受到关注, 其中 *不可变*
    (Immutable) 的一些优点也逐渐体验了出来:

    - 多线程并发时, 不可变的数据可以安全地在线程间共享
    - 函数的 "副作用" 可以得到控制.

    Rust 语言吸收了函数式语言的诸多优势, 其中之一就是声明的绑定默认为不可变.
    
    可以使用 mut 关键字声明可变(Mutable)绑定.
    
*** 绑定的时间属性--生命周期
    变量绑定具有 "时空" 双重属性.

    - *空间属性* 是指标识符与内存空间进行了绑定.
    - *时间属性* 是指绑定的时效性, 也就是指它的生存周期
    
    一个绑定的生存周期也被称为 *生命周期(lifetime)*, 是和词法作用域有关的.

    默认的隐式词法作用域的伪代码:
    #+begin_example
      'a {
         let a = "hello";
         'b {
            let b = "rust";
            'c {
               let c = "world";
               'd {
                  let d = c;
               } // 作用域 'd
            } // 作用域 'c
         } // 作用域 'b
      } // 作用域 'a
    #+end_example

    最后声明的绑定作用域在 *最里面*

    绑定的析构顺序和声明顺序相反, 所以绑定 d 的生命周期是最短的, d 会先析构, 然
    后 c, b, a 依次析构, 所以 a 的生命周期最长. 所以, Rust 的生命周期是基于词法
    作用域的, 编译器能自动识别函数内部这些局部变量绑定的生命周期.

    当向绑定在词法作用域中传递的时候, 就会产生所有权的转移.

    综上所述, let 绑定会创建新的词法作用域, 如果有其他变量作为右值进行赋值操作,
    也就是绑定操作, 那么该变量因为进入了 let 创建的词法作用域, 所以要么转移所有
    权, 要么按位复制, 这取决于该变量是复制语义还是移动语义的.

    除了 let 声明, 还有一些场景会创建新的词法作用域.

*** 花括号
    可以使用花括号在函数体内创建词法作用域.

*** match 匹配
    match 匹配也会产生一个新的词法作用域.
    
*** 循环语句
    for, loop 以及 while 循环语句均可以创建新的作用域.

*** if let 和 while let 块
    也会创建新的作用域  

*** 函数
    函数体本身是独立的词法作用域. 当复制语义类型作为函数参数时, 会按位复制, 如果
    是移动语义作为函数参数, 则会转移所有权.

*** 闭包
    闭包会创建新的作用域, 对于换变量来说有以下三种捕获方式:
    - 对于复制语义类型, 以不可变引用(~&T~)来捕获
    - 对于移动语义类型, 执行移动语义(move)转移所有权来捕获
    - 对于可变绑定, 如果在闭包中包含对齐进行修改的操作, 则以可变引用(~&mut~)来捕
      获

** 所有权借用
   函数签名也支持模式匹配, 所以一个可变数组的函数签名参数, 可以传递不可变数组,
   相当于重新绑定.

*** 引用与借用
    *引用(Reference)* 是 Rust 提供的一种指针语义. 引用是基于指针的实现, 它与指针
    的区别是: 指针保存的是其指向内存的地址, 而引用可以看做某块内存的 *别名
    (Alias)*, 使用它需要满足编译器的各种安全检查规则. 引用也分为 *不可变引用* 和
    *可变引用*. 使用 ~&~ 符号进行不可变引用, 使用 ~&mut~ 符号进行可变引用.

    在所有权系统中, 引用 ~&x~ 也可称为 x 的 *借用(Borrowing)*, 通过 ~&~ 操作符来
    完成所有权租借. 既然是借用所有权, 那么引用并不会造成绑定变量所有权的转移. 但
    是借用所有权会让 *所有者(owner)* 受到如下限制:

    - 在不可变借用期间, 所有者不能修改资源, 并且也不能再进行可变借用
    - 在可变借用期间, 所有权不能访问资源, 并且也不能再出借所有权.

    *引用在离开作用域之时, 就是其归还所有权之时*. 使用借用, 与直接使用拥有所有权
    的值一样自然, 而且还不需要转移所有权.

    ~std::vec::Vec~ 中 ~len()~ 方法的源码实现
    #+begin_src rust
      pub fn len(&self) -> usize {
          self.len
      }
    #+end_src

    ~len~ 方法中的 ~&self~ 实际上是 ~self: &self~ 的简写, 因此, 可以直接调用.
    这同样利用了函数参数的模式匹配. 由此可见, 通过借用, 开发者可以在 *不转移所有
    权* 的情况下, 更加方便地对内存操作, 同时也让代码有良好的可读性和维护性.

*** 借用规则
    为保证内存安全, *借用必须遵循以下三个规则*:
    1. 借用的生命周期不能长于出借方(拥有所有权的对象)的生命周期.
    2. 可变借用(引用)不能有别名(Alias), 因为可变借用具有独占性
    3. 不可变借用(引用)不能再次出借为可变借用.

    规则一是为了防止出现悬垂指针. eg: 出借方已经被析构了, 但借用依然存在, 就会产
    生一个悬垂指针, 这是 Rust 绝对不允许出现的情况.

    规则二和三可以总结为一条核心的原则: *共享不可变, 可变不共享*. 相当于内存的读
    写锁, 同一时刻, 只能拥有一个写锁, 或者多个读锁, 不能同时拥有.

    Rust 编译器会做严格的借用检查, 违反以上规则的行为均无法正常通过编译.  

    不可变借用可以被出借多次, 因为它不能修改内存数据, 因此它也被称为共享借用(引
    用).可变借用只能出借一次, 否则, 难以预料数据何时何地会被修改.

    Rust 的借用检查带来了如下好处:
    - 不可变借用保证了没有任何指针可以修改的内存, 便于将值存储在寄存器中.
    - 可变借用保证了在写的时候没有任何指针可以读取值的内存, 避免了脏读.
    - 不可变借用保证了内存不会在读取之后被写入新数据.
    - 保证了不可变借用和可变借用不相互依赖, 从而可以对读写操作进行自由移动和重新
      排序.

    关于引用, 还有一个值得注意的地方: *解引用操作会获得所有权*. 在需要对语义类型
    (eg: ~&String~ 类型)进行解引用操作时, 需要注意这一点.

    
    
