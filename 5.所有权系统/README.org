* 所有权系统
  只有确定了权利归属, 才能防止纠纷的发生.
  通过法律划分出明确的权属界限, 才能理清每个人的行为界限, 合理保障个人的自由空间,
  利益范围和生命安全.

  内存管理不外如是. 栈内存的生命周期是短暂的, 会随着栈展开(常见的是函数调用)的过
  程而被自动清理. 而堆内存是动态的, 其分配和重新分配并不遵循某个固定的模式, 所以
  需要使用指着拿来对齐进行跟踪. Rust 受现在 C++ 的启发, 同样引入了智能指针来管理
  堆内存. 智能指针在堆上开辟内存空间, 并拥有其所有权, 通过存储于栈中的指针来管理
  堆内存. 智能指针的 RAII 机制利用栈的特点, 在栈元素被自动清空时自动调用析构函数,
  来释放智能指针所管理的堆内存空间.

  现在 C++ 的 RAII 机制解决了无 GC 自动管理内存的基本问题, 但并没有解决全部问题,
  还存在着很多安全隐患.

  #+begin_src c++
    #include <iostream>
    #include <memory>

    using namespace std;

    int main()
    {
      unique_ptr<int> orig(new int(5));
      cout << *orig << endl;
      auto stolen = move(orig);
      cout << *orig << endl;
    }
  #+end_src

  执行结果:
  #+begin_example
    [1]    97674 segmentation fault  ./a.out
  #+end_example

  Rust 代码并没有显式地移动任何类似现代 C++ 中的 move 函数来转移所有权, 缺拥有和
  现代 C++ 一样的效果. 现在 C++ 中的 RAII 机制虽然也有所有权的概念, 但其作用范围
  非常有限, 仅智能指针有所有权, 并且现代 C++ 编译器也并没有依据所有权进行严格检
  查, 所以才会出现解引用空指针的运行时错误 segmentation fault. 而在 Rust 中, 所
  有权是系统性的概念, 是 Rust 语言中的基础设施. Rust 中的每个值都必定有一个唯一
  的控制者(即所有者). 所有权的转移都是按系统性的规则隐式地自动完成的.

  Rust 的所有权系统与法律上 "定分止争" 的思想不谋而合的. 所有权系统让每个值都有
  了明确的权属界限, 它们的行为也有了明确的权属界限, 这样内存安全就有了基本的保障.
  如果说所有权系统是内存管理的 "法律", 那么 Rust 编译器就是 "严格的执法者", 两者
  有机统一, 保障了内存安全. 如果代码中有违反所有权机制的行为, 编译器就会检查出来,
  让错误在编译期就无所遁形, 而不用等到运行时.
  
** 通用概念
   *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/104][issue]]

   当前计算机内存栈和堆的分配机制, 决定了编程语言中的值主要是分为 2 类: *值类型
   (Value)* 和 *引用类型(Reference)*. 像 C, C++, Java, JavaScript, C# 等语言都明
   确对值类型和引用类型作了区别, 而一些纯面向对象语言只剩下了引用类型的概念, eg:
   Ruby 和 Python 中, 一切皆对象, 而对象就是引用类型.

   *值类型一般是指可以将数据都保存到同一位置的类型*, 一些原生类型, eg: 数值, 布
   尔值, 结构体等都是值类型. 因此 *对值类型的操作效率一般比较高*, 使用完立即会被
   回收. 值类型作为 *右值(在值表达式中)* 执行赋值操作时, 会 *自动复制* 一个新的
   值副本. 并且该副本和原始的值没有直接关系, 互不影响

   *引用类型则会存在一个指向实际存储区域的指针*. eg: 通常一些引用类型会将数据存
   储在栈中, 而栈中只存放指向堆中数据的地址(指针). 因此对引用类型的操作效率一般
   比较低, 使用完交给 GC 回收, 这样更安全一些. 但是没有 GC 的语言则需要靠手工来
   回收, 就多了很多风险.

   基本的原生类型, 结构体和枚举体都属于值类型. 普通引用类型, 原生之后怎类型等都
   属于引用类型. 但随着语言的发展, 类型越来越丰富, 值类型和引用类型已经难以描述
   完全部情况. 
   
   为了更加精准地对这种情况进行描述, *值语义(Value Semantic)* 和 *引用语义
   (Reference Semantic)* 被引入, 定义如下:

   - 值语义: 复制(赋值操作)以后, 两个数据对象拥有的存储空间是独立的, 相互之间互
     不影响
   - 引用语义: 复制(赋值操作)以后, 两个数据对象, 相互之间互为别名. 操作其中任意
     一个数据对象, 则会影响到另一个.

   值语义可以保证变量值的 *独立性* (Independence): 如果项修改某个变量, 只能通过
   它本身来修改; 而如果修改了它本身, 并不影响其复制品. 也就是说, 如果只能通过变
   量本身来修改值, 那么它就是具有值语义的变量.

   对于引用语义的数据对象, 赋值操作时按位复制, 可能存在内存不安全风险. eg: 只复
   制了栈上的指针, 堆上的数据就多了一个管理者, 多了一层内存安全的隐患.

   按位复制: 只是复制 *值*, 而不会复制 *值中所包含指针指向的数据*. 也可以说, 它
   是浅复制的一种特定形式. 它不会进行深复制. eg: Rust 中的 String 字符串来说, 其
   本质是一个智能指针, 在栈上存储着元信息, 但是在堆里存储的具体的数据. 若对齐进
   行按位复制, 只会复制其栈上的元信息, 而不会复制其堆里的数据. 如果想深复制, 只
   能显式地调用其 clone 函数.

   对于整数类型, 当它作为右值赋给新的变量时, 编译器会默认自动调用 clone 方法进行
   *按位复制*. 被复制以后, 就是两个不同的值, *互不影响*.

   这是因为整数类型实现了 Copy trait, 对于实现 Copy 的类型, 其 clone 方法必须是
   按位复制的. 对于拥有值语义的整数类型, 整个数据存储于栈中, 按位复制以后, 不会
   对原有数据造成破坏, 不存在内存安全的问题.

   反观 C++, 当对象作为右值参与赋值的时候, 一般会建议开发者自定义实现复制构造函
   数, 但开发者很有可能忘记这样做, 那么这种情况下, 编译器就会默认实现复制构造函
   数来进行按位复制, 就会出现悬垂指针的内存安全问题, 解决的办法是自定义深复制构
   造函数, 将堆上的数据也复制一遍. 而 Rust 通过 Copy 这个标记 trait, 将类型 *按
   值语义和引用语义做了精准的分类*, 帮助编译器检测出潜在的内存安全问题.

   智能指针 ~Box<T>~ 封装了原生指针, 是典型的引用类型. ~Box<T>~ 无法实现 Copy,
   意味着它被 Rust 标记为了引用语义, *禁止实现按位复制*.

   值得注意的是, 虽然引用语义类型不能实现 Copy, 但可以实现 Clone 的 clone 方法,
   以实现深复制, 在需要的时候可以显式调用.
   
