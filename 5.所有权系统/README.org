* 所有权系统
  只有确定了权利归属, 才能防止纠纷的发生.
  通过法律划分出明确的权属界限, 才能理清每个人的行为界限, 合理保障个人的自由空间,
  利益范围和生命安全.

  内存管理不外如是. 栈内存的生命周期是短暂的, 会随着栈展开(常见的是函数调用)的过
  程而被自动清理. 而堆内存是动态的, 其分配和重新分配并不遵循某个固定的模式, 所以
  需要使用指着拿来对齐进行跟踪. Rust 受现在 C++ 的启发, 同样引入了智能指针来管理
  堆内存. 智能指针在堆上开辟内存空间, 并拥有其所有权, 通过存储于栈中的指针来管理
  堆内存. 智能指针的 RAII 机制利用栈的特点, 在栈元素被自动清空时自动调用析构函数,
  来释放智能指针所管理的堆内存空间.

  现在 C++ 的 RAII 机制解决了无 GC 自动管理内存的基本问题, 但并没有解决全部问题,
  还存在着很多安全隐患.

  #+begin_src c++
    #include <iostream>
    #include <memory>

    using namespace std;

    int main()
    {
      unique_ptr<int> orig(new int(5));
      cout << *orig << endl;
      auto stolen = move(orig);
      cout << *orig << endl;
    }
  #+end_src

  执行结果:
  #+begin_example
    [1]    97674 segmentation fault  ./a.out
  #+end_example

  Rust 代码并没有显式地移动任何类似现代 C++ 中的 move 函数来转移所有权, 缺拥有和
  现代 C++ 一样的效果. 现在 C++ 中的 RAII 机制虽然也有所有权的概念, 但其作用范围
  非常有限, 仅智能指针有所有权, 并且现代 C++ 编译器也并没有依据所有权进行严格检
  查, 所以才会出现解引用空指针的运行时错误 segmentation fault. 而在 Rust 中, 所
  有权是系统性的概念, 是 Rust 语言中的基础设施. Rust 中的每个值都必定有一个唯一
  的控制者(即所有者). 所有权的转移都是按系统性的规则隐式地自动完成的.

  Rust 的所有权系统与法律上 "定分止争" 的思想不谋而合的. 所有权系统让每个值都有
  了明确的权属界限, 它们的行为也有了明确的权属界限, 这样内存安全就有了基本的保障.
  如果说所有权系统是内存管理的 "法律", 那么 Rust 编译器就是 "严格的执法者", 两者
  有机统一, 保障了内存安全. 如果代码中有违反所有权机制的行为, 编译器就会检查出来,
  让错误在编译期就无所遁形, 而不用等到运行时.
  
** 通用概念
   *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/104][issue]]

   当前计算机内存栈和堆的分配机制, 决定了编程语言中的值主要是分为 2 类: *值类型
   (Value)* 和 *引用类型(Reference)*. 像 C, C++, Java, JavaScript, C# 等语言都明
   确对值类型和引用类型作了区别, 而一些纯面向对象语言只剩下了引用类型的概念, eg:
   Ruby 和 Python 中, 一切皆对象, 而对象就是引用类型.

   *值类型一般是指可以将数据都保存到同一位置的类型*, 一些原生类型, eg: 数值, 布
   尔值, 结构体等都是值类型. 因此 *对值类型的操作效率一般比较高*, 使用完立即会被
   回收. 值类型作为 *右值(在值表达式中)* 执行赋值操作时, 会 *自动复制* 一个新的
   值副本. 并且该副本和原始的值没有直接关系, 互不影响

   *引用类型则会存在一个指向实际存储区域的指针*. eg: 通常一些引用类型会将数据存
   储在栈中, 而栈中只存放指向堆中数据的地址(指针). 因此对引用类型的操作效率一般
   比较低, 使用完交给 GC 回收, 这样更安全一些. 但是没有 GC 的语言则需要靠手工来
   回收, 就多了很多风险.

   基本的原生类型, 结构体和枚举体都属于值类型. 普通引用类型, 原生之后怎类型等都
   属于引用类型. 但随着语言的发展, 类型越来越丰富, 值类型和引用类型已经难以描述
   完全部情况. 
   
   为了更加精准地对这种情况进行描述, *值语义(Value Semantic)* 和 *引用语义
   (Reference Semantic)* 被引入, 定义如下:

   - 值语义: 复制(赋值操作)以后, 两个数据对象拥有的存储空间是独立的, 相互之间互
     不影响
   - 引用语义: 复制(赋值操作)以后, 两个数据对象, 相互之间互为别名. 操作其中任意
     一个数据对象, 则会影响到另一个.

   值语义可以保证变量值的 *独立性* (Independence): 如果项修改某个变量, 只能通过
   它本身来修改; 而如果修改了它本身, 并不影响其复制品. 也就是说, 如果只能通过变
   量本身来修改值, 那么它就是具有值语义的变量.

   对于引用语义的数据对象, 赋值操作时按位复制, 可能存在内存不安全风险. eg: 只复
   制了栈上的指针, 堆上的数据就多了一个管理者, 多了一层内存安全的隐患.

   按位复制: 只是复制 *值*, 而不会复制 *值中所包含指针指向的数据*. 也可以说, 它
   是浅复制的一种特定形式. 它不会进行深复制. eg: Rust 中的 String 字符串来说, 其
   本质是一个智能指针, 在栈上存储着元信息, 但是在堆里存储的具体的数据. 若对齐进
   行按位复制, 只会复制其栈上的元信息, 而不会复制其堆里的数据. 如果想深复制, 只
   能显式地调用其 clone 函数.

   对于整数类型, 当它作为右值赋给新的变量时, 编译器会默认自动调用 clone 方法进行
   *按位复制*. 被复制以后, 就是两个不同的值, *互不影响*.

   这是因为整数类型实现了 Copy trait, 对于实现 Copy 的类型, 其 clone 方法必须是
   按位复制的. 对于拥有值语义的整数类型, 整个数据存储于栈中, 按位复制以后, 不会
   对原有数据造成破坏, 不存在内存安全的问题.

   *存在改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/238][issue]]
   
   既然作为右值参与赋值即移动构造函数/移动赋值函数, 实现起来也是 move 内部指针而
   不是复制. 要深度复制用左值语义的拷贝构造函数/拷贝赋值函数.当对象作为右值参与
   赋值的时候, 一般会建议开发者自己定义实现移动构造函数/移动赋值函数. 一般对于
   ~Vector~ 这种类型, 如果使用右值引用, 需要显式地标记移动构造函数是否可以安全地
   使用. 而 Rust 通过 Copy 这个标记 trait, 将类型 *按值语义和引用语义做了精准的
   分类*, 帮助编译器检测出潜在的内存安全问题.

   智能指针 ~Box<T>~ 封装了原生指针, 是典型的引用类型. ~Box<T>~ 无法实现 Copy,
   意味着它被 Rust 标记为了引用语义, *禁止实现按位复制*.

   值得注意的是, 虽然引用语义类型不能实现 Copy, 但可以实现 Clone 的 clone 方法,
   以实现深复制, 在需要的时候可以显式调用.
   
** 所有权机制
   *有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/104][issue]]

   在 Rust 中, 由 Copy trait 来区分只语义和引用语义. 但为了描述的更加精准, Rust
   也引入了新的语义: *复制(Copy)* 和 *移动(Move)* 语义. 复制语义对应值语义, 也就
   是说, 实现了 Copy 的类型, 在进行按位复制的时候, 是安全的. 移动语义对应引用语
   义. 复制语义对应值语义, 也就是说, 在传统语言(eg: C++)中本来是引用语义的类型,
   在 Rust 中不允许按位复制, 只允许移动所有权, 只有这样才能保证安全. 这样划分是
   因为引入了所有权机制, 在所有权机制下同时保证内存安全和性能. Rust 的数据默认存
   储在栈上.

   对于默认可以安全地在栈上进行按位复制的类型, 就只需要按位复制, 也方便管理内存.
   对于默认只可在堆上存储的数据, 因为无法安全地进行按位复制, 如果要保证内存安全,
   就 *必须进行深度复制*. 当然, 也可以把实现 Copy 的类型, 通过 Rust 提供的特定
   API (eg: Box 语法) 将其放到堆上, 但它既然是实现了 Copy, 就是可以安全进行按位
   复制的类型. 深度复制需要在堆内存中重新开辟空间, 这会带来更多的性能开销. 如果
   堆上的数据不变, 只需在栈上移动堆内存的指针地址, 不仅保证了内存安全, 还可以拥
   有在栈上进行复制的等同性能.

   所以, 对于 Rust 而言, 可以实现 Copy trait 的类型, 则表示它拥有复制语义, 在赋
   值或传入函数等行为时, 默认会进行按位复制. 它和传统概念中的值语义类型相对应,
   因为两个独立不关联的值, 操作其中一个, 不影响另外一个, 是安全的. 对于不能实现
   Copy trait 的类型, 它实际上和传统的引用语义类型相对应, 只不过在 Rust 中, 如果
   只是简单地按位复制, 则会出现悬垂指针问题. 所以, 为了安全, 它必须是移动语义.
   移动语义实际上在告诉编译器, 该类型不要简单的按位复制, 那样不安全. 所以, 其他
   语言中的引用语义到了 Rust 中, 就成了移动语义. 但是被移动的值, *相当于已经废
   弃* 了, 无法使用. 如果从这个角度看, 如果认为 Rust 语言中并不存在引用语义类型,
   只有值语义类型, 也是可以的. 另外, 需要注意: RUst 中 *默认的引用和指针也都实现
   了 Copy*. 

   *一个值的所有权被转移给另外一个变量绑定的过程, 就叫做所有权转移*.

   Rust 中每个值都有一个所有者, 更进一步说就是: Rust 中分配的每块内存都有其所有
   者, 所有者负责该内存的释放和读写权限, 并且每次每个值只能有唯一的所有者. 这就
   是 Rust 的 *所有权机制(OwnerShip)*.

*** 所有权的类型系统理论
    Rust 的所有权在类型系统理论中称为 *仿射类型(affine type)*, 它属于类型理论中
    *子结构类型系统(Substructural Type System)* 的概念. 子结构类型系统又是 *子结
    构逻辑(Substructural Logic)* 在类型系统中的应用. 而子结构逻辑属于证明理论里
    的推理规则, 其规则包含如下几点:

    - 线性逻辑(Linear Logic), 如果包含每个变量符合某种特定的 "结构", 它就内涵一
      种规则: *必须且只能使用一次*.
    - 仿射逻辑(Affine Logic), 和线性逻辑是类似地, 但它的规则是: *最多使用一次*.
      看上去线性逻辑更严格一些
    - 其他数据
      
    子结构逻辑规则则用于推理. 基于仿射类型, Rust 实现了所有权机制, 在需要移动的
    时候自己移动, 维护了内存安全.  

*** 所有权的特点
    所有者拥有以下三种权限:
    - 控制资源(不仅仅是内存)的释放
    - 出借所有权, 博阿含不可变(共享)和可变(独占)的
    - 转移所有权

    对于实现 Copy 的类型, 也就是复制语义类型来说, 按位复制并不会出现内存问题, 并
    且可以简化内存管理. 所以在赋值操作时, 作为右值的变量会默认进行按位复制. 但是
    对于禁止实现 Copy 的类型, 依旧是移动语义类型来说, 如果对其执行按位复制, 就会
    出现悬垂指针问题, 所以在进行赋值操作时, 作为右值的变量会默认执行移动语义来转
    移所有权, 从而保证了内存安全.

    对于可以实现 Copy 的复制语义类型来说, 所有权并未改变. 对于符合类型来说, 是复
    制还是移动, 取决于其成员的类型.

    枚举体和结构体是类似的, 当成员均为复制语义类型时, 不会自动实现 Copy. 而对于
    *元组类型* 来说, 其本身实现了 Copy, 如果元素均为复制语义类型, 则默认是按位复
    制的, 否则会执行移动语义.

    数组, Option 类型与元组类型都遵循这样的规则: 如果元组都是复制语义类型, 也就
    是都实现了 Copy, 那么它们就可以按位复制, 否则就转移所有权.

** 绑定, 作用域和生命周期
   Rust 使用 let 关键字来声明 "变量". let 有 let binding 之意, 声明的 "变量" 实
   际上不是传统意义上的变量, 而是指一种 *绑定语义*.

*** 不可变与可变
    "共享可变状态是万恶之源", 这句在业界流传已久的名言诉说着这样一个事实: 可变状
    态决不能共享, 否则会增加函数直接的耦合度, 函数中的变量状态在任何时候发生改变
    都将变得难以控制, 从而让函数产生 "副作用". 可变状态也更不利于多线程并发程序,
    容易引发数据竞争.

    在很多传统的编程语言中, 变量均为默认可变的, 开发者很难避免 "共享可变状态".
    随着近几年来函数式语言的逐渐流程, 其显著的优点也开始受到关注, 其中 *不可变*
    (Immutable) 的一些优点也逐渐体验了出来:

    - 多线程并发时, 不可变的数据可以安全地在线程间共享
    - 函数的 "副作用" 可以得到控制.

    Rust 语言吸收了函数式语言的诸多优势, 其中之一就是声明的绑定默认为不可变.
    
    可以使用 mut 关键字声明可变(Mutable)绑定.
    
*** 绑定的时间属性--生命周期
    变量绑定具有 "时空" 双重属性.

    - *空间属性* 是指标识符与内存空间进行了绑定.
    - *时间属性* 是指绑定的时效性, 也就是指它的生存周期
    
    一个绑定的生存周期也被称为 *生命周期(lifetime)*, 是和词法作用域有关的.

    默认的隐式词法作用域的伪代码:
    #+begin_example
      'a {
         let a = "hello";
         'b {
            let b = "rust";
            'c {
               let c = "world";
               'd {
                  let d = c;
               } // 作用域 'd
            } // 作用域 'c
         } // 作用域 'b
      } // 作用域 'a
    #+end_example

    最后声明的绑定作用域在 *最里面*

    绑定的析构顺序和声明顺序相反, 所以绑定 d 的生命周期是最短的, d 会先析构, 然
    后 c, b, a 依次析构, 所以 a 的生命周期最长. 所以, Rust 的生命周期是基于词法
    作用域的, 编译器能自动识别函数内部这些局部变量绑定的生命周期.

    当向绑定在词法作用域中传递的时候, 就会产生所有权的转移.

    综上所述, let 绑定会创建新的词法作用域, 如果有其他变量作为右值进行赋值操作,
    也就是绑定操作, 那么该变量因为进入了 let 创建的词法作用域, 所以要么转移所有
    权, 要么按位复制, 这取决于该变量是复制语义还是移动语义的.

    除了 let 声明, 还有一些场景会创建新的词法作用域.

*** 花括号
    可以使用花括号在函数体内创建词法作用域.

*** match 匹配
    match 匹配也会产生一个新的词法作用域.
    
*** 循环语句
    for, loop 以及 while 循环语句均可以创建新的作用域.

*** if let 和 while let 块
    也会创建新的作用域  

*** 函数
    函数体本身是独立的词法作用域. 当复制语义类型作为函数参数时, 会按位复制, 如果
    是移动语义作为函数参数, 则会转移所有权.

*** 闭包
    闭包会创建新的作用域, 对于换变量来说有以下三种捕获方式:
    - 对于复制语义类型, 以不可变引用(~&T~)来捕获
    - 对于移动语义类型, 执行移动语义(move)转移所有权来捕获
    - 对于可变绑定, 如果在闭包中包含对齐进行修改的操作, 则以可变引用(~&mut~)来捕
      获

** 所有权借用
   函数签名也支持模式匹配, 所以一个可变数组的函数签名参数, 可以传递不可变数组,
   相当于重新绑定.

*** 引用与借用
    *引用(Reference)* 是 Rust 提供的一种指针语义. 引用是基于指针的实现, 它与指针
    的区别是: 指针保存的是其指向内存的地址, 而引用可以看做某块内存的 *别名
    (Alias)*, 使用它需要满足编译器的各种安全检查规则. 引用也分为 *不可变引用* 和
    *可变引用*. 使用 ~&~ 符号进行不可变引用, 使用 ~&mut~ 符号进行可变引用.

    在所有权系统中, 引用 ~&x~ 也可称为 x 的 *借用(Borrowing)*, 通过 ~&~ 操作符来
    完成所有权租借. 既然是借用所有权, 那么引用并不会造成绑定变量所有权的转移. 但
    是借用所有权会让 *所有者(owner)* 受到如下限制:

    - 在不可变借用期间, 所有者不能修改资源, 并且也不能再进行可变借用
    - 在可变借用期间, 所有权不能访问资源, 并且也不能再出借所有权.

    *引用在离开作用域之时, 就是其归还所有权之时*. 使用借用, 与直接使用拥有所有权
    的值一样自然, 而且还不需要转移所有权.

    ~std::vec::Vec~ 中 ~len()~ 方法的源码实现
    #+begin_src rust
      pub fn len(&self) -> usize {
          self.len
      }
    #+end_src

    ~len~ 方法中的 ~&self~ 实际上是 ~self: &self~ 的简写, 因此, 可以直接调用.
    这同样利用了函数参数的模式匹配. 由此可见, 通过借用, 开发者可以在 *不转移所有
    权* 的情况下, 更加方便地对内存操作, 同时也让代码有良好的可读性和维护性.

*** 借用规则
    为保证内存安全, *借用必须遵循以下三个规则*:
    1. 借用的生命周期不能长于出借方(拥有所有权的对象)的生命周期.
    2. 可变借用(引用)不能有别名(Alias), 因为可变借用具有独占性
    3. 不可变借用(引用)不能再次出借为可变借用.

    规则一是为了防止出现悬垂指针. eg: 出借方已经被析构了, 但借用依然存在, 就会产
    生一个悬垂指针, 这是 Rust 绝对不允许出现的情况.

    规则二和三可以总结为一条核心的原则: *共享不可变, 可变不共享*. 相当于内存的读
    写锁, 同一时刻, 只能拥有一个写锁, 或者多个读锁, 不能同时拥有.

    Rust 编译器会做严格的借用检查, 违反以上规则的行为均无法正常通过编译.  

    不可变借用可以被出借多次, 因为它不能修改内存数据, 因此它也被称为共享借用(引
    用).可变借用只能出借一次, 否则, 难以预料数据何时何地会被修改.

    Rust 的借用检查带来了如下好处:
    - 不可变借用保证了没有任何指针可以修改的内存, 便于将值存储在寄存器中.
    - 可变借用保证了在写的时候没有任何指针可以读取值的内存, 避免了脏读.
    - 不可变借用保证了内存不会在读取之后被写入新数据.
    - 保证了不可变借用和可变借用不相互依赖, 从而可以对读写操作进行自由移动和重新
      排序.

    关于引用, 还有一个值得注意的地方: *解引用操作会获得所有权*. 在需要对语义类型
    (eg: ~&String~ 类型)进行解引用操作时, 需要注意这一点.

        
** 生命周期参数
   值的生命周期和词法作用域有关, 但是借用可以在各个函数间传递, 必然会跨越多个词
   法作用域. 对于函数本地声明的拥有所有权的值或者借用来说, Rust 编译器包含的借用
   检查器(borrow checker)可以检查它们的生命周期, 但是对于跨词法作用域的借用, 借
   用检查器就无法自动判断借用的合法性了, 也就是说, 无法判断这些跨词法作用域的借
   用是否满足借用规则. 不合法的借用会产生悬垂指针, 造成内存不安全. 所以, Rust 必
   须确保所有的借用都是有效的, 不会存在悬垂指针.

*** 显式生命周期参数
    生命周期参数比如以单引号开头, 参数名通常都是小写字母, eg: ~'a~. 生命周期参数
    位于引用符号 ~&~ 后面, 并使用空格来分割生命周期参数和类型. 如下所示
    #+begin_src rust
      &i32; // 引用
      &'a i32; // 标注生命周期参数的引用
      &'a mut i32; // 标注生命周期参数的可变引用
    #+end_src

    *标注生命周期参数并不能改变任何引用的生命周期长短, 它只用于编译器的借用检查*.
    用来防止悬垂指针. 

*** 函数签名中的生命周期参数
    函数签名中的生命周期参数使用如下标注语法:
    #+begin_src rust
      fn foo<'a>(s: &'a str, t: &'a str) -> &'a str;
    #+end_src

    函数名后面的 ~<'a>~ 为生命周期参数的声明, 与泛型参数类似, 必须先声明才能使用.
    函数或方法参数的生命周期叫做 *输入生命周期(input lifetime)*, 而返回的生命周
    期被称为 *输出生命周期(output lifetime)*.

    *有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/188][issue]]

    函数签名的生命周期参数有这样的限制条件: 输出(借用方)的生命周期长度必须不长于
    输入(出借方)的生命周期长度(此条件依然遵循借用规则一).

    另外, 需要注意: *禁止在没有任何输入参数的情况下返回引用*.

    *从函数中返回(输出)一个引用, 其生命周期参数必须与函数的参数(输入)相匹配, 否
    则, 标注生命周期也毫无意义*.
    
    只要借用方的生命周期不长于出借方的生命周期长度, 就不会造成悬垂指针.

    ~'b:'a~ 的意思是泛型生命周期参数 ~'b~ 的存活时间长于泛型生命周期参数 ~'a~
    (即 ~'b~ outlive ~'a~). 即为 ~'a~ 是 ~'b~ 的子集.

    即使实际传入变量的生命周期不同, *生命周期参数是为了帮助借用检查器验证非法借
    用*. *函数间传入和返回的借用必须相关联*, *并且返回的借用生命周期必须不长于出
    借方的生命周期*. 所以 ~'b:'a~ 中的 ~'a~ 是指返回引用(借用)的生命周期, 必须不
    能长于 ~'b~ (出借方)的生命周期.

    函数在调用时, 其参数的泛型生命周期参数 ~'a~ 和 ~'b~ 会单态化为具体的生命周期
    参数 ~'s1~ 和 ~'s2~, 其返回引用的泛型生命周期参数 ~'a~ 也会单态化为 ~'t~, 因
    为 ~res~ 绑定了该返回的引用, 所以 ~'r~ 和 ~'t~ 是等价的. Rust 里 let 绑定的
    声明顺序正好和析构顺序相反, 这是由栈结构的后进先出特性决定的. 所以, res,
    ~&s2~ 和 ~s1_r~ 的析构顺序是 ~res~ 最先, 然后是 ~&s2~, 最后是 ~s1_r~. 在
    ~res~ 析构之前, ~&s2~ 必须存活, 否则就会产生悬垂指针, 造成内存不安全, 这是
    Rust 绝对不允许的. 

    ~res~ 的生命周期参数是 ~'r~, ~&s2~ 的生命周期参数是 ~'s2~, 它们的关系是
    ~'s2:'r~, ~'s2~ 的存活时间长于 ~'r~. 而 ~'s2~ 和 ~'r~ 分别对应其函数签名中的
    生命周期泛型参数 ~'b~ 和 ~'a~, 所以得出: ~'b:'a~. 而对于参数 ~s1_r~ 来说, 其
    生命周期参数 ~'s1~ 对应生命周期泛型参数 ~'a~, 本身 ~'s1~ 和 ~'r~ 的关系就是
    ~'s1:'r~, 这也满足 ~'a:'a~.

    函数签名中多个生命周期函数的关系看上去比较复杂, 但是只要把握一个原则就可以理
    解它: *生命周期参数的目的是帮助借用检查器验证合法的引用, 消除悬垂指针*. 在
    Rust 官方文档中提到, 这种生命周期参数包含关系是一种子类型, 并且用 ~&'a str~
    和 ~&' static str~ 两种类型做了示例, 对于所有允许使用 ~&'a str~ 类型的地方,
    使用 ~&' static str~ 也是合法的. 但实际上, Rust 中的生命周期参数并非类型,
    ~&'static str~ 也只是 Rust 中少有的特例. 也有人按集合论总结除了判断生命周期
    参数的所谓公式, 但即使使用公式, 也一定要搞懂生命周期参数背后的意义.

*** 结构体定义中的生命周期参数
    除了函数签名, 结构体在含有引用类型成员的时候也需要标注生命周期函数, 否则编译
    器会报错.

    结构体 ~Foo~ 有一个成员为 ~&str~ 类型, 必须先声明生命周期泛型参数 ~<'a>~, 才
    能为成员 ~part~ 标注生命周期参数, 变为 ~&'a str~ 类型. 这里的生命周期参数标
    记, *实际上是和编译器约定了一个规则: 结构体实例的生命周期应短于或等于任意一
    个成员的生命周期*.

    使用 ~first~ 实例化结构体 ~Foo~ 时, 编译器就会根据该结构体实现定义的生命周期
    规则对其成员 ~part~ 的生命周期长度进行检查. 当前 ~part~ 的生命周期是整个
    ~main~ 函数, 而 ~Foo~ 结构体实例 ~f~ 的生命周期确实小于其成员 ~part~ 的声明
    周期, ~f~ 会在 ~first~ 之前被析构. 否则, 如果 ~first~ 被析构, ~f.part~ 就会
    成员悬垂指针, 这是 Rust 绝对不允许的.

*** 方法定义中的生命周期参数
    假如为结构体 ~Foo~ 方法, 因为其包含引用类型的成员, 标注了生命周期参数, 所以
    需要在 ~impl~ 关键字之后声明生命周期参数, 并在结构体 ~Foo~ 名称之后使用, 这
    与泛型参数是类似的.

*** 静态生命周期参数
    Rust 内置了一种特殊的生命周期 ~'static~, 叫作 *静态生命周期*. ~'static~ 生命
    周期存活于整个程序运行期间. 所有的字符串字面量都有 ~'static~ 生命周期, 类型
    为 ~&'static str~.

    字符串字面量是全局静态类型, 它的数据和程序代码一起存储于可执行文件的数据段中,
    其地址在编译期是已知的, 并且是只读的, 无法更改.
    #+begin_example
           可执行文件组成结构                                            虚拟内存空间
      ----------------------------------------
               |       |
               | Code  |            代码段                        高地址 ---------
      只读区    | 代码段 |                                               |   ...  |
               |       |                                               ----------           
               -------------------------------                         | 栈区    |
               | RO  data |                                            |        | 
               | 只读数据段 |                                            |        |
               |          |                                            | 堆区    |
               |          |                                            ----------
      ----------------------        数据段       -------->              | 数据区  |
               |  RW  data |                                           -----------
       读写区   |  读写数据段 |                                           | 代码区   |
               |           |                                           -----------
      -----------------------------------------                        |   ...   |
                                                                  低地址 -----------
    #+end_example
    
    对于存储于栈上的静态字符串, 因为数据段是只读的, 并不会出现什么内存不安全的问
    题.

    在 Rust 2018 中, 使用 ~const~ 和 ~static~ 定义字符串字面量时, 都可以省略掉
    ~'static~ 静态生命周期参数

*** 省略生命周期参数
    对于理论上需要显式地标注生命周期参数的情况, 实际中依然存在可以省略生命周期参
    数的可能.

    Rust 针对某些场景确定了一些常见的模式, 将其硬编码到 Rust 编译器中, 以便编译
    器可以自动补齐函数签名中的生命周期参数, 这样就可以省略生命周期参数. 被硬编码
    进编译器的模式成为 *生命周期省略规则(Lifetime Elision Rule)*, 一共包含三条规
    则:

    - 每个输入位置上省略的生命周期都将成为一个不同的生命周期参数
    - 如果只有一个输入生命周期的位置(不管是否忽略), 则该生命周期都将分配给输出生
      命周期.
    - 如果存在多个输入生命周期的位置, 但是其中包含着 ~&self~ 或 ~&mut self~, 则
      ~self~ 的生命周期都将分配给输出生命周期
    
    如果不满足上面三条规则, 省略生命周期会出错.
      
*** 生命周期限定
    生命周期参数可以像 trait 那样作为泛型的限定, 有以下两种形式:
    - ~T~: ~'a~: 表示 ~T~ 类型中的任何引用都要 "活得" 和 ~'a~ 一样长
    - ~T~: ~Trait + 'a~: 表示 ~T~ 类似必须实现 ~Trait~ 这个 trait, 并且 ~T~ 类型
      中任何引用都要 "活得" 和 ~'a~ 一样长.

    对于引用类型 ~&T~ 来说, 可以显式地使用生命周期限定来约束其生命周期. 但是对于
    没有引用的泛型类型 ~T~ 来说, 可以看做使用静态生命周期作为限定, 形如: ~T:
    'static~, 因为引用的生命周期只可能是暂时的, 而非 ~'static~ 的. 程序中一旦出
    现了 ~'static~, 就代表 *其生命周期与硬编码(Hardcode)* 的生命周期一样长久.

    
*** trait 对象的生命周期
    trait 对象和生命周期有默认的规则
    - trait 对象的生命周期默认是 ~'static~
    - 如果实现 trait 的类型包含 ~&'a X~ 或 ~&' a mut X~, 则默认生命周期就是 ~'a~.
    - 如果实现 trait 的类型只有 ~T: 'a~, 则默认生命周期就是 ~'a~.
    - 如果实现 trait 的类型包含多个类似 ~T: 'a~ 的从句, 则生命周期需要明确指定

** 智能指针与所有权
   除了普通的引用(借用)类型, Rust 还提供具有移动语义(引用语义)的智能指针. 智能指
   针和普通引用的区别之一就是所有权的不同. 智能指针拥有资源的所有权, 而普通引用
   只是对所有权的借用.

   ~Box<T>~ 实现 deref 方法的源码
   #+begin_src rust
     impl<T: ?Sized> Deref for Box<T> {
         type Target = T;
         fn deref(&self) -> &T {
             &**self
         }
     }
   #+end_src
   
   此方法返回的是 ~&T~ 类型. 这里没有添加生命周期参数是因为满足生命周期省略规则.
   实际上, 这里的 ~*a~ 和 ~*b~ 操作相当于 ~*(a.deref()) 和 ~*(b.deref())~ 操作.
   对于 ~Box<T>~ 类型来说, *如果包含的类型 ~T~ 属于复制语义, 则执行按位复制*;
   *如果属于移动语义, 则移动所有权*.

   这种对 ~Box<T>~ 使用操作符(~*~)进行解引用而转移所有权的行动, 被称为 *解引用移
   动*, 理论上应该使用 trait DerefMove 定义此行为, 这也是官方未来团队打算做的,
   但实际上 Rust 源码中并不存在此 trait. *目前支持此行为的智能指针只有 ~Box<T>~
   .*, ~Rc<T>~ 和 ~Arc<T>~ 不支持解引用移动.

   #+begin_src rust
     #[lang = "owned_box"]
     pub struct Box<T:?Sized>(Unique<T>);
   #+end_src

   ~Box<T>~ 标注了 Lang Item 为 "owned_box", 编译器由此来识别 ~Box<T>~ 类型, 因
   为 ~Box<T>~ 与原生类型不同, 并不具备类型名称(eg: bool), 但它代表所有权唯一的
   智能指针的特殊性, 所以需要使用 Lang Item 来专门识别, 而其他的智能指针不是这样
   的.

   ~Box<T>~ 和其他指针相同的地方在于内部都使用了 box 关键字来进行堆分配.

   #+begin_src rust
     impl<T> Box<T> {
         pub fn new(x: T) -> Box<T> {
             box x
         }
     }

     impl<T> Rc<T> {
         pub fn new(x: T) -> Rc<T> {
             unsafe {
                 Rc {
                     ptr: Shared::new(Box::into_raw(box RcBox {})),
                 }
             }
         }
     }

     impl<T> Arc<T> {
         pub fn new(x: T) -> Arc<T> {
             let x: Box<_> = box ArcInner {};
         }
     }
   #+end_src
   

   box 关键字 *只可以在 Rust 源码内部使用*, 并未作为公开 API 使用.

   box 关键字会调用内部堆分配方法 ~exchange_malloc()~ 和堆释放方法 ~box_free()~
   进行堆内存管理.
   
   #+begin_src rust
     #[cfg_attr(not(test), lang = "box_free")]
     #[inline]
     pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {
         // ...
         // Heap.dealloc(ptr as *mut u8, layout);

         unsafe {
             let size = size_of_val(ptr.as_ref());
             let align = min_align_of_val(ptr.as_ref());
             let layout = Layout::from_size_align_unchecked(size, align);
             Global.dealloc(ptr.cast().into(), layout)
         }
     }

     #[cfg(not(test))]
     #[lang = "exchange_malloc"]
     #[inline]
     unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {
         // ...
         // Heap.alloc(layout)
    
         let layout = unsafe { Layout::from_size_align_unchecked(size, align) };
         match Global.alloc(layout) {
             Ok(ptr) => ptr.as_mut_ptr(),
             Err(_) => handle_alloc_error(layout),
         }
     }
   #+end_src

   这两个方法都被标注了 Lang Item, 方便编译器来识别. ~box_free()~ 用于释放
   (dealloc) 堆内存, ~exchange_malloc()~ 用于分配(alloc) 堆内存.

*** 共享所有权 Rc<T> 和 Weak<T>
    引用计数(reference counting)可以说是简单的 GC 算法之一了, 应用于多种语言.
    Rust 中提供了 ~Rc<T>~ 智能指针来支持引用计数, 但不同于 GC 的是, Rust 是确定
    性的析构, 开发者知道什么时候会被析构.

    Rust 中只有拥有所有权才能释放资源, ~Rc<T>~ 可以将多个所有权共享给多个变量,
    每当共享一个所有权时, 计数就会增加一次, 只有当计数为 0, 也就是当所有共享变量
    离开作用域时, 该值才会被析构. ~Rc<T>~ 主要用于希望共享堆上分配的数据可以供程
    序的多个部分读取的场景, 并且主要确保共享的资源析构函数都能被调用到. ~Rc<T>~
    是单线程引用计数指针, 不是线程安全的类型, Rust 也不允许它被传递或共享给别的
    线程.

    Rc 的 ~clone()~ 并非深复制, 只是简单地增加共享所有权的计数, 但是这个计数操作
    会产生一定的计算型开销.

    通过 ~clone()~ 方法共享的引用所有权被称为 *强引用*. Rc 上的静态方法
    ~downgrade()~ 创建了另外一种智能指针类型 ~Weak<T>~, 它也是引用计数指针, 属于
    ~Rc<T>~ 的另一种版本, 它共享的指针没有所有权, 所以被称为 *弱引用*, 但
    ~Weak<T>~ 还保留对 ~Rc<T>~ 中值的引用. ~Rc::strong_count()~ 返回的是强引用的
    计数, ~Rc::weak_count()~ 返回的是弱引用的计数.

    可以使用 ~Weak<T>~ 弱引用解决循环引用问题. 也可以通过使用 Arena 模式来解决.
    即利用线性数组来模拟节点之间的关系, 可以有效避免循环引用.

*** 内部可变性 Cell<T> 和 RefCell<T>
    Rust 中的可变或不可变主要是针对一个变量绑定而言的, eg: 对于结构体来说, 可变
    或不可变只能对其实例进行设置, 而不腻设置单个成员的可变性. 但是在实际的开发中,
    某个字段是可变而其他字段不可变的情况确实存在, eg: 在网络请求中, 每个请求博阿
    含的路径, 参数等状态, 都应该是可变的. Rust 提供了 ~Cell<T>~ 和 ~RefCell<T>~
    来应对这种情况. 它们本质上不属于智能指针, 只是可以提供内部可变性(Interior
    Mutability)的容器.

**** Cell<T>
     内部可变性实际上是 Rust 中的一种设计模式. 内部可变性容器是对 Stuct 的一种封
     装, 表面不可变, 但内部可以通过某种方法来改变里面的值.
     
     使用 ~Cell<T>~ 内部可变容器确实方便了编程. 它提供的 ~set()~ / ~get()~ 方法
     像极了 OOP语言中场景的 setter/getter 方法, 封装了对象属性的获取和设置行为.
     ~Cell<T>~ 通过对外暴露的 ~set()~ / ~get()~ 方法实现了对内部值的修改, 而其本
     身确是不可变的. 所以, 实际上 ~Cell<T>~ 包裹的 ~T~ 本身合法地避开了借用检查. 

     对于包裹在 ~Cell<T>~ 中的类型 ~T~, 只有实现了 Copy 的类型 ~T~, 才可以使用
     get 方法获取包裹的值, 因为 get 方法内部返回的是对内部值的复制. 但是任何类型
     ~T~ 都可以使用 set 方法修改其包裹的值. 由此可见, ~Cell<T>~ 并没有违反 Rust
     保证的内存安全原则, 对于实现 Copy 的类型 ~T~, 可以任意读取; 对于没有实现
     Copy 的类型 ~T~, 则提供了 ~get_mut()~ 方法来返回可变引用, 依然遵循 Rust 的
     借用检查规则.

     使用 ~Cell<T>~ 虽然没有运行时开销, 但是尽量不要用它包裹大的结构体, 应该选择
     包装某个字段, 因为 ~Cell<T>~ 内部每次 get/set 都会执行一次按位复制.

**** RefCell<T>
     对于没有实现 Copy 的类型, 使用 ~Cell<T>~ 有许多不便. Rust 提供的
     ~RefCell<T>~ 使用的范围更广, 对类型 ~T~ 并没有 Copy 的限制.

     ~RefCell<T>~ 提供了 ~borrow()~ / ~borrow_mut()~ 方法, 对应 ~Cell<T>~ 的
     ~get()~ / ~set()~ 方法. ~RefCell<T>~ 虽然没有分配空间, 但它是有运行时开销的,
     因为它自己维护着一个运行时借用检查器, 如果在运行时出现了违反借用规则的情况,
     eg: 持有多个可变借用, 则会引发线程 panic.

     若通过 ~borrow_mut()~ 方法第二次获取可变引用, 这显然违反了借用规则, 虽然是
     运行时检查, 但其借用规则和 Rust 编译器借用检查规则是一样的, 所以此时 main
     函数线程就会崩溃.

     ~Cell<T>~ 和 ~RefCell<T>~ 使用最多的场景就是配合只读引用来使用, eg: ~&T~ 或
     ~Rc<T>~. 

     ~Cell<T>~ 和 ~RefCell<T>~ 之间的区别可以总结如下:
     - ~Cell<T>~ 使用 ~set()~ / ~get()~ 方法直接操作包裹的值, ~RefCell<T>~ 通过
       ~borrow()~ / ~borrow_mut()~ 返回包装过的引用 ~Ref<T>~ 和 ~RefMut<T>~ 来操
       作包裹的值
     - ~Cell<T>~ 一般适合复制语义类型(实现了 Copy), ~RefCell<T>~ 一般适合移动语
       义类型(未实现 Copy).
     - ~Cell<T>~ 无运行时开销, 并且拥有不会在运行时引发 panic 错误. ~RefCell<T>~
       需要在运行时借用检查, 所以有运行时开销, 一旦发现违反借用规则的情况, 则会
       引发线程 panic 而退出当前线程.

     在日常的编程开发中, 不要为了专门避开借用检查而使用 ~Cell<T>~ 或
     ~RefCell<T>~, 而应该仔细分析具体的需求来选择适合的解决方法.  

**** 写时复制 Cow<T>
     写时复制(Copy on Write)技术是一种程序中的优化策略, 被应用于多种场景. eg:
     Linux 中父进程创建子进程时, 并不是立刻让子进程复制一份进程空间, 而是先让子
     进程共享父进程的进程空间, 只有等到子进程真正需要写入的时候才复制进程空间.
     这种 "拖延" 技术实际上很好地减少了开销. Rust 也采纳这种思想提供了 ~Cow<T>~
     容器.

     ~Cow<T>~ 是一个枚举体的智能指针, 包括两个可选值
     - Borrowed, 用于包裹引用
     - Owned, 用于包裹所有者.

     跟 ~Option<T>~ 类型有点相似, ~Option<T>~ 表示的是值的 "有" 和 "无", 而
     ~Cow<T>~ 表示的是所有权的 "借用" 和 "拥有".

     ~Cow<T>~ 提供的功能是: *以不可变的方式访问借用内容, 以及在需要可变借用或所
     有权的时候再克隆一份数据*. ~Cow<T>~ 实现了 Deref, 这意味着可以直接调用其包
     含数据的不可变方法. ~Cow<T>~ 旨在减少复制操作, 提高性能, 一般用于读多写少的
     场景.

     ~Cow<T>~ 写时复制使用要点:
     - ~Cow<T>~ 实现了 Deref, 所以可以直接调用 ~T~ 的不可变方法
     - 在需要修改 ~T~ 时, 可以使用 ~to_mut()~ 方法来获取可变借用. 该方法会产生克
       隆, 但仅克隆一次, 如果多次调用, 则只会使用第一次的克隆对象. 如果 ~T~ 本身
       拥有所有权, 则此时调用 ~to_mut()~ 不会发生克隆.
     - 在需要修改 ~T~ 时, 也可以使用 ~into_owned()~ 方法来获取一个拥有所有权的对
       象. 如果 ~T~ 是借用类型, 这个过程会发生克隆, 并创建新的所有权对象. 如果
       ~T~ 是所哟去对象, 则会将所有权转移到新的克隆对象.

     *' ~Cow<T>~ 的另一个用处是统一实现规范*.

     附加: 
     1. 针对 ~into()~ 的探讨: [[https://wiki.jikexueyuan.com/project/rust-primer/intoborrow/into.html][极客学院]] 
     2. 针对 ~Cow<T>~ 的更多用法: [[https://wiki.jikexueyuan.com/project/rust-primer/intoborrow/cow.html][极客学院]]
     
** 并发安全与所有权
   Rust 的内存安全特性也非常适合用于并发, 保证线程安全. Rust 使用了 2 个标签
   trait: Send 和 Sync 来对类型进行分类.

   - 如果类型 ~T~ 实现了 Send, 就是告诉编译器该类型的实例可以在线程间安全传
     递所有权
   - 如果类型 ~T~ 实现了 Sync, 就是表明可以安全地跨线程共享, 向编译器表明该类型
     的实例在多线程并发中不可能导致内存不安全.
     
   Rust 提供了一些线程安全的同步机制, eg: ~Arc<T>~, ~Mutex<T>~, ~RwLock<T>~ 和
   Atomic 系列类型. 以下为简要说明:

   - ~Arc<T>~ 是线程安全版本的 ~Rc<T>~
   - ~Mutex<T>~ 是锁, 同一时间仅允许有一个线程进行操作.
   - ~RwLock<T>~ 相当于线程安全版本的 ~RefCell<T>~, 同时运行多个 reader 或者一个 writer.
   - Atomic 系列类型包括: AtomicBool, Aomiclsize, AtomicUsize 和 AtomicPtr 这 4
     种, 虽然比较少, 但是可以用 AtomicPtr 来模拟其他想要的类型, 它相当于线程安全
     版本的 ~Cell<T>~.

   11 章会详细讲解并发安全.  
