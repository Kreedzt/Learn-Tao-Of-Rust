* 所有权系统
  只有确定了权利归属, 才能防止纠纷的发生.
  通过法律划分出明确的权属界限, 才能理清每个人的行为界限, 合理保障个人的自由空间,
  利益范围和生命安全.

  内存管理不外如是. 栈内存的生命周期是短暂的, 会随着栈展开(常见的是函数调用)的过
  程而被自动清理. 而堆内存是动态的, 其分配和重新分配并不遵循某个固定的模式, 所以
  需要使用指着拿来对齐进行跟踪. Rust 受现在 C++ 的启发, 同样引入了智能指针来管理
  堆内存. 智能指针在堆上开辟内存空间, 并拥有其所有权, 通过存储于栈中的指针来管理
  堆内存. 智能指针的 RAII 机制利用栈的特点, 在栈元素被自动清空时自动调用析构函数,
  来释放智能指针所管理的堆内存空间.

  现在 C++ 的 RAII 机制解决了无 GC 自动管理内存的基本问题, 但并没有解决全部问题,
  还存在着很多安全隐患.

  #+begin_src c++
    #include <iostream>
    #include <memory>

    using namespace std;

    int main()
    {
      unique_ptr<int> orig(new int(5));
      cout << *orig << endl;
      auto stolen = move(orig);
      cout << *orig << endl;
    }
  #+end_src

  执行结果:
  #+begin_example
    [1]    97674 segmentation fault  ./a.out
  #+end_example

  Rust 代码并没有显式地移动任何类似现代 C++ 中的 move 函数来转移所有权, 缺拥有和
  现代 C++ 一样的效果. 现在 C++ 中的 RAII 机制虽然也有所有权的概念, 但其作用范围
  非常有限, 仅智能指针有所有权, 并且现代 C++ 编译器也并没有依据所有权进行严格检
  查, 所以才会出现解引用空指针的运行时错误 segmentation fault. 而在 Rust 中, 所
  有权是系统性的概念, 是 Rust 语言中的基础设施. Rust 中的每个值都必定有一个唯一
  的控制者(即所有者). 所有权的转移都是按系统性的规则隐式地自动完成的.

  Rust 的所有权系统与法律上 "定分止争" 的思想不谋而合的. 所有权系统让每个值都有
  了明确的权属界限, 它们的行为也有了明确的权属界限, 这样内存安全就有了基本的保障.
  如果说所有权系统是内存管理的 "法律", 那么 Rust 编译器就是 "严格的执法者", 两者
  有机统一, 保障了内存安全. 如果代码中有违反所有权机制的行为, 编译器就会检查出来,
  让错误在编译期就无所遁形, 而不用等到运行时.
  
** 通用概念
   *内容有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/104][issue]]

   当前计算机内存栈和堆的分配机制, 决定了编程语言中的值主要是分为 2 类: *值类型
   (Value)* 和 *引用类型(Reference)*. 像 C, C++, Java, JavaScript, C# 等语言都明
   确对值类型和引用类型作了区别, 而一些纯面向对象语言只剩下了引用类型的概念, eg:
   Ruby 和 Python 中, 一切皆对象, 而对象就是引用类型.

   *值类型一般是指可以将数据都保存到同一位置的类型*, 一些原生类型, eg: 数值, 布
   尔值, 结构体等都是值类型. 因此 *对值类型的操作效率一般比较高*, 使用完立即会被
   回收. 值类型作为 *右值(在值表达式中)* 执行赋值操作时, 会 *自动复制* 一个新的
   值副本. 并且该副本和原始的值没有直接关系, 互不影响

   *引用类型则会存在一个指向实际存储区域的指针*. eg: 通常一些引用类型会将数据存
   储在栈中, 而栈中只存放指向堆中数据的地址(指针). 因此对引用类型的操作效率一般
   比较低, 使用完交给 GC 回收, 这样更安全一些. 但是没有 GC 的语言则需要靠手工来
   回收, 就多了很多风险.

   基本的原生类型, 结构体和枚举体都属于值类型. 普通引用类型, 原生之后怎类型等都
   属于引用类型. 但随着语言的发展, 类型越来越丰富, 值类型和引用类型已经难以描述
   完全部情况. 
   
   为了更加精准地对这种情况进行描述, *值语义(Value Semantic)* 和 *引用语义
   (Reference Semantic)* 被引入, 定义如下:

   - 值语义: 复制(赋值操作)以后, 两个数据对象拥有的存储空间是独立的, 相互之间互
     不影响
   - 引用语义: 复制(赋值操作)以后, 两个数据对象, 相互之间互为别名. 操作其中任意
     一个数据对象, 则会影响到另一个.

   值语义可以保证变量值的 *独立性* (Independence): 如果项修改某个变量, 只能通过
   它本身来修改; 而如果修改了它本身, 并不影响其复制品. 也就是说, 如果只能通过变
   量本身来修改值, 那么它就是具有值语义的变量.

   对于引用语义的数据对象, 赋值操作时按位复制, 可能存在内存不安全风险. eg: 只复
   制了栈上的指针, 堆上的数据就多了一个管理者, 多了一层内存安全的隐患.

   按位复制: 只是复制 *值*, 而不会复制 *值中所包含指针指向的数据*. 也可以说, 它
   是浅复制的一种特定形式. 它不会进行深复制. eg: Rust 中的 String 字符串来说, 其
   本质是一个智能指针, 在栈上存储着元信息, 但是在堆里存储的具体的数据. 若对齐进
   行按位复制, 只会复制其栈上的元信息, 而不会复制其堆里的数据. 如果想深复制, 只
   能显式地调用其 clone 函数.

   对于整数类型, 当它作为右值赋给新的变量时, 编译器会默认自动调用 clone 方法进行
   *按位复制*. 被复制以后, 就是两个不同的值, *互不影响*.

   这是因为整数类型实现了 Copy trait, 对于实现 Copy 的类型, 其 clone 方法必须是
   按位复制的. 对于拥有值语义的整数类型, 整个数据存储于栈中, 按位复制以后, 不会
   对原有数据造成破坏, 不存在内存安全的问题.

   反观 C++, 当对象作为右值参与赋值的时候, 一般会建议开发者自定义实现复制构造函
   数, 但开发者很有可能忘记这样做, 那么这种情况下, 编译器就会默认实现复制构造函
   数来进行按位复制, 就会出现悬垂指针的内存安全问题, 解决的办法是自定义深复制构
   造函数, 将堆上的数据也复制一遍. 而 Rust 通过 Copy 这个标记 trait, 将类型 *按
   值语义和引用语义做了精准的分类*, 帮助编译器检测出潜在的内存安全问题.

   智能指针 ~Box<T>~ 封装了原生指针, 是典型的引用类型. ~Box<T>~ 无法实现 Copy,
   意味着它被 Rust 标记为了引用语义, *禁止实现按位复制*.

   值得注意的是, 虽然引用语义类型不能实现 Copy, 但可以实现 Clone 的 clone 方法,
   以实现深复制, 在需要的时候可以显式调用.
   
** 所有权机制
   *有改动*: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/104][issue]]

   在 Rust 中, 由 Copy trait 来区分只语义和引用语义. 但为了描述的更加精准, Rust
   也引入了新的语义: *复制(Copy)* 和 *移动(Move)* 语义. 复制语义对应值语义, 也就
   是说, 实现了 Copy 的类型, 在进行按位复制的时候, 是安全的. 移动语义对应引用语
   义. 复制语义对应值语义, 也就是说, 在传统语言(eg: C++)中本来是引用语义的类型,
   在 Rust 中不允许按位复制, 只允许移动所有权, 只有这样才能保证安全. 这样划分是
   因为引入了所有权机制, 在所有权机制下同时保证内存安全和性能. Rust 的数据默认存
   储在栈上.

   对于默认可以安全地在栈上进行按位复制的类型, 就只需要按位复制, 也方便管理内存.
   对于默认只可在堆上存储的数据, 因为无法安全地进行按位复制, 如果要保证内存安全,
   就 *必须进行深度复制*. 当然, 也可以把实现 Copy 的类型, 通过 Rust 提供的特定
   API (eg: Box 语法) 将其放到堆上, 但它既然是实现了 Copy, 就是可以安全进行按位
   复制的类型. 深度复制需要在堆内存中重新开辟空间, 这会带来更多的性能开销. 如果
   堆上的数据不变, 只需在栈上移动堆内存的指针地址, 不仅保证了内存安全, 还可以拥
   有在栈上进行复制的等同性能.

   所以, 对于 Rust 而言, 可以实现 Copy trait 的类型, 则表示它拥有复制语义, 在赋
   值或传入函数等行为时, 默认会进行按位复制. 它和传统概念中的值语义类型相对应,
   因为两个独立不关联的值, 操作其中一个, 不影响另外一个, 是安全的. 对于不能实现
   Copy trait 的类型, 它实际上和传统的引用语义类型相对应, 只不过在 Rust 中, 如果
   只是简单地按位复制, 则会出现悬垂指针问题. 所以, 为了安全, 它必须是移动语义.
   移动语义实际上在告诉编译器, 该类型不要简单的按位复制, 那样不安全. 所以, 其他
   语言中的引用语义到了 Rust 中, 就成了移动语义. 但是被移动的值, *相当于已经废
   弃* 了, 无法使用. 如果从这个角度看, 如果认为 Rust 语言中并不存在引用语义类型,
   只有值语义类型, 也是可以的. 另外, 需要注意: RUst 中 *默认的引用和指针也都实现
   了 Copy*. 

   *一个值的所有权被转移给另外一个变量绑定的过程, 就叫做所有权转移*.

   Rust 中每个值都有一个所有者, 更进一步说就是: Rust 中分配的每块内存都有其所有
   者, 所有者负责该内存的释放和读写权限, 并且每次每个值只能有唯一的所有者. 这就
   是 Rust 的 *所有权机制(OwnerShip)*.

*** 所有权的类型系统理论
    Rust 的所有权在类型系统理论中称为 *仿射类型(affine type)*, 它属于类型理论中
    *子结构类型系统(Substructural Type System)* 的概念. 子结构类型系统又是 *子结
    构逻辑(Substructural Logic)* 在类型系统中的应用. 而子结构逻辑属于证明理论里
    的推理规则, 其规则包含如下几点:

    - 线性逻辑(Linear Logic), 如果包含每个变量符合某种特定的 "结构", 它就内涵一
      种规则: *必须且只能使用一次*.
    - 仿射逻辑(Affine Logic), 和线性逻辑是类似地, 但它的规则是: *最多使用一次*.
      看上去线性逻辑更严格一些
    - 其他数据
      
    子结构逻辑规则则用于推理. 基于仿射类型, Rust 实现了所有权机制, 在需要移动的
    时候自己移动, 维护了内存安全.  

*** 所有权的特点
    所有者拥有以下三种权限:
    - 控制资源(不仅仅是内存)的释放
    - 出借所有权, 博阿含不可变(共享)和可变(独占)的
    - 转移所有权

    对于实现 Copy 的类型, 也就是复制语义类型来说, 按位复制并不会出现内存问题, 并
    且可以简化内存管理. 所以在赋值操作时, 作为右值的变量会默认进行按位复制. 但是
    对于禁止实现 Copy 的类型, 依旧是移动语义类型来说, 如果对其执行按位复制, 就会
    出现悬垂指针问题, 所以在进行赋值操作时, 作为右值的变量会默认执行移动语义来转
    移所有权, 从而保证了内存安全.

    对于可以实现 Copy 的复制语义类型来说, 所有权并未改变. 对于符合类型来说, 是复
    制还是移动, 取决于其成员的类型.

    枚举体和结构体是类似的, 当成员均为复制语义类型时, 不会自动实现 Copy. 而对于
    *元组类型* 来说, 其本身实现了 Copy, 如果元素均为复制语义类型, 则默认是按位复
    制的, 否则会执行移动语义.

    数组, Option 类型与元组类型都遵循这样的规则: 如果元组都是复制语义类型, 也就
    是都实现了 Copy, 那么它们就可以按位复制, 否则就转移所有权.
