* 构建健壮的程序
  健壮性又叫鲁棒性(Robust). 是一个跨领域的术语, 在建筑、机械、控制、经济和计算机
  领域均意味着系统的容错和恢复能力.

  纵观软件开发的历史, 为了保证软件的健壮性, 各门语言所用的办法各有特色, 但总归可
  以分为两大类: *返回错误值* 和 *异常*.

  eg: 在 C 语言中, 并不存在专门的异常处理机制, 卡覅在只能通过返回值、goto、
  setjump、assert 断言等方式来处理程序中发生的错误， 这些方式的优点是比较灵活，
  但是缺点更多:

  1. 这种错误并不是强制性检查的, 很容易被开发者疏忽而进一步引起更多的问题, 成为
     Bug 的温床
  2. 可读性差, 错误处理代码和正常的功能代码交织在一起, 有可能会让正常逻辑陷入混
     乱中, 有人称之为 "错误地狱".

  随着 C++、Java 等高级语言的发展, 引入了语言级别的异常处理机制, 才让开发者摆脱
  了 "错误地狱". 异常处理机制利用 *栈回退(Stack Unwind)* 或 *栈回溯(Stack
  Backtrack)* 机制, 自动处理异常, 解放了开发者. 异常处理的优点是它是全局且独立的,
  不需要所有的函数都考虑捕获异常, 并且用专门的语法将异常处理逻辑和正常的功能逻辑
  清晰地分离开来. 但是异常处理并不完美. 首先, 异常处理的开销比较大, 尤其是在抛出
  异常时; 其次, 异常处理包含的信息太多, 对于开发者来说, 如何优雅高效地进行异常处
  理, 又成为另一个难题.

  Rust 作为一门现代安全的系统级编程语言, 如何构建健壮的程序是其必然要解决的问题
  之一, 而工程性、安全性和性能是其必须要考虑的三重标准.

** 通用概念
   在编程中遇到的非正常情况, 大概可以分为三类: *失败(Failure)*, *错误(Error)* 和
   *异常(Exception)*.

   *失败* 是指违反了 "契约" 的行为. 此处的 "契约" 用来表示满足程序正确运行的前提
   条件. eg: 一个函数在定义时规定必须传入某种类型的参数和返回某种类型的值, 这就
   创建了一个契约, 在调用该函数时, 需要满足此 "契约" 才是程序正确运行的前提条件.

   *错误* 是指可能出现问题的地方出现了问题. eg: 建立一个 HTTP 连接时超时, 打开一
   个不存在的文件或查询某些数据返回了空. 这些都是完全在意料之中, 并且有办法解决
   的问题. 而且这些问题通常都和具体的业务相关联.

   *异常* 是指完全不可预料的问题. eg: 引入了空指针、访问了越界数组、除数为 0 等
   行为. 这些问题都是非业务相关的.

   很多支持异常处理的语言, eg: C++/Java/Python 或 Ruby 等, 并没有对上述三种情况
   做出语言级的区分. 这就导致很多开发者在处理异常时把一切非正常情况都当做异常来
   处理, 甚至把异常处理当做控制流程来使用. 把一切非正常情况都当做异常来处理, 不
   利于管理. 在开发中很多错误需要在第一时间就暴露出来, 才不至于传播到生产环境进
   一步造成危害. 有些开发者虽然对异常的三种情况做出了不同的处理, eg: 对错误使用
   返回值的形式来处理、对真正的异常使用异常机制来处理, 但是却并没有形成统一的标
   准; 社区里只有最佳实践在口口相传, 但并非强制性执行.

   现代编程语言 Go 在语言层面上区分了异常(Panic)和错误, 但是带来了巨大的争议. 在
   Go 语言中错误处理是强制性的, 开发人员必须显式地处理错误, 这就导致 Go 语言代码
   变得相当冗长, 因为每次函数调用都需要 if 语句来判断是否出现问题. Go 语言错误处
   理的理念很好, 但是具体实现却差强人意. Rust 语言也区分了异常和错误, 相比于 Go
   语言, Rust 的错误处理机制就显得非常优雅.

** 消除失败
   Rust 使用以下两种机制来消除失败:
   - 强大的类型系统
   - 断言

   Rust 是类型安全的语言, 一切皆类型. Rust 中的函数签名都显式地指定了类型, 通过
   编译器的类型检查, 就完全可以消除函数调用违反 "契约" 的情况.

   仅仅依赖编译器的类型检查还不足以消除大部分失败, 有些失败发生在运行时. eg:
   ~Vector~ 数组提供了 ~insert()~ 方法, 插入错误的位置会出错.

   以上情况通过类型检查是无法判断的, 因为无法预先知道开发者会指定声明索引. 这时
   就需要使用 *断言(Assert)*. RUst 标准库中一共提供了以下六个常用的断言:
   
   - ~assert!~: 用于断言布尔表达式在运行时一定返回 true.
   - ~assert_eq!~: 用于断言两个表达式是否相等(使用 ~PartialEq~).
   - ~assert_ne!~: 用于断言两个表达式是否不相等(使用 ~PartialEq~).
   - ~debug_assert!~: 等价于 ~assert!~, 只能用于调试模式.
   - ~debug_assert_eq!~: 等价于 ~assert_eq!~, 只能用于调试模式
   - ~debug_assert_ne!~, 等价于 ~assert_ne!~, 只能用于调试模式

   以上六个断言都是宏. ~assert~ 系列宏在调试(Debug)和发布(Release)模式下均可用,
   并且不能被禁用. ~debug_assert~ 系列宏只在调试模式下起作用. 在使用断言时, 要注
   意具体的场合是否一定需要 ~assert~ 系列宏, 因为断言的性能开销不可忽略, 尽量使
   用 ~debug_assert~ 系列宏.

   在 ~insert()~ 方法中使用 ~assert!~ 断言
   #+begin_src rust
     #[stable(feature = "rust1", since = "1.0.0")]
     pub fn insert(&mut self, index: usize, element: T) {
         let len = self.len();
         if index > len {
             // 超过直接引发线程恐慌
             assert_failed(index, len);
         }
         // ...
     }
   #+end_src

   引发线程恐慌不算消除失败, 是一种 *快速失败(Fast Fail)* 的策略, 这样做可以让开
   发中的错误尽早地暴露出来, 使得 Bug 无处藏身. 所以 ~assert~ 系列宏也支持自定义
   错误消息.

   综上所述, 通过断言可以对函数进行契约式的约束. 所谓 "契约" 就是指可以确保程序
   正常运行的条件, 一旦 "契约" 被毁, 就意味着程序出了 Bug. 程序运行的条件大概可
   以分为以下三类:

   - *前置条件*: 代码只需之前必须具备的特性
   - *后置条件*: 代码只需之后必须具体的特性
   - *前后不变*: 代码只需前后不能变化的特性

   在日常开发中, 如果必要的话, 则可以依据这三类情况来设置断言.

   除断言之外, 还可以直接通过 ~panic!~ 宏来制造线程恐慌, 其实在 ~assert~ 系列宏
   内部也使用了 ~panic!~ 宏. 那么什么时候使用呢? 其实还是遵循快速失败的原则, 在
   处理某些在运行时决不允许或绝不可能的情况时, 可以使用 ~panic!~ 宏.
   
