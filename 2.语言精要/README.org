* 语言精要
** Rust 语言的基本构成
   Rust 语言主要由以下几个核心部件组成:
   - 语言规范
   - 编译器
   - 核心库
   - 标准库
   - 包管理器

*** 语言规范
    Rust 语言规范主要由 Rust 语言参考(The Rust Reference) 和 RFC 文档共同构成
    
**** Rust 语言参考
     Rust 语言参考是官方团队维护的一份参考文档, 包含了三类内容:

     - 对每种语言结构及其用法的描述
     - 对内存模型, 并发模型, 链接, 调试等内存的描述
     - 影响语言设计的基本原理和参考

     该参考文档不算 Rust 语言的正式规范, 但目前官方只有这么一份最接近规范的文档,
     在不就得将来, Rust 官方会出一份正式的文档.  

**** RFC 文档
     Rust 引入了 规范化的 RFC 流程, RFC 文档是涵盖了语言特性的设计意图, 详细设计,
     优缺点的完成技术方案. 社区中的每个人都可以提 RFC, 经过社区讨论, 核心开发团
     队评审, 通过之后才能进入具体实现阶段.

     Rust 源码中也规范德使用了 RFC 编号, 来对应相应的功能特性. 使用 RFC 的好处是,
     形成了规范化的文档, 利于方案实施和后期维护, 利于核心开发组主导项目进展方向.
     Rust 学习者也可以通过 RFC 来深入了解某个语言特性的来龙去脉.

*** 编译器
    Rust 是一门静态编译型语言. Rust 官方的编译器叫 *rustc*, 负责将 Rust 源代码编
    译为可执行文件或其他库文件(.a, .so, .lib, .dll 等).

    rustc 有如下特点:
    - rustc 是跨平台的应用程序, 支持 UNIX/Linux 等 UNIX 平台, 也支持 Windows 平
      台.
    - rustc 支持交叉编译, 可以在当前平台下输出可运行于其他平台上的应用程序和库.
    - rustc 使用 LLVM 作为编译器后端, 具有很好的代码生成和优化技术, 支持多个目标
      平台
    - rustc 是用 Rust 语言开发的, 包含在 Rust 语言源码中
    - rustc 对 Rust 源码进行词法语法分析, 静态类型检查, 最终将代码翻译为 LLVM IR.
    - rustc 输出的错误信息非常友好和详尽, 是开发者的良师益友.

*** 核心库
    Rust 语言的语法由核心库和标准库共同提供. 其中 Rust 核心库是标准库的基础. 核
    心库中定义的是 Rust 语言的核心, 不依赖于操作系统和网络相关的库, 甚至不知道堆
    分配, 也不提供并发和 I/O.

    可以通过在模块顶部引入 ~#![no_std]~ 来使用核心库. 核心库和标准库的功能有一些
    重复, 包括如下部分:

    - 基础的 trait, 如 Copy, Debug, Display, Option 等
    - 基本原始类型, 如 bool, char, i8/u8, i16/u16, i32/u32, i64/u64,
      isize/usize, f32/f64, str, array, slice, tuple, pointer 等
    - 常用功能型数据类型, 满足常见的功能性需求, 如 String, Vec, HashMap, Rc,
      Arc, Box 等
    - 常用的宏定义, 如 println!, assert!, panic!, vec! 等

    做嵌入式应用开发的时候, 核心库是必须的

*** 标准库
    Rust 标准库提供应用程序开发所需要的基础和跨平台支持. 标准库包含的内容大概如
    下:

    - 与核心库一样的基本 trait, 原始数据类型, 功能型数据类型和常用宏等, 以及与核
      心库几乎完全一致的 API.
    - 并发, I/O 运行时. eg: 线程模块, 用于消息传递的通道类型, Sync trait 等并发
      模块, 文件, TCP, UDP, 关到, 套接字等常见 I/O.
    - 平台抽象. os 模块提供了许多与操作系统环境交互的基本功能, 包括程序参数, 环
      境变量和目录导航; 路径模块很赚了处理文件路径的平台特定规则.
    - 底层操作接口, eg: ~std::mem~, ~std::ptr~, ~std::intrinsics~ 等, 操作内存,
      指针, 调用编译器固有函数.
    - 可选和错误处理类型 Option 和 Result, 以及各种迭代器等.

*** 包管理器
    把按一定规则组织的多个 rs 文件变异后就得到一个 *包(crate)*. 包是 Rust 代码的
    基本编译单元, 也是程序员之间共享代码的基本单元.

    Rust 社区的公开电饭煲都集中在 crates.io 网站上面, 它们的文档被自动发布到
    docs.rs 网站上.

** 语句与表达式
   Rust 中的语法可以分成两大类: *语句(Statement)* 和 *表达式(Expression)*. 语句
   是指要执行的一些操作和产生副作用的表达式. 表达式主要用于计算求值.

   语句又分两种: *声明语句(Declaration statement)* 和 *表达式语句(Expression
   statement)*.
   
   - 声明语句: 用于声明各种语言项(item), 包括生命变量, 今天变量, 常量, 结构体,
     函数等, 以及通过 extern 和 use 关键字引入包和模块等.
   - 表达式语句, 特指以分号结尾的表达式. 此类表达式求值结果将被舍弃, 并总是返回
     单元类型().

     #+begin_src rust
       // extern crate std;
       // use std::prelude::v1::*;

       fn main() {
           pub fn answer() -> () {
               let a = 40;
               let b = 2;
               assert_eq!(sum(a, b), 42);
           }

           pub fn sum(a: i32, b: i32) -> i32 {
               a + b
           }

           answer();
       }
     #+end_src
     第 1 和第 2 行为声明语句, 它们并不需要求值, 只是用来引入标准包及模块. 这里
     注释掉是因为 Rust 会为每个 crate 都自动引入标准库模块, 除非使用 ~#[no_std]~
     属性明确指定了不需要标准库.

     然后使用 fn 关键字定义了 2 个函数 answer 和 sum. 关键字 fn 是 function 的缩
     写.

     函数 answer 没有输入参数, 并且返回值为 *单元类型()*. 单元类型拥有唯一的值,
     就是它本身, 为了描述方便, 将该值称为 *单元值*. 单元类型的概念来自 OCmal, 它
     表示 [没有什么特殊的价值]. 所以, 这里将单元类型作为函数返回值, 就表示该函数
     无返回值. 当然, 通常无返回值的函数默认不需要在函数签名中指定返回类型.

     在函数 answer 中, 使用 let 声明了 2 个变量 a, b, 其后必须加分号.
     ~assert_eq!~ 则是宏语句, 它是 Rust 提供的断言, 允许判断给定的两个表达式求值
     结果是否相同. 以叹号结尾, 并且可以像函数一样被调用的语句, 在 Rust 中叫做 *
     宏*.

     Rust 编译器在解析代码的时候, 如果碰到 *分号, 就会继续往后面执行;* 如果碰到
     语句, 则 *执行语句*; 如果碰到表达式, 则会 *对表达式求值*, 如果分号后面什么
     都没有, *就会补上单元值()*.

     当遇到函数的时候, 会将函数体的花括号识别为 *块表达式(Block Expression)*. 块
     表达式是由一对花括号和一系列表达式组成的, 它 *总是返回块中最后一个表达式的
     值*. 

     从这个角度来看, 可以将 Rust 看作一切皆表达式. 由于当分号后面什么都没有时自
     动补单元值() 的特点, 我们可以将 Rust 中的语句看作计算结果均为 () 的特殊表达
     式. 而对于普通的表达式来说, 则会得到正常的求值结果.
** 变量与绑定
   通过 let 关键字来创建变量, 这是 Rust 语言从函数式语言中借鉴的语法形式. let 创
   建的变量一般称为 *绑定(Binding)*, 它表明了标识符(Identifier) 和值(Value) 之间
   建立的一种关联关系.

*** 位置表达式和值表达式
    Rust 中的表达式一般可以分为 *位置表达式(Place Expression)* 和 *值表达式
    (Value Expression)*. 在其他语言中, 一般叫做左值(LValue) 和 右值(RValue).

    顾名思义, 位置表达式就是表示内存位置的表达式. 分别有以下几类:
    - 本地变量
    - 静态变量
    - 解引用 (*expr)
    - 数组索引
    - 字段引用(expr.field)
    - 位置表达式组合

    通过位置表达式可以对某个数据单元的内存进行读写. 主要是进行写操作, 这也是位置
    表达式可以被赋值的原因.

    除此之外的表达式就是值表达式. 值表达式一般只引用了某个存储单元地址中的数据.它
    相当于数据值, 只能进行读操作.

    *从语义角度来说, 位置表达式代表了持久性数据, 值表达式代表了临时数据*. 位置表
    达式一般有持久的状态, 值表达式要么是字面量, 要么是值表达式过程中创建的临时值.

    表达式的求值过程在不同的上下文中会有不同的结果. 求值上下文也分为 *位置上下
    文* (Place Context) 和 *值上下文(Value Context)*. 下面几种表达式属于位置上下
    文:

    - 赋值或者复合赋值语句左侧的操作数.
    - 一元引用表达式的独立操作数
    - 包含隐式借用(引用)的操作数
    - match 判别式或 let 绑定右侧在使用 ref 模式匹配的时候也是位置上下文.

    除了上述几种情况, 其余表达式都属于值上下文. *值表达式不能出现在位置上下文中*.
    #+begin_src rust
      pub fn temp() -> i32 {
          return 1;
      }

      fn main() {
          let x = &temp();
          // error[E0070]: invalid left-hand side expression
          temp() = *x;
      }
    #+end_src

    temp 函数调用是一个无效的位置表达式, 它是值表达式.

*** 不可变绑定与可变绑定
    使用 let 关键字声明的位置表达式 *默认不可变, 为不可变绑定*.
    
    从语义上来说, let 默认声明的不可变绑定只能对相应的存储单元进行读取, 而 let
    mut 声明的可变绑定则是可以对象相应的存储单元进行写入的.

*** 所有权与引用
    当位置表达式出现在值上下文中时, 该位置变道时将会把内存地址转移给另外一个位置
    表达式, 这其实是所有权的转移.

    在日常开发中, 有使用并不需要转移所有权. Rust 提供 *引用操作符(&)*, 可以直接
    获取表达式的存储单元地址, 即内存位置.

*** 值表达式在位置上下文中求值时会被创建临时值
    编译器为 ~let e = &42~ 创建临时值的示意代码:
    #+begin_src rust
      let mut _0: &i32;
      let mut _1: i32;
      _1 = const 42i32;
      _0 = &1;
    #+end_src

    从语义上来说, 不管是 ~&a~ 还是 ~&mut c~, 都相当于对 a 和 c 所有权的借用, 因
    为 a 和 c 还 *依旧保留它们的所有权*, 所以引用也被称为借用.

** 函数与闭包
   *main 函数*: 代表程序的入口. 对于二进制可执行文件来说, main 函数必不可少. 对
   于库函数来说, main 函数就没那么重要了

*** 函数定义
    函数是通过关键字 *fn* 定义的.

*** 作用域与生命周期
    *Rust 语言的作用域是静态作用域, 即此法作用域(Lexical Scope)*. 由一对花括号来
    开辟作用域, 其作用域在此法分析阶段就已经确定了, 不会动态改变.

    连续使用 let 定义同名变量的做法叫 *变量遮蔽(Varaible Shadow)*. 但是最终的变
    量的值由新定义所决定.

    在词法作用域内部使用花括号开辟新的词法作用域后, 两个作用域是相互独立的. 在不
    同的词法作用域内声明的变量绑定, 拥有不同的 *生命周期(LifeTime)*. 尽管如此,
    变量绑定的生命周期总是遵循这样的规律: *从使用 let 声明创建变量绑定开始*, *到
    超出词法作用域的范围时结束*.

*** 函数指针
    在 Rust 中, *函数为一等公民*. 这意味着, 函数自身就可以作为函数的参数和返回值
    使用.

    形如 ~fn(i32, i32) -> i32~ 类型在 Rust 中是 *函数指针(fn pointer)* 类型

*** CTFE 机制
    Rust 编译器也可以像 C++ 或者 D 语言那样, 拥有 *编译时函数执行* (Compile-Time
    Function Execution, CTFE) 的能力. 在 Rust 2018 版本的首个语义化版本 1.30 中,
    CTFE 的一个最小化子集已经稳定了.

    Rust 中固定长度的数组必须在编译期就知道长度, 否则编译出错. 使用 ~const fn~
    定义的函数, 必须可以确定值, 不能存在歧义, ~const fn~ 函数可以强制编译器在编
    译期执行函数. 其中关键字 ~const~ 一般用于定义全局常量.

    *Rust 中的 CTFE 是由 miri 来执行的*. miri 是一个 MIR 解释器, 目前已经被集成
    到了 Rust 编译器 rustc 中. Rust 编译器目前可以支持的常量表达式有: 字面量, 元
    组, 数组, 字段结构体, 枚举, 只包含单行代码的块表达式, 范围等. Rust 想要拥有
    完善的 CTFE 支持, 还有很多工作要做

*** 闭包
    闭包也叫匿名函数. 闭包有以下几个特点:
    - 可以像函数一样被调用.
    - 可以捕获上下文环境中的自由变量
    - 可以自动推断输入和返回的类型.

    闭包调用和函数调用非常像, 但是闭包和函数有一个重要的区别, 那就是 *闭包可以捕
    获外部变量, 而函数不可以*. 

    闭包也可以作为函数参数和返回值.

    *Rust 中闭包实际上就是由一个匿名结构体和 trait 来组合实现的*. 所以, 在 main
    函数调用 math 函数的时候, 分别传入 ~|| a + b~ 和 ~|| a * b~ 这两个闭包, 都实
    现了 ~Fn() -> i32~. 在 math 函数内部, 通过在后面添加一对圆括号来调用传入的闭
    包.

    一般情况下, *闭包默认会按引用捕获变量*. 如果将此闭包返回, 则引用也会跟着返回,
    但是在整个函数调用完毕之后, 函数内的本地变量 i 就会被销毁. 那么随闭包返回的
    变量 i 的引用, 也将成为悬垂指针. Rust 是注重内存安全的语言, 绝对不允许, 编译
    器会报错. 使用 move 将捕获变量 i 的所有权转移到闭包中, 就不会按引用进行捕获
    变量, 这样闭包才可以安全地返回.

    
