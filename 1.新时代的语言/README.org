* 新时代的语言  
** 内存安全
   一般来说, 一门语言只要保证类型安全, 就可以说它是一门安全的语言. 简单来说, 类
   型安全是指类型系统可以保证程序的行为是意义明确, 不出错的.

   *Rust 语言如果想保证内存安全, 首先要做的就是保证类型安全*.

   Rust 语言建立了严格的安全内存管理模型:
   - *所有权系统*:
     每个被分配的内存都有一个独占其所有权的指针. 只有当该指针被销毁时, 其对应的
     内存才能随之被释放.

   - *借用和生命周期*:
     每个变量都有其生命周期, 一旦超出生命周期, 变量就会被自动释放. 如果是借用,
     则可以通过标记生命周期参数供编译器检查的方式, 防止出现悬垂指针, 也就是是释
     放后的情况.

   从 Haskell 的类型系统那里借鉴了以下特性:
   - 没有空指针
   - 默认不可变
   - 表达式
   - 高阶函数
   - 代数数据类型
   - 模式匹配
   - 泛型
   - trait 和关联类型
   - 本地类型推导

   为了实现内存安全, 还具备以下独有的特性:
   - 仿射类型(Affine Type), 该类型用来表达 Rust 所有权中的 Move 语义
   - 借用, 生命周期

** 实用性
*** 实践性
    为了保证安全性, Rust 引入了强大的类型系统和所有权系统, 不仅保证内存安全, 还
    保证了并发安全, 同时还不会牺牲性能.

    为了保证支持硬实时系统, Rust 从 C++ 那里借鉴了确定性析构, RAII 和智能指针,
    用于自动化地, 确定性地管理内存, 从而避免了 GC 的引入.

    为了保证程序的健壮性, Rust 重新审视了错误处理机制.

    Rust 针对失败, 错误和异常这三类情况分别提供了专门的处理方式:
    - 对于失败的情况, 可以使用断言工具
    - 对于错误, Rust 提供了基于返回值的分层错误处理方式, 比如 ~Option<T>~ 可以用
      来处理可能存在空值得情况, 而 ~Result<T>~ 就专门用来处理可以被合理解决并需
      要传播的错误.
    - 对于异常, Rust 将其看作无法被合理解决的问题, 提供了线程恐慌机制, 在发生异
      常的时候, 线程可以安全地退出.

** 语言架构
   Rust 语言概念可以分为 4 个层次:
   #+begin_src text

     开发者 ---  混合编程范式: 面向对象, 函数式
     开发者 ---  语义: 所有权, MOVE, COPY, 借用, 生命周期, DROP   --- 编译器
     开发者 ---  类型系统: 泛型, Trait, 一切皆类型, 多态, 类型推断  --- 编译器
                安全内存管理: 栈, RAII, 堆                       --- 编译器

   #+end_src
   - 最底层的是安全内存管理层, 该层主要是涉及内存管理相关的概念
   - 倒数第二层是类型系统层, 该层起到了承上启下的作用. 类型系统层承载了上层的所
     有权系统语义和混合编程范式, 赋予了 Rust 语言高级的抽象表达能力和安全性. 同
     时, 还保留了对底层代码执行, 数据表示和内存分配等操作的控制能力.

   对于开发者而言, 只需要掌握类型系统, 所有权系统和混合式编程范式即可, 不需要操
   心底层的内存是否安全, 因为有编译器和类型系统帮忙处理. 在这个语言架构之下, 人
   和编译器共用同一套[心智模型], 这样可以极大地保证系统的安全和健壮性

** Rust 代码如何执行
   Rust 是跨平台语言, 一次编译, 到处运行, 这得益于 LLVM. Rust 编译器是一个 LLVM
   编译前端, 它将代码编译为 LLVM IR, 然后经过 LLVM 编译为相应地平台目标.

   Rust 源码经过分词和解析, 生成 AST(抽象语法树). 然后把 AST 进一步简化处理为
   HIR(High-level IR), 目的是让编译器更方便地做类型检查. HIR 会进一步被编译为
   MIR(Middle IR), 这是一种中间表示, 它在 Rust 1.12 版本中被引入, 主要用于以下目
   的:

   - *缩短编译时间*. MIR 可以帮助实现增量编译, 当你修改完代码重新编译的时候, 编
     译器只计算更改过的部分, 从而缩短了编译时间.

   - *缩短执行时间*. MIR 可以在 LLVM 编译之前实现更细粒度的优化, 因为单纯依赖
     LLVM 的优化粒度太粗, 而且 Rust 无法控制, 引入 MIR 就增加了更多的优化空间.

   - *更精确的类型检查*. MIR 将帮助实现更灵活的借用检查, 从而可以提升 Rust 的使
     用体验.

   最终, MIR 会被翻译为 LLVM IR, 然后被 LLVM 的处理编译为能在各个平台上运行的目
   标机器码.
