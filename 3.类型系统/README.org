* 类型系统
  本性决定行为, 本性取决于行为.

** 通用概念
   *类型是对表示信息的值进行细粒度的区分*. eg: 整数, 小数, 文本等.

   不同的类型占用的内存不同. 与直接操作比特位相比, 直接操作类型可以更安全, 更有
   效地利用利用内存.(eg: Rust 自动分配 4 个字节存储 u32 类型的值)

   计算机除了存储信息外, 还需要处理信息. 这就必然会面临一个问题: 不同类型的值计
   算问题. 类型之间的纷繁复杂的交互形成了类型系统, *是编程语言的基础和核心*, 因
   为编程语言的目的就是存储和处理信息. 不同编程语言之间的区别就在于如何存储和处
   理信息.

   在计算机科学中, 类型系统是最轻量, 最完善的一种方式. 
   在类型系统中, *一切皆类型*. 基于类型定义的一系列组合, 运算和转换等方法, 可以
   看做类型的 *行为*. 类型的行为决定了类型该如何计算, 同时也是一种约束, 有了这种
   约束才可以保证信息被正确处理.

*** 类型系统的作用
    类型系统是一门编程语言不可或缺的部分, 有如下方面的优势:
    - *排查错误*: 很多编程语言都会载编译期或运行期进行类型检查, 以便排查违规行为,
      保证程序正确执行. 如果程序中有类型不一致的情况, 或有未定义的行为发生, 则可
      能导致错误的产生. 尤其对于静态语言来说, 能在编译期排查出错误是一个很大的优
      势, 这样可以尽早地处理问题, 而不必等到运行后崩溃了再解决

    - *抽象*: 类型允许开发者在更高层面进行思考, 这种抽象能力有助于强化编程规范和
      工程化系统. eg: OOP 语言中的类就可以作为一种类型.

    - *文档*: 在阅读代码的时候, 明确的类型声明可以表明程序的行为

    - *优化效率*: 这一点是针对静态编译语言来说的, 在编译期可以通过类型检查来优化
      一些操作, 节省运行时的时间

    - *类型安全*:
      + *类型安全的语言可以避免类型间的无效运算*
        eg: ~3/ "hello"~ 这种不符合算术规则的计算.

      + *类型安全的语言还可以保证内存安全*: 避免空指针, 悬垂指针和缓冲区溢出等导
        致的内存安全问题.

      + *类型安全的语言也可以避免语义上的逻辑错误*
        eg: 以 mm 为党委的数值和以 cm 为单位的数值都是以整数来存储的, 但是可以用
        不同的类型来区分, 避免逻辑错误

        
    尽管类型系统有诸多优点, 但并非所以肚饿编程语言都能 100% 拥有这些优点, 这与它
    们的类型系统的具体设计和实现有关.

*** 类型系统的分类
    在编译期进行类型检查的语言属于 *静态类型*, 在运行期进行类型检查的语言属于 
    *动态类型*. 如果一门语言不允许类型的自动隐式转换, 在强制转换前不同类型无法进
    行计算, 则该语言属于 *强类型*, 反之则属于 *弱类型*.

    *静态类型的语言能在编译期对代码进行静态分析, 依靠的就是类型系统*.
    eg: 越界数组. 有些静态语言, C 和 C++, 在编译期 *不检查* 数组是否越界访问, 运
    行时可能会得到难以意料的结果, 而程序依旧正常运行, 这属于类型系统中未定义的行
    为, 所以它们不是类型安全的语言. 而 *Rust 语言在编译期就能监察处数组是否越界
    访问*, 并给出警告, 让开发者及时修改, 如果开发者没有修改, 那么在运行时也会抛
    出错误并退出线程, 而不会因此去访问非法的内存, 从而保证了运行时的内存安全, 所
    以 *Rust 是类型安全的语言*. 强大的类型系统也可以对类型进行 *自动推导*, 因此
    一些静态语言在编写代码时候不用显式地指定具体的类型, eg: Haskell 就被称为隐式
    静态类型. Rust 语言的类型系统受 Haskell 启发, 也可以自动推导, 但不如 Haskell
    强大. 在 Rust 中大部分地方还是需要显式地指定类型, 类型是 Rust 语法的一部分,
    因此 *Rust 属于显示静态类型*.

    *动态类型的语言只能在运行时进行类型检查*, 但是当有数组越界访问时, 就会抛出异
    常, 执行线程退出操作, 而不是给出奇怪的结果. 所以一些动态语言也是类型安全的,
    eg: Ruby 和 Python. 在其他语言中作为基本类型的整数, 字符串, 布尔值等, 在
    Ruby 和 Python 语言中都是对象. 实际上, 也可将对象看做类型, Ruby 和 Python 语
    言在运行时通过一种名为 Duck Typing 的手段来进行运行时类型检查, 以保证类型安
    全. 在 Ruby 和 Python 语言中, 对象之间通过消息进行通信, 如果对象可以响应该消
    息, 则说明该对象就是正确的类型.

    对象是什么样的类型, 决定了它由什么样的行为; 反过来, 对象在不同上下文中的行为,
    也决定了它的类型. 这其实是一种 *多态性*.

*** 类型系统与多态性
    如果一个类型系统允许一段代码在不同的上下文中具有不同的类型, 这样的类型系统就
    叫做 *多态类型系统*. 对于静态类型的语言来说, 多态性的好处是可以在不影响类型
    丰富的前提下, 为不同的类型编写通用的代码.

    现代编程语言包含了三种多态形式: *参数化多态(Parametric polymorphism)*,
    *Ad-hoc多态(Ad-hoc polymorphism)* 和 *子类型多态(Subtype polymorphism)*. 如
    果按多态发生的时间来划分, 又可分为 *静多态(Static polymorphism)* 和 *动多态
    (Dynamic Polymorphism)*. 静多态发生在编译期, 动多态发生在运行时. 参数化多态
    和 Ad-hoc 多态一般是静多态, 子类型多态一般是动多态. 静多态牺牲灵活性获取性能,
    动多态牺牲性能获取灵活性. 动多态在运行时需要查表, 占用较多空间, 所以一般情况
    下都使用静多态. Rust 语言同时支持静多态和动多态, 静多态是一种 0 成本抽象.

    *参数化多态实际就是指泛型*. 很多时候函数或数据类型都需要适用于多种类型, 以避
    免大量的重复性工作. 泛型使得语言极具表达力, 同时也能保证静态类型安全.

    *Ad-hoc 多态也叫特定多态*. Ad-hoc 短语源自拉丁语系, 用于表示一种特定情况.
    *Ad-hoc多态是指同一种行为定义, 在不同的上下文中会响应不同的行为实现*.
    Haskell 语言中使用 Typeclass 来支持 Ad-hoc 多态, Rust 受 Haskell 启发, 使用
    trait 来支持 Ad-hoc 多态. 所以, Rust 的 trait 系统的概念类似于 Haskell 中的
    Typeclass.

    子类型多态的概念一般用在 OOP 语言中, 尤其是 Java 语言. Java 语言中的多态就是
    子类型多态, 它代表一种包含关系, 父类型的值包含了子类型的值, 所以子类型的值有
    时也可以看做父类型的值, 反之则不然. 而 Rust 语言中没有类似 Java 中的集成的概
    念, 所以也不存在子类型多态. 

    所以, *Rust 中的类型系统目前只支持参数化多态和 Ad-hoc 多态*, 也就是: *泛型*
    和 *trait*.

** Rust 类型系统概述
   Rust 是一门强类型且类型安全的静态语言. Rust 中一切皆表达式, 表达式皆有值, 值
   皆有类型. 所以可以说, *Rust 中一切皆类型*.

   除了一些基本的原生类型和符合类型, Rust 把作用域也纳入了类型系统, 这就是第 4
   章要学的生命周期标记. 还有一些表达式, 有时有返回值, 有时没有返回值(也就是只返
   回单元值), 或者有时返回正确的值, 有时返回错误的值, Rust 将这类情况也纳入了类
   型系统, 也就是 ~Option<T>~ 和 ~Result<T, E>~ 这样的可选类型, 从而强制开发人员
   必须分别处理这两种情况. 一些根本无法返回的情况: eg: 线程崩溃, break 或
   continue 等行为, 也都被纳入了类型系统, 这种类型叫做 never 类型. 可以说, Rust
   的类型系统基本囊括了编程中会遇到的各种情况, 一般情况下不会有未定义的行为出现,
   所以说, Rust 是类型安全的语言.

*** 类型大小
    编程语言中不同的类型本质上是内存占用空间和编码方式的不同, Rust 也不例外.
    Rust 中没有 GC, 内存首先由编译器来分配, Rust 代码被编译为 LLVM IR, 其中携带
    了内存分配的信息. 所以 *编译器需要事先知道类型的大小, 才能分配合理的内存*.

    
**** 可确定大小类型和动态大小类型
     Rust 中绝大部分类型都是在 *编译期可确定大小的类型(Sized Type)*, eg: 原生整
     数类型 u32 固定是 4 个字节, u64 固定是 8个字节.

     Rust 中也有少量的 *动态大小的类型(Dynamic Sized Type, DST)*, eg: str 类型的
     字符串字面量, 编译器就不可能事先知道程序中会出现什么样的字符串,所以对于编译
     器来说, str 类型的大小是无法确定的. 对于这种情况, Rust 提供了引用类型, 因为
     引用总会有固定的且在编译期已知的大小. 字符串切片 ~&str~ 就是一种引用类型,
     它由指针和长度组成.

     #+begin_example
                 /&str\
       栈:       * 5
                 ↓
       堆:       h e l l o
                 \  str /
     #+end_example

     ~&str~ 存储于栈上, str 字符串序列存储于堆上. 这里的堆和栈是指不同的内存空间,
     在第 4 章会详细介绍. ~&str~ 由 两部分组成: *指针* 和 *长度信息*. 其中指针是
     固定大小的, 存储的是 str 字符串序列的起始地址, 长度信息也是固定大小的整数.
     这样一来, ~&str~ 就变成了可确定大小的类型, 编译器就可以正确地为其分配栈内存
     空间, str 也会在运行时在堆上开辟内存空间.

     对于 ~as_ptr()~ 和 ~len()~ 方法, 可以分别获取该字符串字面量存储的地址和长度
     信息. *这种包含了动态大小类型地址信息和携带了长度信息的指针, 叫做胖指针(Fat
     Pointer)*, 所以 ~&str~ 是一种胖指针.

     与字符串切片同理, Rust 中的数组 ~[T]~ 是动态大小类型, 编译器难以确定它的大
     小.

**** 0 大小类型
     除了可确定大小类型和 DST 类型, Rust 还支持 *0 大小类型(Zero Sized, Type,
     ZST)*, eg: 单元类型和单元结构体, 大小都是 0.

     *单元类型和单元结构体大小为 0, 其单元类型组成的数组大小也为 0*. 
     *ZST 类型的特点是, 它们的值就是其本身, 运行时并不占用内存空间*.
     ZST 类型代表的意义正是"空".

     Rust 标准库中的 ~HashSet<T>~ 和 ~BTreeSet<T>~. 它们其实只是把 ~HashMap<K,
     T>~ 换成了 ~HashMap<K, ()>~, 然后就可以共用 ~HashMap<K, T>~ 之前的代码, 而
     不需要重新实现一遍 ~HashSet<T>~ 了.

**** 底类型
     底类型(Buttom Type) 是源自类型理论的术语, 它其实是第 2 章介绍过的 never 类
     型. 特点如下:

     - 没有值
     - 是其他任意的子类型

     如果说 ZST 类型表示 "空" 的话, 那么 *底类型就表示 "无"*. 底类型无值, 而且它
     等价于任意类型, 有点无中生有之意.

     Rust 中的底类型用 *叹号(!)表示*. 此类型也被称为 Bang Type. Rust 中有很多种
     情况确实没有值, 但为了类型安全, 必须把这些情况纳入类型系统进行统一处理. 这
     些情况包括:

     - *发散函数(Diverging Function)*
     - continue 和 break 关键字
     - loop 循环
     - *空枚举*, eg: ~enum Void {}~
       
     发散函数是指挥导致线程崩溃的 ~panic!("This function never returns!")~, 或者
     用于退出函数的 ~std::process::exit~, 这类函数永远都不会有返回值.

     continue 和 break 也是类似的, 它们只是表示流程的跳转, 并不会返回什么. loop
     循环虽然可以返回某个值, 但也有需要无限循环的时候.
     
     Rust 中 if 语句是表达式, *要求所有分支类型一致*, 但是有时候, 分支中可能包含
     了永远无法返回的情况, 属于底类型的一种应用.
       
     Rust 使用 Result 类型来进行错误处理, 强制开发者处理 ~Ok~ 和 ~Err~ 两种情况.
     但是有时可能永远没有 ~Err~, 这时使用 ~enum Void {}~ 就可以避免处理 ~Err~ 的
     情况. 当然这里也可以用 ~if let~ 语句处理, 这里为了说明空枚举的用法故意这样
     使用.
     
*** 类型推导
    类型标注在 Rust 中属于语法的一部分, 所以 Rust 属于显式类型语言. Rust 支持类
    型推断, 但其功能并不像 Haskell 那样强大.

    *Rust 只能在局部范围内进行类型推导*.

**** Turbofish 操作符
     当 Rust 无法从上下文中自动推导出类型的时候, 编译器会通过错误信息告诉开发者,
     请求添加类型标注.

     形如 ~parse::<i32>()~ 这种, 使用 ~::<>~ 形式的为泛型函数标注类型的为
     *turbofish 操作符*.

     
**** 类型推导的不足
     目前看来, Rust 的类型推导还不够强大.

     eg: 使用 ~is_positive()~ 时候需要更确切的类型. 

     所以应尽量显示声明类型.

** 泛型
   泛型(Generic)是一种参数化多态. 使用泛型可以编写更为抽象的代码, 减少工作量. 简
   单来说, 泛型就是把一个繁华的类型作为参数, 单个类型就可以抽象化为一簇类型.

   eg: ~Box<T>~, ~Option<T>~ 和 ~Result<T, E>~ 等, 都是泛型类型.

*** 泛型函数
    除了定义类型, 泛型也可以应用于函数中

    结构体名称旁边的 ~<T>~ 叫做 *泛型声明*.

    *泛型只有被声明之后才可以被使用*. 在为泛型结构体实现具体方法的时候, 也需要声
    明泛型类型.

    对于实现泛型结构体方法中的 ~impl<T>~ 的泛型不可省略.

    Rust 中的泛型属于静多态, 它是一种编译期多态. 在编译期, 不管是泛型枚举, 还是
    泛型函数和泛型结构体, 都会被 *单态化(Monomorphization)*. 单态化是编译器进行
    静态分发的一种策略. 

    *单态化意味着编译器要将一个反向函数生成两个具体类型对于的函数*.
    
    eg: 编译期的单态化函数:
    #+begin_src rust
      fn foo_1(x: i32) -> i32 {
          return x;
      }

      fn foo_2(x: &'static str) -> &'static str {
          return x;
      }

      fn main() {
          foo_1(1);
          foo_2("2");
      }
    #+end_src

    泛型及单态化是 Rust 的最重要的两个功能:
    *单态化静态分发的好处是性能好, 没有运行时开销*.
    *缺点是容易造成编译后生成的二进制文件膨胀*. 

    这个缺点并不影响使用 Rust 编程. 但是需要明白单态化机制, 在平时的编程中注意二
    进制的大小, 如果变得太大, 可以根据具体的情况重构代码来解决问题.
    
