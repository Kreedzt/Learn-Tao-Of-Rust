* 类型系统
  本性决定行为, 本性取决于行为.

** 通用概念
   *类型是对表示信息的值进行细粒度的区分*. eg: 整数, 小数, 文本等.

   不同的类型占用的内存不同. 与直接操作比特位相比, 直接操作类型可以更安全, 更有
   效地利用利用内存.(eg: Rust 自动分配 4 个字节存储 u32 类型的值)

   计算机除了存储信息外, 还需要处理信息. 这就必然会面临一个问题: 不同类型的值计
   算问题. 类型之间的纷繁复杂的交互形成了类型系统, *是编程语言的基础和核心*, 因
   为编程语言的目的就是存储和处理信息. 不同编程语言之间的区别就在于如何存储和处
   理信息.

   在计算机科学中, 类型系统是最轻量, 最完善的一种方式. 
   在类型系统中, *一切皆类型*. 基于类型定义的一系列组合, 运算和转换等方法, 可以
   看做类型的 *行为*. 类型的行为决定了类型该如何计算, 同时也是一种约束, 有了这种
   约束才可以保证信息被正确处理.

*** 类型系统的作用
    类型系统是一门编程语言不可或缺的部分, 有如下方面的优势:
    - *排查错误*: 很多编程语言都会载编译期或运行期进行类型检查, 以便排查违规行为,
      保证程序正确执行. 如果程序中有类型不一致的情况, 或有未定义的行为发生, 则可
      能导致错误的产生. 尤其对于静态语言来说, 能在编译期排查出错误是一个很大的优
      势, 这样可以尽早地处理问题, 而不必等到运行后崩溃了再解决

    - *抽象*: 类型允许开发者在更高层面进行思考, 这种抽象能力有助于强化编程规范和
      工程化系统. eg: OOP 语言中的类就可以作为一种类型.

    - *文档*: 在阅读代码的时候, 明确的类型声明可以表明程序的行为

    - *优化效率*: 这一点是针对静态编译语言来说的, 在编译期可以通过类型检查来优化
      一些操作, 节省运行时的时间

    - *类型安全*:
      + *类型安全的语言可以避免类型间的无效运算*
        eg: ~3/ "hello"~ 这种不符合算术规则的计算.

      + *类型安全的语言还可以保证内存安全*: 避免空指针, 悬垂指针和缓冲区溢出等导
        致的内存安全问题.

      + *类型安全的语言也可以避免语义上的逻辑错误*
        eg: 以 mm 为党委的数值和以 cm 为单位的数值都是以整数来存储的, 但是可以用
        不同的类型来区分, 避免逻辑错误

        
    尽管类型系统有诸多优点, 但并非所以肚饿编程语言都能 100% 拥有这些优点, 这与它
    们的类型系统的具体设计和实现有关.

*** 类型系统的分类
    在编译期进行类型检查的语言属于 *静态类型*, 在运行期进行类型检查的语言属于 
    *动态类型*. 如果一门语言不允许类型的自动隐式转换, 在强制转换前不同类型无法进
    行计算, 则该语言属于 *强类型*, 反之则属于 *弱类型*.

    *静态类型的语言能在编译期对代码进行静态分析, 依靠的就是类型系统*.
    eg: 越界数组. 有些静态语言, C 和 C++, 在编译期 *不检查* 数组是否越界访问, 运
    行时可能会得到难以意料的结果, 而程序依旧正常运行, 这属于类型系统中未定义的行
    为, 所以它们不是类型安全的语言. 而 *Rust 语言在编译期就能监察处数组是否越界
    访问*, 并给出警告, 让开发者及时修改, 如果开发者没有修改, 那么在运行时也会抛
    出错误并退出线程, 而不会因此去访问非法的内存, 从而保证了运行时的内存安全, 所
    以 *Rust 是类型安全的语言*. 强大的类型系统也可以对类型进行 *自动推导*, 因此
    一些静态语言在编写代码时候不用显式地指定具体的类型, eg: Haskell 就被称为隐式
    静态类型. Rust 语言的类型系统受 Haskell 启发, 也可以自动推导, 但不如 Haskell
    强大. 在 Rust 中大部分地方还是需要显式地指定类型, 类型是 Rust 语法的一部分,
    因此 *Rust 属于显示静态类型*.

    *动态类型的语言只能在运行时进行类型检查*, 但是当有数组越界访问时, 就会抛出异
    常, 执行线程退出操作, 而不是给出奇怪的结果. 所以一些动态语言也是类型安全的,
    eg: Ruby 和 Python. 在其他语言中作为基本类型的整数, 字符串, 布尔值等, 在
    Ruby 和 Python 语言中都是对象. 实际上, 也可将对象看做类型, Ruby 和 Python 语
    言在运行时通过一种名为 Duck Typing 的手段来进行运行时类型检查, 以保证类型安
    全. 在 Ruby 和 Python 语言中, 对象之间通过消息进行通信, 如果对象可以响应该消
    息, 则说明该对象就是正确的类型.

    对象是什么样的类型, 决定了它由什么样的行为; 反过来, 对象在不同上下文中的行为,
    也决定了它的类型. 这其实是一种 *多态性*.

*** 类型系统与多态性
    如果一个类型系统允许一段代码在不同的上下文中具有不同的类型, 这样的类型系统就
    叫做 *多态类型系统*. 对于静态类型的语言来说, 多态性的好处是可以在不影响类型
    丰富的前提下, 为不同的类型编写通用的代码.

    现代编程语言包含了三种多态形式: *参数化多态(Parametric polymorphism)*,
    *Ad-hoc多态(Ad-hoc polymorphism)* 和 *子类型多态(Subtype polymorphism)*. 如
    果按多态发生的时间来划分, 又可分为 *静多态(Static polymorphism)* 和 *动多态
    (Dynamic Polymorphism)*. 静多态发生在编译期, 动多态发生在运行时. 参数化多态
    和 Ad-hoc 多态一般是静多态, 子类型多态一般是动多态. 静多态牺牲灵活性获取性能,
    动多态牺牲性能获取灵活性. 动多态在运行时需要查表, 占用较多空间, 所以一般情况
    下都使用静多态. Rust 语言同时支持静多态和动多态, 静多态是一种 0 成本抽象.

    *参数化多态实际就是指泛型*. 很多时候函数或数据类型都需要适用于多种类型, 以避
    免大量的重复性工作. 泛型使得语言极具表达力, 同时也能保证静态类型安全.

    *Ad-hoc 多态也叫特定多态*. Ad-hoc 短语源自拉丁语系, 用于表示一种特定情况.
    *Ad-hoc多态是指同一种行为定义, 在不同的上下文中会响应不同的行为实现*.
    Haskell 语言中使用 Typeclass 来支持 Ad-hoc 多态, Rust 受 Haskell 启发, 使用
    trait 来支持 Ad-hoc 多态. 所以, Rust 的 trait 系统的概念类似于 Haskell 中的
    Typeclass.

    子类型多态的概念一般用在 OOP 语言中, 尤其是 Java 语言. Java 语言中的多态就是
    子类型多态, 它代表一种包含关系, 父类型的值包含了子类型的值, 所以子类型的值有
    时也可以看做父类型的值, 反之则不然. 而 Rust 语言中没有类似 Java 中的集成的概
    念, 所以也不存在子类型多态. 

    所以, *Rust 中的类型系统目前只支持参数化多态和 Ad-hoc 多态*, 也就是: *泛型*
    和 *trait*.
