* 字符串与集合类型
  数据结构是计算机存储和组织数据的方式. 对于不同的场景, 精心选择的数据结构可以带
  来更高的运行效率或存储效率. 通常, 通过确定数据结构来选择相应的算法, 也可能通过
  算法来选择数据结构, 不管是哪种情况, 选择合适的数据结构都相当重要.

  程序中最常用的三大数据结构是字符串、数组和映射. 字符串是特殊的线性表, 是由 0 个
  或多个字符组成的有限序列. 但字符串和数组、映射的区别在于, 字符串是被作为一个整
  体来关注和使用的; 而数组和映射关注最多的是其中的元素及它们之间的关系. 所以, 数
  组和映射也被称为集合类型. Rust 作为一门现代高级语言, 也自然为这三大数据结构提
  供了丰富的操作支持.

** 字符串
   在编程中字符串具有非常重要的地位. 计算机底层只存储 0 和 1 这两个数字, 如果想
   让计算机处理各种字符串, 就必须建立字符和特定数字的一一映射关系. eg: 想让计算
   机存储字符 A, 则存储二进制数 0100_0001, 在读取的时候, 再将 0100_0001 显示为字
   符串 A, 这样就将字符 A 和 0100_0001 建立了一一映射关系. 这种方案, 就叫做 *字
   符编码* (Character Encoding).

*** 字符编码
    最早的字符编码就是常见的 ASCⅡ 编码. 因为计算机起源于美国, 美国是以英语为母语
    的国家, 所以 ASCⅡ 码表中只记录了英文字母大小写和一些常用的基本符号, 并使用 0
    ~ 127 的数字来表示它们. 最大的数字 127 的二进制数是 1111111, 所以用 1 字节(8
    比特位) 足以表示全部的 ASCⅡ 编码.

    随着计算机的普及, 出现了很多编码标准, GB2312 是我国基于 ASCⅡ 编码进行中文扩
    充以后产生的, 可以表示 6000+ 个汉子. 之后出现了 GBK 编码, 包括 GB2312 的所有
    汉字外, 又扩充了近 2 万个汉子. 再后来, 为了兼容少数民族语言,  又扩充成
    GB18030 编码. 而与此同时, 其他国家也都分别创造了属于自己语言的字符编码标准.
    这样带来的后果就是:　如果想同时显示多个国家的文字，　就必须在计算机中安装多
    套字符编码系统，　这就带来了诸多不便.

    为了解决这个问题, 国际标准化组织指定了通用的多字节编码字符集, 也就是 Unicode
    字符集. 该字符集相当于一张表, 其中包含了世界上所有语言中可能出现的字符, 每个
    字符对应一个非负整数, 该数字称为 *码点(Code Point)*. 这些码点也分为不同的类
    型, 包括 *标量值(Scala Value)* 、代理对码点、非字符码点、保留码点、和私有码
    点. 其中标量值最常用, 它是指实际存在对应字符的码位, 其范围是 0x0000 ~ 0xD7FF
    和 0xE000 ~ 0x10FFFF 两段. Unicode 字符集只规定了字符所对应的码点, 却没有指
    定如何存储. 如果直接存储码位, 则太耗费时间了, 因为 Unicode 字符集的每个字符
    都占 4 字节, 传输效率非常低. 虽然 Unicode 字符集解决了字符通用的问题, 但是必
    须寻求另外一种存储方式, 在保证 Unicode 字符集通用的情况下更加节约流量和硬盘
    空间. 这种存储方式就是 *码元(Code Unit)* 组成的序列.

    | \                | 英文字符 A | 中文道         | emoji:smile:        |
    |------------------+------------+----------------+---------------------|
    | Code Point       |     U+0x41 | U+9053         | U+1F600             |
    | UTF-8 Code Point |       0x41 | 0xE9 0x81 0x93 | 0xF0 0x9F 0x98 0x84 |
    | Byte             |          1 | 3              | 4                   |

    码元是指用于处理和交换编码文本的最小比特组合. eg: 计算机处理字符的最小单位 1
    字节就是一个码元. 通过将 Unicode 标量值和码元序列建立一一映射关系, 就构成了
    码表. 在 Unicode 中一共有 3 种这样的字符编码表: UTF-8, UTF-16 和 UTF-32, 它
    们正好对应了 1 字节, 2 字节和 4 字节的码元. 对于 UTF-16 和 UTF-32 来说, 因为
    它们的码元分别是 2 字节和 4 字节, 所以就得考虑字节节序问题; 而对于 UTF-8 来
    说, 一个码元只有 1 字节, 所以不存在字节序问题, 可以直接存储.

    UTF-8 是以 1 字节为编码单位的可变长编码, 它根据一定的规则将码位编码为 1 ~ 4
    字节, 如下所示:
    | Unicode 范围      | UTF-8 编码(1-4 字节)                |
    |-------------------+-------------------------------------|
    | U+0000 ~ U+-007F  | 0XXXXXXX                            |
    | U+0800 ~ U+07FF   | 110XXXXX 10XXXXXX                   |
    | U+0800 ~ U+FFFF   | 1110XXXX 10XXXXXX 10XXXXXX          |
    | U+10000 ~ U+1FFFF | 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX |

    UTF-8 编码规则大致如下：
    - 当一个字符在 ASCⅡ 码的范围(兼容 ASCⅡ 码)内时, 就用 1 字节表示, 因为 ASC Ⅱ
      码中的字符最多使用 7 个比特位, 所以前面需要补 0.
    - 当一个字符占用了 n 字节时, 第一字节的前 n 位设置为 1, 第 n+1 位 设置为 0,
      后面字节的前 2 位设置为 10.

    以 "道" 举例, 它的码位是 U+9053, 相应的二进制表示为 1001_0000_0101_0011, 按
    上述 UTF-8 编码规则进行编码, 则变为字节序列 1110_1001_10_000001_10_010011,
    用十六进制表示的话, 就是 0xE90x810x93.

    像这种将 Unicode 码位转换为字节序列的过程，　就叫做 *编码(Encode)*; 反过来,
    将编码字节序列转变为字符集中码位的过程, 就叫做 *解码(Decode)*.

    UTF-8 编码的好处就是在实际传输过程中其占据的长度是不固定的, 在保证 Unicode
    通用性的情况下避免了流量和空间的浪费, 而且还保证了传输过程中不会错判字符. 正
    因如此, UTF-8 才能被广泛应用于互联网中.

    
*** 字符
    Rust 使用 char 类型表示单个字符. char 雷神使用整数值与 Unicode 标量值一一对
    应.

    在 Rust 中每个 char 类型的字符都代表一个有效的 u32 类型的整数, 但不是每个
    u32 类型的整数都能代表一个有效的字符. 因为并不是每个整数都属于 Unicode 标量
    值.

    为了能够存储任何 Unicode 标量值, Rust 规定 *每个字符都占 4 字节*.

    将字符串转换为字符串时, 要注意字节长度. 可以通过内建的 ~len_utf8()~ 方法获取
    UTF-8 编码的字节长度.

    *注意*: 只有包含单个 Unicode 标量值(实际码位)的才能被声明为字符(从 Rust 1.3
    版本起, 开始支持多码位字符).

*** 字符串分类
    字符串是由字符组成的有限序列. 字符可以用整数值直接表示 Unicode 标量值, 然而
    字符串却不能, 因为字符串不能确定大小, 所以在 Rust 中字符串是 UTF-8 编码序列.

    出于内存安全的考虑, 在 Rust 中字符串分别为以下几种类型:
    - *str*: 表示固定长度的字符串
    - *String*: 表示可增长的字符串.
    - *CStr*: 表示由 C 分配而被 Rust 借用的字符串, 一般用于和 C 语言交互.
    - *CString*: 表示由 Rust 分配且可以传递给 C 函数使用的 C 字符串, 同样用于和
      C 语言交互
    - *OsStr*: 表示和操作系统相关的字符串. 这是为了兼容 Windows 系统.
    - *OsString*: 表示 OsStr 的可变版本. 与 Rust 字符串可以相互转换.
    - *Path*: 表示路径, 定义于 ~std::path~ 模块中. Path 包装了 OsStr.
    - *PathBuf*: 跟 Path 配对, 是 Path 的可变版本. PathBuf 包装了 OsString.

    但是在 Rust 中最常用的字符串是 str 和 String. 在第 3 章中已经介绍过 str 属于
    动态大小类型(DST), 在编译期并不能确定其大小, 所以在程序中最常见到的是 str 的
    *切片(Slice)* 类型的 &str. &str 代表的是不可变的 UTF-8 字节序列, 创建后无法
    再为其追加内容或更改其内容. &str 类型的字符串可以存储在任意地方:

    - *静态存储区*: 有代表性的是字符串字面量, ~&'static str~ 类型的字符串被直接
      存储到已编译的可执行文件中, 随着程序一起加载启动.
    - *堆分配*: 如果 &str 类型的字符串是通过堆 String 类型的字符串取切片生成的,
      则存储在堆上. 因为 String 类型的字符串是堆分配的, &str 只不过是其在堆上的
      切片.
    - *栈分配*: 比如使用 ~str::from_utf8()~ 方法, 就可以将栈分配的 ~[u8;N]~ 数组
      转换为一个 &str 字符串.

    与 &str 类型相对应的是 String 类型的字符串. &str 是一个引用类型, 而 String
    类型的字符串拥有所有权. String 是由标准库提供的可变字符串, 可以在创建后为其
    追加内容或更改其内容. String 类型本质为一个成员变量是 ~Vec<u8>~ 类型的结构体,
    所以它是直接将字符内容存放于堆中的. *String 类型由 3 部分组成*: 指向堆中的字
    节序列的指针(as_ptr 方法), 记录堆中字节序列的字节长度(len 方法)和堆分配的容
    量(capacity 方法).

*** 字符串的两种处理方式
    Rust 中的字符串不能使用索引访问其中的字符, 因为字符串是 UTF-8 字节序列, 到底
    返回字节还是码点是一个问题. 但是 Rust 提供了 bytes 和 chars 两个方法来分别按
    字节和按字符迭代的迭代器. 所以, 在 Rust 中对字符串的操作大致分为 2 种方式: 
    *按字节处理* 和 *按字符处理*.

    调用 str 的 ~len()~ 方法时, 返回的是字符串的字节长度, 而非字符长度.

    Rust 提供了 ~get()~ 和 ~get_mut()~ 可以通过指定索引范围来获取字符串切片, 并
    且 Rust 默认会检查字符串的序列是否为有效的 UTF-8 序列.

    在使用字符串内建的 ~split_at()~ 和 ~split_at_mut()~ 方法分割字符串时, 需要注
    意: *一定要使用合法的字符串边界索引*, 否则就会引起线程崩溃.

    日常处理字符串时, 要注意是按字节还是按字符进行的, 以避免发生预期之外的错误.

*** 字符串的修改
    一般情况下, 如果要修改字符串, 则使用 String 类型. 修改字符串大致分为: 追加、
    插入、连接、更新和删除 5 种情形.

**** 追加字符串
     对于追加的情形, Rust 提供了 push 和 push_str 两个方法.

     push 和 push_str 在内部实现上其实是类似的, 因为 String 本质是对 ~Vec<u8>~
     动态数组的包装, 所以对于 push 来说, 如果字符是单字节的, 则将字符转换为 u8
     类型直接最佳到 ~Vec<u8>~ 尾部; 如果是多字节的, 则转换为 UTF-8 字节序列, 通
     过 ~Vec<u8>~ 的 ~extend_from_slice~ 方法来扩展 String 类型字符串的内部
     ~Vec<u8>~ 数组.

     除了上面 2 个方法, 也可以通过迭代器为 String 追加字符串, 因为 String 上实现
     了 Extend 迭代器.

**** 插入字符串
     如果想从字符串的某个位置开始插入一段字符串, 则需要使用 insert 和 insert_str
     方法, 其用法和 push/push_str 方法类似.

     *注意*: 这两个方法是基于字节序列的索引进操作的, 其内部实现会通过
     ~is_char_boundary~ 方法来判断插入的位置是否为合法的字符边界, 如果插入的位
     置非法, 则会引发线程崩溃

**** 连接字符串
     String 类型的字符串也实现了 ~Add<&str>~ 和 ~AddAssign<&str>~ 两个 trait, 这
     意味着可以使用 "+" 和 "+=" 操作符来连接字符串.
     
     需要注意的是: 操作符右边的字符串为切片类型(~&str~). ~&String~ 类型因为
     String 类型实现了 *Deref* trait, 所以执行加法操作自动解引用为 ~&str~ 类型.

**** 更新字符串
     因为 Rust 不支持直接按索引操作字符串中的字符, 一些常规的算法在 Rust 中必然
     无法使用. eg: 想修改某个字符串中符合条件的字符为大写, 就无法直接通过索引来
     操作, 只能通过迭代器的方式或者某些 unsafe 方法.

**** 删除字符串
     ~remove~. ~truncate~ 方法使用时需要注意: 此类方法是按字节操作, 可能引发线程
     崩溃

*** 字符串的查找
    在 Rust 标准库中 *并没有* 提供正则表达式的支持, 这是因为正则表达式算是外部
    DSL, 如果直接将其引入标准库中, 则会破坏 Rust 的一致性. 因为线程的正则表达式
    引擎都是其他语言实现的, eg: C 语言. 除非完全使用 Rust 来实现. 目前 Rust 支持
    的正则表达式引擎是官方实现的第三方包 *regex*, 未来是否会归为标准库中, 不得而
    知. 虽然 Rust 在标准库中不提供正则表达式支持, 但它提供了另外的字符串匹配功能
    供开发者使用, 一共包含 20 个方法.

    这 20 个方法涵盖了以下几种字符串匹配操作:
    - *存在性判断*: ~contains~, ~starts_with~, ~ends_with~.
    - *位置匹配*: ~find~, ~rfind~
    - *分割字符串*: ~split~, ~rsplit~, ~split_terminator~, ~rsplit_terminator~,
      ~splitn~, ~rsplitn~.
    - *捕获匹配*: ~matches~, ~rmatches~, ~match_indices~, ~rmatch_indices~.
    - *删除匹配*: ~trim_matches~, ~trim_left_matches~, ~trim_right_matches~.
    - *替代匹配*: ~replace~, ~replacen~

**** 存在性判断
     ~contains~ 返回 bool 类型

     ~std::str~ 模块中 ~contains~ 方法源码:
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       #[inline]
       // 参数限定为 `Pattern<'a>`
       pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {
           pat.is_contained_in(self)
       }
     #+end_src
     
     ~Pattern<'a>~ 是一个专门用于搜索 ~&'a str~ 字符串的模式 trait. Rust 中的
     ~char~ 类型, ~String~, ~&str~, ~&&str~, ~&[char]~ 类型, 以及 ~FnMut(char)
     -> bool~ 的闭包均已经实现了该 trait. 因此, ~contains~ 才可以接收不同类型的
     值作为参数.

     ~starts_with~ 和 ~ends_with~ 与 ~contains~ 一样, 也可以接收实现了
     ~Pattern<'a>~ 的类型作为参数. 为了方便描述, 暂且称这种参数为 ~pattern~ 参
     数. ~starts_with~ 和 ~ends_with~ 分别用于判断指定的 ~pattern~ 参数是否为字
     符串的起始边界和结束边界.

**** 位置匹配
     如果想查找指定字符串中字符所在的位置, 则可以使用 ~find~ 方法
     ~find~ 方法默认是从左向右按字符进行遍历查找的, 最终返回 ~Option<usize>~ 类
     型的位置索引, ~rfind~ 表示从右向左来匹配.

**** 分割字符串
     如果想通过指定的模式来分割字符串, 则可以使用 ~split~ 系列方法.

     ~splitn~ 的第一个参数代表分割的数组长度.

     ~split_terminator~ 会把分割结果数组最后一位的空字符串去掉.(仅去掉最后, 不去
     掉起始: [[https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=8bcdbceb5973c8190a88f17917879e06][PLayground]])

     
**** 捕获匹配
     通常通过正则表达式来完成在字符串中匹配符合条件的字符.
     在 Rust 中, 通过 ~pattern~ 参数配合 ~matches~ 系列方法可以获得同样的效果.

     ~match_indices~ 方法返回的结果是元组数组, 其中元组的第一个元素代表匹配字符
     的位置索引.

     从方法的命名来看, indices 为 index 的复数形式, 在语义上就指名了匹配结果会包
     含索引. 在标准库中有不少以 "_indices" 结尾的方法名, 在语义上都表明其返回值
     会包含索引.

**** 删除匹配
     在 ~std::str~ 模块中提供了 ~trim~ 系列方法, 可以删除字符串两头的指定字符.

     ~trim~ 系列方法可以删除字符串两头的空格, 制表符(\t) 和换行符(\n).

     Rust 还提供了 ~trim_matches~ 系列方法, 支持 ~pattern~ 参数, 可以指定自定义
     的删除规则.

**** 替代匹配
     使用 ~trim_matches~ 系列方法可以满足基本的字符串删除匹配要求, 但是其质量去
     除字符串两头的字符, 无法去除字符串内部包含的字符. 可以通过 ~replace~ 系列方
     法来实现此需求.

**** 字符串的匹配模式原理
     Rust 提供的这些字符串匹配方法看似繁多, 但实际上其背后是一套统一的迭代器适配
     器. 我们从 ~matches~ 方法说起:

     ~matches~ 方法源码
     #+begin_src rust
       #[stable(feature = "str_matches", since = "1.2.0")]
       #[inline]
       pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {
           Matches(MatchesInternal(pat.into_searcher(self)))
       }
     #+end_src

     该方法返回的是 ~Matches<'a, P>~ 类型, 它是一个结构体, 也是一个迭代器.
     源码如下:
     #+begin_src rust
       // generate_pattern_iterators! {
       //     forward:
       //     /// Created with the method [`matches`].
       //     ///
       //     /// [`matches`]: str::matches
       //     struct Matches;
       //     reverse:
       //     /// Created with the method [`rmatches`].
       //     ///
       //     /// [`rmatches`]: str::rmatches
       //     struct RMatches;
       //     stability:
       //     #[stable(feature = "str_matches", since = "1.2.0")]
       //     internal:
       //     MatchesInternal yielding (&'a str);
       //     delegate double ended;
       // }

       struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);
       // 通过以上宏生成
       pub struct Matches<'a, P: Pattern<'a>>(MatchesInternal<'a, P>);
       impl<'a, P: Pattern<'a>> Iterator for Matches<'a, P> {
           type Item = &'a str;
           fn next(&mut self) -> Option<&'a str> {
               self.0.next()
           }
       }
     #+end_src
     
     ~Matches~ 结构体是一个元组结构体, 也就是 NewType 模式, 它包装了
     ~MatchesInternal~ 结构体. 为 ~Matches~ 实现了 ~Iterator~, 它就成为迭代器.
     在 ~next~ 方法中, 它又调用了 ~MatchesInternal~ 结构体的 ~next~ 方法.

     ~MatchesInternal~ 实现 ~next~ 和 ~next_back~ 方法的源码:
     #+begin_src rust
       impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {
           #[inline]
           fn next(&mut self) -> Option<&'a str> {
               // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.
               self.0.next_match().map(|(a, b)| unsafe {
                   // Indices are known to be on utf8 boundaries
                   self.0.haystack().get_unchecked(a..b)
               })
           }

           #[inline]
           fn next_back(&mut self) -> Option<&'a str>
           where
               P::Searcher: ReverseSearcher<'a>,
           {
               // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.
               self.0.next_match_back().map(|(a, b)| unsafe {
                   // Indices are known to be on utf8 boundaries
                   self.0.haystack().get_unchecked(a..b)
               })
           }
       }
     #+end_src

     ~MatchesInternal~ 也是一个 NewType 模式的结构体, 它包装了 ~P::Searcher~. 其
     中 ~next~ 和 ~next_back~ 方法内部分别调用了 ~P::Searcher~ 的 ~next_match~
     和 ~next_match_back~ 方法, 最终返回 ~Map~ 迭代器供将来 ~collect~ 使用.

     注意 ~Pattern<'a>~, 这个 trait 实际上是字符串匹配算法的抽象.

     ~Pattern<'a>~ 和 ~SearchStep~ 定义:
     #+begin_src rust
       #[derive(Copy, Clone, Eq, PartialEq, Debug)]
       pub enum SearchStep {
           // 代表匹配到的索引范围: hasystack[0..3]
           Match(usize, usize),
           // 代表未匹配到的索引范围
           Reject(usize, usize),
           // 代表匹配完毕
           Done,
       }

       pub trait Pattern<'a>: Sized {
           type Searcher: Searcher<'a>;

           // 通过 `into_searcher` 方法得到具体的搜索类型
           // `haystack` 为原字符串
           fn into_searcher(self, haystack: &'a str) -> Self::Searcher;

           #[inline]
           // 用于判断 `needle` 串是否包含在 `haystack` 串中
           fn is_contained_in(self, haystack: &'a str) -> bool {
               self.into_searcher(haystack).next_match().is_some()
           }

           #[inline]
           // 前缀: 除最后一个字符之外的其余字符的组合
           fn is_prefix_of(self, haystack: &'a str) -> bool {
               matches!(self.into_searcher(haystack).next(), SearchStep::Match(0, _))
           }

           #[inline]
           // 后缀: 除最后一个字符串之外的全部尾部字符的组合
           fn is_suffix_of(self, haystack: &'a str) -> bool
           where
               Self::Searcher: ReverseSearcher<'a>,
           {
               matches!(self.into_searcher(haystack).next_back(), SearchStep::Match(_, j) if haystack.len() == j)
           }
       }
     #+end_src

     通常 haystack 代表原字符串, needle 代表子串.

     在 KMP 算法中, 前缀和后缀用于产生部分匹配表, 而在 Rust 中这里使用的字符匹配
     算法并非 KMP, 而是它的变种 *双向(Two-Way)字符串匹配算法*, 该算法的优势在于
     拥有常量级的空间复杂度. 它和 KMP 的共同点在于其时间复杂度也是 O(n), 并且都
     用到了前缀和后缀的概念.

     ~Searcher<'a>~ 源码:
     #+begin_src rust
       pub unsafe trait Searcher<'a> {
           // 用于传递 `haystack` 串
           fn haystack(&self) -> &'a str;

           // 用于返回 `SearchStep`
           // eg: needle: "aaaa", haystack: "abaaaaab"
           // 此时 next 方法可以nadao: [Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]
           fn next(&mut self) -> SearchStep;

           #[inline]
           // 用于匹配 `SearchStep` 来返回最终匹配的索引范围
           fn next_match(&mut self) -> Option<(usize, usize)> {
               loop {
                   match self.next() {
                       SearchStep::Match(a, b) => return Some((a, b)),
                       SearchStep::Done => return None,
                       _ => continue,
                   }
               }
           }

           #[inline]
           // 用于匹配 `SearchStep` 来返回最终未匹配的索引范围
           fn next_reject(&mut self) -> Option<(usize, usize)> {
               loop {
                   match self.next() {
                       SearchStep::Reject(a, b) => return Some((a, b)),
                       SearchStep::Done => return None,
                       _ => continue,
                   }
               }
           }
       }
     #+end_src
     
     该 ~Searcher<'a>~ 类似于迭代器, 包含了 4 个方法.

     为 ~&'a str~ 类型实现 ~Pattern<'a>~ 的源码:
     #+begin_src rust
       impl<'a, 'b> Pattern<'a> for &'b str {
           type Searcher = StrSearcher<'a, 'b>;

           #[inline]
           // 生成用于匹配 `&'a str` 类型字符串的搜索类型
           fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> {
               StrSearcher::new(haystack, self)
           }

           #[inline]
           fn is_prefix_of(self, haystack: &'a str) -> bool {
               haystack.as_bytes().starts_with(self.as_bytes())
           }

           #[inline]
           fn is_suffix_of(self, haystack: &'a str) -> bool {
               haystack.as_bytes().ends_with(self.as_bytes())
           }
       }

       #[derive(Clone, Debug)]
       /// Associated type for `<&str as Pattern<'a>>::Searcher`.
       pub struct StrSearcher<'a, 'b> {
           // 原字符串
           haystack: &'a str,
           // 子串
           needle: &'b str,

           // 枚举体
           searcher: StrSearcherImpl,
       }

       #[derive(Clone, Debug)]
       enum StrSearcherImpl {
           // 空字符串情况
           Empty(EmptyNeedle),
           // 非空字符串情况
           // `TwoWaySearcher` 即为 *双向字符串匹配算法的具体实现*
           TwoWay(TwoWaySearcher),
       }


       unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {
           #[inline]
           fn haystack(&self) -> &'a str {
               self.haystack
           }

           #[inline]
           fn next(&mut self) -> SearchStep {
               match self.searcher {
                   StrSearcherImpl::Empty(ref mut searcher) => {
                       // empty needle rejects every char and matches every empty string between them
                       let is_match = searcher.is_match_fw;
                       searcher.is_match_fw = !searcher.is_match_fw;
                       let pos = searcher.position;
                       match self.haystack[pos..].chars().next() {
                           _ if is_match => SearchStep::Match(pos, pos),
                           None => SearchStep::Done,
                           Some(ch) => {
                               searcher.position += ch.len_utf8();
                               SearchStep::Reject(pos, searcher.position)
                           }
                       }
                   }
                   StrSearcherImpl::TwoWay(ref mut searcher) => {
                       // TwoWaySearcher produces valid *Match* indices that split at char boundaries
                       // as long as it does correct matching and that haystack and needle are
                       // valid UTF-8
                       // *Rejects* from the algorithm can fall on any indices, but we will walk them
                       // manually to the next character boundary, so that they are utf-8 safe.
                       if searcher.position == self.haystack.len() {
                           return SearchStep::Done;
                       }
                       let is_long = searcher.memory == usize::MAX;
                       match searcher.next::<RejectAndMatch>(
                           self.haystack.as_bytes(),
                           self.needle.as_bytes(),
                           is_long,
                       ) {
                           SearchStep::Reject(a, mut b) => {
                               // skip to next char boundary
                               while !self.haystack.is_char_boundary(b) {
                                   b += 1;
                               }
                               searcher.position = cmp::max(b, searcher.position);
                               SearchStep::Reject(a, b)
                           }
                           otherwise => otherwise,
                       }
                   }
               }
           }

           #[inline]
           fn next_match(&mut self) -> Option<(usize, usize)> {
               match self.searcher {
                   StrSearcherImpl::Empty(..) => loop {
                       match self.next() {
                           SearchStep::Match(a, b) => return Some((a, b)),
                           SearchStep::Done => return None,
                           SearchStep::Reject(..) => {}
                       }
                   },
                   StrSearcherImpl::TwoWay(ref mut searcher) => {
                       let is_long = searcher.memory == usize::MAX;
                       // write out `true` and `false` cases to encourage the compiler
                       // to specialize the two cases separately.
                       if is_long {
                           searcher.next::<MatchOnly>(
                               self.haystack.as_bytes(),
                               self.needle.as_bytes(),
                               true,
                           )
                       } else {
                           searcher.next::<MatchOnly>(
                               self.haystack.as_bytes(),
                               self.needle.as_bytes(),
                               false,
                           )
                       }
                   }
               }
           }
       }
     #+end_src

     以上就是 *字符串匹配算法的背后机制*, 使用 ~Pattern<'a>~, ~Searcher<'a>~ 和
     ~SearchStep~ 来抽象字符串匹配算法, 然后 *利用迭代器模式* 进行检索. 这里也是
     Rust 一致性的体现.

*** 与其他类型相互转换
**** 将字符串转换为其他类型
     可以通过 ~std::str~ 模块中提供的 ~parse~ 泛型方法来将字符串转换为指定的类型.
     
     ~parse~ 方法为泛型方法, 使用时需要指定类型, 可以使用 turbofish 操作符.

     ~parse~ 方法内部是使用 ~FromStr::from_str~ 方法来实现转换的. ~FromStr~ 是一
     个 trait, 其命名符合 Rust 的一致性惯例.

     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       pub trait FromStr: Sized {
           #[stable(feature = "rust1", since = "1.0.0")]
           type Err;

           #[stable(feature = "rust1", since = "1.0.0")]
           fn from_str(s: &str) -> Result<Self, Self::Err>;
       }
     #+end_src

     该方法在解析失败时返回 ~Err~. Rust 为一些基本的原生类型, 布尔类型以及 IP 地
     址等少数类型实现了 ~FromStr~, 对于自定义的类型需要自己手工实现.
**** 将其他类型转换为字符串
     如果想把其他类型转换为字符串, 则可以使用 ~format!~ 宏. 该宏与 ~println!~ 及
     ~write!~ 宏类似, 同样可以通过格式化规则来生成 ~String~ 类型的字符串.

     ~format!~ 格式化规则:
     - *填充字符串宽度*: 格式: ~{:number}~, number 表示数字. 如果 number 的长度
       大于字符串长度, 则会默认填充空格来扩展字符串的长度.
     - *截取字符串*: 格式: ~{:.number}~, number 代表要截取的字符长度, 也可以和填
       充格式配合使用
     - *对齐字符串*: 格式为: ~{:>}~, ~{:^}~ 和 ~{:<}~, 分别表示左对齐, 位于中间
       和右对齐.

     ~format~ 格式化字符串实现按字符处理的, 不管字符串多长, 对于你们的 Unicode
     码位都会以单个字符位来处理.  

     除满足上述格式化规则之外, Rust 还提供了专门针对整数和浮点数的格式化代码.

     针对整数提供的格式化代码规则:
     - *符号+*: 表示强制输出整数的正负符号
     - *符号#*: 用于显示进制的前缀. eg: 16 进制显示 0x, 二进制显示 0b
     - *数字 0*: 用于把默认的空格替换为数字 0

     针对浮点数时, 某些格式化代码又表示不同的含义:
     - 指定小数点后的有效位: 符号 "~.~" 代表的是指定浮点数小数点后的有效位. 注
       意: 在指定有效位时会四舍五入.
     - 科学计数法: 使用 ~{:e}~ 可以将浮点数格式化为科学计数法的形式

     *以上所有的格式化规则, 对 ~println!~ 和 ~write!~ 宏均适用*.

     如果要对自定义类型格式化, 则需要实现 Display trait.

     实现 ~fmt~ 方法即可通过 ~format~ 宏根据该结构体实例生成字符串.

*** 回顾
    小例子回顾内容: 求出对角线位置的所有数字之和.
    #+begin_example
      1234
      5678
      9876
      4321



      1 + 6 + 7 + 1 + 4 + 7 + 8 + 4
    #+end_example

    使用原生字符串声明语法(r"...")可以将此数字方阵定义为字符串, 然后按行遍历其字
    符即可得到结果.

    原生字符串声明语法可以 *保留原来字符串中的特殊符号*.

** 集合类型
   Rust 标准库中提供的集合类型包括以下几种:
   - ~Vec<T>~: 动态可增长数组
   - ~VecDeque<T>~: 基于环形缓冲区的先进先出(FIFO)双端队列实现
   - ~LinkedList<T>~: 双向链表实现
   - ~BinaryHeap<T>~: 二叉堆(最大堆)实现, 可用作优先队列
   - ~HashSet<T>~: 无序集合实现
   - ~BTreeSet<T>~: 基于 B 树的有序集合实现

   以上最常用的集合类型为 ~Vec<T>~ 和 ~HashMap<K, V>~, 接下来主要介绍这两种集合
   类型

*** 动态可增长数组
    
