* 字符串与集合类型
  数据结构是计算机存储和组织数据的方式. 对于不同的场景, 精心选择的数据结构可以带
  来更高的运行效率或存储效率. 通常, 通过确定数据结构来选择相应的算法, 也可能通过
  算法来选择数据结构, 不管是哪种情况, 选择合适的数据结构都相当重要.

  程序中最常用的三大数据结构是字符串、数组和映射. 字符串是特殊的线性表, 是由 0 个
  或多个字符组成的有限序列. 但字符串和数组、映射的区别在于, 字符串是被作为一个整
  体来关注和使用的; 而数组和映射关注最多的是其中的元素及它们之间的关系. 所以, 数
  组和映射也被称为集合类型. Rust 作为一门现代高级语言, 也自然为这三大数据结构提
  供了丰富的操作支持.

** 字符串
   在编程中字符串具有非常重要的地位. 计算机底层只存储 0 和 1 这两个数字, 如果想
   让计算机处理各种字符串, 就必须建立字符和特定数字的一一映射关系. eg: 想让计算
   机存储字符 A, 则存储二进制数 0100_0001, 在读取的时候, 再将 0100_0001 显示为字
   符串 A, 这样就将字符 A 和 0100_0001 建立了一一映射关系. 这种方案, 就叫做 *字
   符编码* (Character Encoding).

*** 字符编码
    最早的字符编码就是常见的 ASCⅡ 编码. 因为计算机起源于美国, 美国是以英语为母语
    的国家, 所以 ASCⅡ 码表中只记录了英文字母大小写和一些常用的基本符号, 并使用 0
    ~ 127 的数字来表示它们. 最大的数字 127 的二进制数是 1111111, 所以用 1 字节(8
    比特位) 足以表示全部的 ASCⅡ 编码.

    随着计算机的普及, 出现了很多编码标准, GB2312 是我国基于 ASCⅡ 编码进行中文扩
    充以后产生的, 可以表示 6000+ 个汉子. 之后出现了 GBK 编码, 包括 GB2312 的所有
    汉字外, 又扩充了近 2 万个汉子. 再后来, 为了兼容少数民族语言,  又扩充成
    GB18030 编码. 而与此同时, 其他国家也都分别创造了属于自己语言的字符编码标准.
    这样带来的后果就是:　如果想同时显示多个国家的文字，　就必须在计算机中安装多
    套字符编码系统，　这就带来了诸多不便.

    为了解决这个问题, 国际标准化组织指定了通用的多字节编码字符集, 也就是 Unicode
    字符集. 该字符集相当于一张表, 其中包含了世界上所有语言中可能出现的字符, 每个
    字符对应一个非负整数, 该数字称为 *码点(Code Point)*. 这些码点也分为不同的类
    型, 包括 *标量值(Scala Value)* 、代理对码点、非字符码点、保留码点、和私有码
    点. 其中标量值最常用, 它是指实际存在对应字符的码位, 其范围是 0x0000 ~ 0xD7FF
    和 0xE000 ~ 0x10FFFF 两段. Unicode 字符集只规定了字符所对应的码点, 却没有指
    定如何存储. 如果直接存储码位, 则太耗费时间了, 因为 Unicode 字符集的每个字符
    都占 4 字节, 传输效率非常低. 虽然 Unicode 字符集解决了字符通用的问题, 但是必
    须寻求另外一种存储方式, 在保证 Unicode 字符集通用的情况下更加节约流量和硬盘
    空间. 这种存储方式就是 *码元(Code Unit)* 组成的序列.

    | \                | 英文字符 A | 中文道         | emoji:smile:        |
    |------------------+------------+----------------+---------------------|
    | Code Point       |     U+0x41 | U+9053         | U+1F600             |
    | UTF-8 Code Point |       0x41 | 0xE9 0x81 0x93 | 0xF0 0x9F 0x98 0x84 |
    | Byte             |          1 | 3              | 4                   |

    码元是指用于处理和交换编码文本的最小比特组合. eg: 计算机处理字符的最小单位 1
    字节就是一个码元. 通过将 Unicode 标量值和码元序列建立一一映射关系, 就构成了
    码表. 在 Unicode 中一共有 3 种这样的字符编码表: UTF-8, UTF-16 和 UTF-32, 它
    们正好对应了 1 字节, 2 字节和 4 字节的码元. 对于 UTF-16 和 UTF-32 来说, 因为
    它们的码元分别是 2 字节和 4 字节, 所以就得考虑字节节序问题; 而对于 UTF-8 来
    说, 一个码元只有 1 字节, 所以不存在字节序问题, 可以直接存储.

    UTF-8 是以 1 字节为编码单位的可变长编码, 它根据一定的规则将码位编码为 1 ~ 4
    字节, 如下所示:
    | Unicode 范围      | UTF-8 编码(1-4 字节)                |
    |-------------------+-------------------------------------|
    | U+0000 ~ U+-007F  | 0XXXXXXX                            |
    | U+0800 ~ U+07FF   | 110XXXXX 10XXXXXX                   |
    | U+0800 ~ U+FFFF   | 1110XXXX 10XXXXXX 10XXXXXX          |
    | U+10000 ~ U+1FFFF | 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX |

    UTF-8 编码规则大致如下：
    - 当一个字符在 ASCⅡ 码的范围(兼容 ASCⅡ 码)内时, 就用 1 字节表示, 因为 ASC Ⅱ
      码中的字符最多使用 7 个比特位, 所以前面需要补 0.
    - 当一个字符占用了 n 字节时, 第一字节的前 n 位设置为 1, 第 n+1 位 设置为 0,
      后面字节的前 2 位设置为 10.

    以 "道" 举例, 它的码位是 U+9053, 相应的二进制表示为 1001_0000_0101_0011, 按
    上述 UTF-8 编码规则进行编码, 则变为字节序列 1110_1001_10_000001_10_010011,
    用十六进制表示的话, 就是 0xE90x810x93.

    像这种将 Unicode 码位转换为字节序列的过程，　就叫做 *编码(Encode)*; 反过来,
    将编码字节序列转变为字符集中码位的过程, 就叫做 *解码(Decode)*.

    UTF-8 编码的好处就是在实际传输过程中其占据的长度是不固定的, 在保证 Unicode
    通用性的情况下避免了流量和空间的浪费, 而且还保证了传输过程中不会错判字符. 正
    因如此, UTF-8 才能被广泛应用于互联网中.

    
*** 字符
    Rust 使用 char 类型表示单个字符. char 雷神使用整数值与 Unicode 标量值一一对
    应.

    在 Rust 中每个 char 类型的字符都代表一个有效的 u32 类型的整数, 但不是每个
    u32 类型的整数都能代表一个有效的字符. 因为并不是每个整数都属于 Unicode 标量
    值.

    为了能够存储任何 Unicode 标量值, Rust 规定 *每个字符都占 4 字节*.

    将字符串转换为字符串时, 要注意字节长度. 可以通过内建的 ~len_utf8()~ 方法获取
    UTF-8 编码的字节长度.

    *注意*: 只有包含单个 Unicode 标量值(实际码位)的才能被声明为字符(从 Rust 1.3
    版本起, 开始支持多码位字符).

*** 字符串分类
    字符串是由字符组成的有限序列. 字符可以用整数值直接表示 Unicode 标量值, 然而
    字符串却不能, 因为字符串不能确定大小, 所以在 Rust 中字符串是 UTF-8 编码序列.

    出于内存安全的考虑, 在 Rust 中字符串分别为以下几种类型:
    - *str*: 表示固定长度的字符串
    - *String*: 表示可增长的字符串.
    - *CStr*: 表示由 C 分配而被 Rust 借用的字符串, 一般用于和 C 语言交互.
    - *CString*: 表示由 Rust 分配且可以传递给 C 函数使用的 C 字符串, 同样用于和
      C 语言交互
    - *OsStr*: 表示和操作系统相关的字符串. 这是为了兼容 Windows 系统.
    - *OsString*: 表示 OsStr 的可变版本. 与 Rust 字符串可以相互转换.
    - *Path*: 表示路径, 定义于 ~std::path~ 模块中. Path 包装了 OsStr.
    - *PathBuf*: 跟 Path 配对, 是 Path 的可变版本. PathBuf 包装了 OsString.

    但是在 Rust 中最常用的字符串是 str 和 String. 在第 3 章中已经介绍过 str 属于
    动态大小类型(DST), 在编译期并不能确定其大小, 所以在程序中最常见到的是 str 的
    *切片(Slice)* 类型的 &str. &str 代表的是不可变的 UTF-8 字节序列, 创建后无法
    再为其追加内容或更改其内容. &str 类型的字符串可以存储在任意地方:

    - *静态存储区*: 有代表性的是字符串字面量, ~&'static str~ 类型的字符串被直接
      存储到已编译的可执行文件中, 随着程序一起加载启动.
    - *堆分配*: 如果 &str 类型的字符串是通过堆 String 类型的字符串取切片生成的,
      则存储在堆上. 因为 String 类型的字符串是堆分配的, &str 只不过是其在堆上的
      切片.
    - *栈分配*: 比如使用 ~str::from_utf8()~ 方法, 就可以将栈分配的 ~[u8;N]~ 数组
      转换为一个 &str 字符串.

    与 &str 类型相对应的是 String 类型的字符串. &str 是一个引用类型, 而 String
    类型的字符串拥有所有权. String 是由标准库提供的可变字符串, 可以在创建后为其
    追加内容或更改其内容. String 类型本质为一个成员变量是 ~Vec<u8>~ 类型的结构体,
    所以它是直接将字符内容存放于堆中的. *String 类型由 3 部分组成*: 指向堆中的字
    节序列的指针(as_ptr 方法), 记录堆中字节序列的字节长度(len 方法)和堆分配的容
    量(capacity 方法).

*** 字符串的两种处理方式
    Rust 中的字符串不能使用索引访问其中的字符, 因为字符串是 UTF-8 字节序列, 到底
    返回字节还是码点是一个问题. 但是 Rust 提供了 bytes 和 chars 两个方法来分别按
    字节和按字符迭代的迭代器. 所以, 在 Rust 中对字符串的操作大致分为 2 种方式: 
    *按字节处理* 和 *按字符处理*.

    调用 str 的 ~len()~ 方法时, 返回的是字符串的字节长度, 而非字符长度.

    Rust 提供了 ~get()~ 和 ~get_mut()~ 可以通过指定索引范围来获取字符串切片, 并
    且 Rust 默认会检查字符串的序列是否为有效的 UTF-8 序列.

    在使用字符串内建的 ~split_at()~ 和 ~split_at_mut()~ 方法分割字符串时, 需要注
    意: *一定要使用合法的字符串边界索引*, 否则就会引起线程崩溃.

    日常处理字符串时, 要注意是按字节还是按字符进行的, 以避免发生预期之外的错误.

*** 字符串的修改
    一般情况下, 如果要修改字符串, 则使用 String 类型. 修改字符串大致分为: 追加、
    插入、连接、更新和删除 5 种情形.

**** 追加字符串
     对于追加的情形, Rust 提供了 push 和 push_str 两个方法.

     push 和 push_str 在内部实现上其实是类似的, 因为 String 本质是对 ~Vec<u8>~
     动态数组的包装, 所以对于 push 来说, 如果字符是单字节的, 则将字符转换为 u8
     类型直接最佳到 ~Vec<u8>~ 尾部; 如果是多字节的, 则转换为 UTF-8 字节序列, 通
     过 ~Vec<u8>~ 的 ~extend_from_slice~ 方法来扩展 String 类型字符串的内部
     ~Vec<u8>~ 数组.

     除了上面 2 个方法, 也可以通过迭代器为 String 追加字符串, 因为 String 上实现
     了 Extend 迭代器.

**** 插入字符串
     如果想从字符串的某个位置开始插入一段字符串, 则需要使用 insert 和 insert_str
     方法, 其用法和 push/push_str 方法类似.

     *注意*: 这两个方法是基于字节序列的索引进操作的, 其内部实现会通过
     ~is_char_boundary~ 方法来判断插入的位置是否为合法的字符边界, 如果插入的位
     置非法, 则会引发线程崩溃

**** 连接字符串
     String 类型的字符串也实现了 ~Add<&str>~ 和 ~AddAssign<&str>~ 两个 trait, 这
     意味着可以使用 "+" 和 "+=" 操作符来连接字符串.
     
     需要注意的是: 操作符右边的字符串为切片类型(~&str~). ~&String~ 类型因为
     String 类型实现了 *Deref* trait, 所以执行加法操作自动解引用为 ~&str~ 类型.

**** 更新字符串
     因为 Rust 不支持直接按索引操作字符串中的字符, 一些常规的算法在 Rust 中必然
     无法使用. eg: 想修改某个字符串中符合条件的字符为大写, 就无法直接通过索引来
     操作, 只能通过迭代器的方式或者某些 unsafe 方法.

**** 删除字符串
     ~remove~. ~truncate~ 方法使用时需要注意: 此类方法是按字节操作, 可能引发线程
     崩溃
