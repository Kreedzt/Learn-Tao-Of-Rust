* 字符串与集合类型
  数据结构是计算机存储和组织数据的方式. 对于不同的场景, 精心选择的数据结构可以带
  来更高的运行效率或存储效率. 通常, 通过确定数据结构来选择相应的算法, 也可能通过
  算法来选择数据结构, 不管是哪种情况, 选择合适的数据结构都相当重要.

  程序中最常用的三大数据结构是字符串、数组和映射. 字符串是特殊的线性表, 是由 0 个
  或多个字符组成的有限序列. 但字符串和数组、映射的区别在于, 字符串是被作为一个整
  体来关注和使用的; 而数组和映射关注最多的是其中的元素及它们之间的关系. 所以, 数
  组和映射也被称为集合类型. Rust 作为一门现代高级语言, 也自然为这三大数据结构提
  供了丰富的操作支持.

** 字符串
   在编程中字符串具有非常重要的地位. 计算机底层只存储 0 和 1 这两个数字, 如果想
   让计算机处理各种字符串, 就必须建立字符和特定数字的一一映射关系. eg: 想让计算
   机存储字符 A, 则存储二进制数 0100_0001, 在读取的时候, 再将 0100_0001 显示为字
   符串 A, 这样就将字符 A 和 0100_0001 建立了一一映射关系. 这种方案, 就叫做 *字
   符编码* (Character Encoding).

*** 字符编码
    最早的字符编码就是常见的 ASCⅡ 编码. 因为计算机起源于美国, 美国是以英语为母语
    的国家, 所以 ASCⅡ 码表中只记录了英文字母大小写和一些常用的基本符号, 并使用 0
    ~ 127 的数字来表示它们. 最大的数字 127 的二进制数是 1111111, 所以用 1 字节(8
    比特位) 足以表示全部的 ASCⅡ 编码.

    随着计算机的普及, 出现了很多编码标准, GB2312 是我国基于 ASCⅡ 编码进行中文扩
    充以后产生的, 可以表示 6000+ 个汉子. 之后出现了 GBK 编码, 包括 GB2312 的所有
    汉字外, 又扩充了近 2 万个汉子. 再后来, 为了兼容少数民族语言,  又扩充成
    GB18030 编码. 而与此同时, 其他国家也都分别创造了属于自己语言的字符编码标准.
    这样带来的后果就是:　如果想同时显示多个国家的文字，　就必须在计算机中安装多
    套字符编码系统，　这就带来了诸多不便.

    为了解决这个问题, 国际标准化组织指定了通用的多字节编码字符集, 也就是 Unicode
    字符集. 该字符集相当于一张表, 其中包含了世界上所有语言中可能出现的字符, 每个
    字符对应一个非负整数, 该数字称为 *码点(Code Point)*. 这些码点也分为不同的类
    型, 包括 *标量值(Scala Value)* 、代理对码点、非字符码点、保留码点、和私有码
    点. 其中标量值最常用, 它是指实际存在对应字符的码位, 其范围是 0x0000 ~ 0xD7FF
    和 0xE000 ~ 0x10FFFF 两段. Unicode 字符集只规定了字符所对应的码点, 却没有指
    定如何存储. 如果直接存储码位, 则太耗费时间了, 因为 Unicode 字符集的每个字符
    都占 4 字节, 传输效率非常低. 虽然 Unicode 字符集解决了字符通用的问题, 但是必
    须寻求另外一种存储方式, 在保证 Unicode 字符集通用的情况下更加节约流量和硬盘
    空间. 这种存储方式就是 *码元(Code Unit)* 组成的序列.

    | \                | 英文字符 A | 中文道         | emoji:smile:        |
    |------------------+------------+----------------+---------------------|
    | Code Point       |     U+0x41 | U+9053         | U+1F600             |
    | UTF-8 Code Point |       0x41 | 0xE9 0x81 0x93 | 0xF0 0x9F 0x98 0x84 |
    | Byte             |          1 | 3              | 4                   |

    码元是指用于处理和交换编码文本的最小比特组合. eg: 计算机处理字符的最小单位 1
    字节就是一个码元. 通过将 Unicode 标量值和码元序列建立一一映射关系, 就构成了
    码表. 在 Unicode 中一共有 3 种这样的字符编码表: UTF-8, UTF-16 和 UTF-32, 它
    们正好对应了 1 字节, 2 字节和 4 字节的码元. 对于 UTF-16 和 UTF-32 来说, 因为
    它们的码元分别是 2 字节和 4 字节, 所以就得考虑字节节序问题; 而对于 UTF-8 来
    说, 一个码元只有 1 字节, 所以不存在字节序问题, 可以直接存储.

    UTF-8 是以 1 字节为编码单位的可变长编码, 它根据一定的规则将码位编码为 1 ~ 4
    字节, 如下所示:
    | Unicode 范围      | UTF-8 编码(1-4 字节)                |
    |-------------------+-------------------------------------|
    | U+0000 ~ U+-007F  | 0XXXXXXX                            |
    | U+0800 ~ U+07FF   | 110XXXXX 10XXXXXX                   |
    | U+0800 ~ U+FFFF   | 1110XXXX 10XXXXXX 10XXXXXX          |
    | U+10000 ~ U+1FFFF | 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX |

    UTF-8 编码规则大致如下：
    - 当一个字符在 ASCⅡ 码的范围(兼容 ASCⅡ 码)内时, 就用 1 字节表示, 因为 ASC Ⅱ
      码中的字符最多使用 7 个比特位, 所以前面需要补 0.
    - 当一个字符占用了 n 字节时, 第一字节的前 n 位设置为 1, 第 n+1 位 设置为 0,
      后面字节的前 2 位设置为 10.

    以 "道" 举例, 它的码位是 U+9053, 相应的二进制表示为 1001_0000_0101_0011, 按
    上述 UTF-8 编码规则进行编码, 则变为字节序列 1110_1001_10_000001_10_010011,
    用十六进制表示的话, 就是 0xE90x810x93.

    像这种将 Unicode 码位转换为字节序列的过程，　就叫做 *编码(Encode)*; 反过来,
    将编码字节序列转变为字符集中码位的过程, 就叫做 *解码(Decode)*.

    UTF-8 编码的好处就是在实际传输过程中其占据的长度是不固定的, 在保证 Unicode
    通用性的情况下避免了流量和空间的浪费, 而且还保证了传输过程中不会错判字符. 正
    因如此, UTF-8 才能被广泛应用于互联网中.

    
*** 字符
    Rust 使用 char 类型表示单个字符. char 雷神使用整数值与 Unicode 标量值一一对
    应.

    在 Rust 中每个 char 类型的字符都代表一个有效的 u32 类型的整数, 但不是每个
    u32 类型的整数都能代表一个有效的字符. 因为并不是每个整数都属于 Unicode 标量
    值.

    为了能够存储任何 Unicode 标量值, Rust 规定 *每个字符都占 4 字节*.

    将字符串转换为字符串时, 要注意字节长度. 可以通过内建的 ~len_utf8()~ 方法获取
    UTF-8 编码的字节长度.

    *注意*: 只有包含单个 Unicode 标量值(实际码位)的才能被声明为字符(从 Rust 1.3
    版本起, 开始支持多码位字符).

*** 字符串分类
    字符串是由字符组成的有限序列. 字符可以用整数值直接表示 Unicode 标量值, 然而
    字符串却不能, 因为字符串不能确定大小, 所以在 Rust 中字符串是 UTF-8 编码序列.

    出于内存安全的考虑, 在 Rust 中字符串分别为以下几种类型:
    - *str*: 表示固定长度的字符串
    - *String*: 表示可增长的字符串.
    - *CStr*: 表示由 C 分配而被 Rust 借用的字符串, 一般用于和 C 语言交互.
    - *CString*: 表示由 Rust 分配且可以传递给 C 函数使用的 C 字符串, 同样用于和
      C 语言交互
    - *OsStr*: 表示和操作系统相关的字符串. 这是为了兼容 Windows 系统.
    - *OsString*: 表示 OsStr 的可变版本. 与 Rust 字符串可以相互转换.
    - *Path*: 表示路径, 定义于 ~std::path~ 模块中. Path 包装了 OsStr.
    - *PathBuf*: 跟 Path 配对, 是 Path 的可变版本. PathBuf 包装了 OsString.

    但是在 Rust 中最常用的字符串是 str 和 String. 在第 3 章中已经介绍过 str 属于
    动态大小类型(DST), 在编译期并不能确定其大小, 所以在程序中最常见到的是 str 的
    *切片(Slice)* 类型的 &str. &str 代表的是不可变的 UTF-8 字节序列, 创建后无法
    再为其追加内容或更改其内容. &str 类型的字符串可以存储在任意地方:

    - *静态存储区*: 有代表性的是字符串字面量, ~&'static str~ 类型的字符串被直接
      存储到已编译的可执行文件中, 随着程序一起加载启动.
    - *堆分配*: 如果 &str 类型的字符串是通过堆 String 类型的字符串取切片生成的,
      则存储在堆上. 因为 String 类型的字符串是堆分配的, &str 只不过是其在堆上的
      切片.
    - *栈分配*: 比如使用 ~str::from_utf8()~ 方法, 就可以将栈分配的 ~[u8;N]~ 数组
      转换为一个 &str 字符串.

    与 &str 类型相对应的是 String 类型的字符串. &str 是一个引用类型, 而 String
    类型的字符串拥有所有权. String 是由标准库提供的可变字符串, 可以在创建后为其
    追加内容或更改其内容. String 类型本质为一个成员变量是 ~Vec<u8>~ 类型的结构体,
    所以它是直接将字符内容存放于堆中的. *String 类型由 3 部分组成*: 指向堆中的字
    节序列的指针(as_ptr 方法), 记录堆中字节序列的字节长度(len 方法)和堆分配的容
    量(capacity 方法).

*** 字符串的两种处理方式
    Rust 中的字符串不能使用索引访问其中的字符, 因为字符串是 UTF-8 字节序列, 到底
    返回字节还是码点是一个问题. 但是 Rust 提供了 bytes 和 chars 两个方法来分别按
    字节和按字符迭代的迭代器. 所以, 在 Rust 中对字符串的操作大致分为 2 种方式: 
    *按字节处理* 和 *按字符处理*.

    调用 str 的 ~len()~ 方法时, 返回的是字符串的字节长度, 而非字符长度.

    Rust 提供了 ~get()~ 和 ~get_mut()~ 可以通过指定索引范围来获取字符串切片, 并
    且 Rust 默认会检查字符串的序列是否为有效的 UTF-8 序列.

    在使用字符串内建的 ~split_at()~ 和 ~split_at_mut()~ 方法分割字符串时, 需要注
    意: *一定要使用合法的字符串边界索引*, 否则就会引起线程崩溃.

    日常处理字符串时, 要注意是按字节还是按字符进行的, 以避免发生预期之外的错误.

*** 字符串的修改
    一般情况下, 如果要修改字符串, 则使用 String 类型. 修改字符串大致分为: 追加、
    插入、连接、更新和删除 5 种情形.

**** 追加字符串
     对于追加的情形, Rust 提供了 push 和 push_str 两个方法.

     push 和 push_str 在内部实现上其实是类似的, 因为 String 本质是对 ~Vec<u8>~
     动态数组的包装, 所以对于 push 来说, 如果字符是单字节的, 则将字符转换为 u8
     类型直接最佳到 ~Vec<u8>~ 尾部; 如果是多字节的, 则转换为 UTF-8 字节序列, 通
     过 ~Vec<u8>~ 的 ~extend_from_slice~ 方法来扩展 String 类型字符串的内部
     ~Vec<u8>~ 数组.

     除了上面 2 个方法, 也可以通过迭代器为 String 追加字符串, 因为 String 上实现
     了 Extend 迭代器.

**** 插入字符串
     如果想从字符串的某个位置开始插入一段字符串, 则需要使用 insert 和 insert_str
     方法, 其用法和 push/push_str 方法类似.

     *注意*: 这两个方法是基于字节序列的索引进操作的, 其内部实现会通过
     ~is_char_boundary~ 方法来判断插入的位置是否为合法的字符边界, 如果插入的位
     置非法, 则会引发线程崩溃

**** 连接字符串
     String 类型的字符串也实现了 ~Add<&str>~ 和 ~AddAssign<&str>~ 两个 trait, 这
     意味着可以使用 "+" 和 "+=" 操作符来连接字符串.
     
     需要注意的是: 操作符右边的字符串为切片类型(~&str~). ~&String~ 类型因为
     String 类型实现了 *Deref* trait, 所以执行加法操作自动解引用为 ~&str~ 类型.

**** 更新字符串
     因为 Rust 不支持直接按索引操作字符串中的字符, 一些常规的算法在 Rust 中必然
     无法使用. eg: 想修改某个字符串中符合条件的字符为大写, 就无法直接通过索引来
     操作, 只能通过迭代器的方式或者某些 unsafe 方法.

**** 删除字符串
     ~remove~. ~truncate~ 方法使用时需要注意: 此类方法是按字节操作, 可能引发线程
     崩溃

*** 字符串的查找
    在 Rust 标准库中 *并没有* 提供正则表达式的支持, 这是因为正则表达式算是外部
    DSL, 如果直接将其引入标准库中, 则会破坏 Rust 的一致性. 因为线程的正则表达式
    引擎都是其他语言实现的, eg: C 语言. 除非完全使用 Rust 来实现. 目前 Rust 支持
    的正则表达式引擎是官方实现的第三方包 *regex*, 未来是否会归为标准库中, 不得而
    知. 虽然 Rust 在标准库中不提供正则表达式支持, 但它提供了另外的字符串匹配功能
    供开发者使用, 一共包含 20 个方法.

    这 20 个方法涵盖了以下几种字符串匹配操作:
    - *存在性判断*: ~contains~, ~starts_with~, ~ends_with~.
    - *位置匹配*: ~find~, ~rfind~
    - *分割字符串*: ~split~, ~rsplit~, ~split_terminator~, ~rsplit_terminator~,
      ~splitn~, ~rsplitn~.
    - *捕获匹配*: ~matches~, ~rmatches~, ~match_indices~, ~rmatch_indices~.
    - *删除匹配*: ~trim_matches~, ~trim_left_matches~, ~trim_right_matches~.
    - *替代匹配*: ~replace~, ~replacen~

**** 存在性判断
     ~contains~ 返回 bool 类型

     ~std::str~ 模块中 ~contains~ 方法源码:
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       #[inline]
       // 参数限定为 `Pattern<'a>`
       pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {
           pat.is_contained_in(self)
       }
     #+end_src
     
     ~Pattern<'a>~ 是一个专门用于搜索 ~&'a str~ 字符串的模式 trait. Rust 中的
     ~char~ 类型, ~String~, ~&str~, ~&&str~, ~&[char]~ 类型, 以及 ~FnMut(char)
     -> bool~ 的闭包均已经实现了该 trait. 因此, ~contains~ 才可以接收不同类型的
     值作为参数.

     ~starts_with~ 和 ~ends_with~ 与 ~contains~ 一样, 也可以接收实现了
     ~Pattern<'a>~ 的类型作为参数. 为了方便描述, 暂且称这种参数为 ~pattern~ 参
     数. ~starts_with~ 和 ~ends_with~ 分别用于判断指定的 ~pattern~ 参数是否为字
     符串的起始边界和结束边界.

**** 位置匹配
     如果想查找指定字符串中字符所在的位置, 则可以使用 ~find~ 方法
     ~find~ 方法默认是从左向右按字符进行遍历查找的, 最终返回 ~Option<usize>~ 类
     型的位置索引, ~rfind~ 表示从右向左来匹配.

**** 分割字符串
     如果想通过指定的模式来分割字符串, 则可以使用 ~split~ 系列方法.

     ~splitn~ 的第一个参数代表分割的数组长度.

     ~split_terminator~ 会把分割结果数组最后一位的空字符串去掉.(仅去掉最后, 不去
     掉起始: [[https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=8bcdbceb5973c8190a88f17917879e06][PLayground]])

     
**** 捕获匹配
     通常通过正则表达式来完成在字符串中匹配符合条件的字符.
     在 Rust 中, 通过 ~pattern~ 参数配合 ~matches~ 系列方法可以获得同样的效果.

     ~match_indices~ 方法返回的结果是元组数组, 其中元组的第一个元素代表匹配字符
     的位置索引.

     从方法的命名来看, indices 为 index 的复数形式, 在语义上就指名了匹配结果会包
     含索引. 在标准库中有不少以 "_indices" 结尾的方法名, 在语义上都表明其返回值
     会包含索引.

**** 删除匹配
     在 ~std::str~ 模块中提供了 ~trim~ 系列方法, 可以删除字符串两头的指定字符.

     ~trim~ 系列方法可以删除字符串两头的空格, 制表符(\t) 和换行符(\n).

     Rust 还提供了 ~trim_matches~ 系列方法, 支持 ~pattern~ 参数, 可以指定自定义
     的删除规则.

**** 替代匹配
     使用 ~trim_matches~ 系列方法可以满足基本的字符串删除匹配要求, 但是其质量去
     除字符串两头的字符, 无法去除字符串内部包含的字符. 可以通过 ~replace~ 系列方
     法来实现此需求.

**** 字符串的匹配模式原理
     Rust 提供的这些字符串匹配方法看似繁多, 但实际上其背后是一套统一的迭代器适配
     器. 我们从 ~matches~ 方法说起:

     ~matches~ 方法源码
     #+begin_src rust
       #[stable(feature = "str_matches", since = "1.2.0")]
       #[inline]
       pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {
           Matches(MatchesInternal(pat.into_searcher(self)))
       }
     #+end_src

     该方法返回的是 ~Matches<'a, P>~ 类型, 它是一个结构体, 也是一个迭代器.
     源码如下:
     #+begin_src rust
       // generate_pattern_iterators! {
       //     forward:
       //     /// Created with the method [`matches`].
       //     ///
       //     /// [`matches`]: str::matches
       //     struct Matches;
       //     reverse:
       //     /// Created with the method [`rmatches`].
       //     ///
       //     /// [`rmatches`]: str::rmatches
       //     struct RMatches;
       //     stability:
       //     #[stable(feature = "str_matches", since = "1.2.0")]
       //     internal:
       //     MatchesInternal yielding (&'a str);
       //     delegate double ended;
       // }

       struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);
       // 通过以上宏生成
       pub struct Matches<'a, P: Pattern<'a>>(MatchesInternal<'a, P>);
       impl<'a, P: Pattern<'a>> Iterator for Matches<'a, P> {
           type Item = &'a str;
           fn next(&mut self) -> Option<&'a str> {
               self.0.next()
           }
       }
     #+end_src
     
     ~Matches~ 结构体是一个元组结构体, 也就是 NewType 模式, 它包装了
     ~MatchesInternal~ 结构体. 为 ~Matches~ 实现了 ~Iterator~, 它就成为迭代器.
     在 ~next~ 方法中, 它又调用了 ~MatchesInternal~ 结构体的 ~next~ 方法.

     ~MatchesInternal~ 实现 ~next~ 和 ~next_back~ 方法的源码:
     #+begin_src rust
       impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {
           #[inline]
           fn next(&mut self) -> Option<&'a str> {
               // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.
               self.0.next_match().map(|(a, b)| unsafe {
                   // Indices are known to be on utf8 boundaries
                   self.0.haystack().get_unchecked(a..b)
               })
           }

           #[inline]
           fn next_back(&mut self) -> Option<&'a str>
           where
               P::Searcher: ReverseSearcher<'a>,
           {
               // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.
               self.0.next_match_back().map(|(a, b)| unsafe {
                   // Indices are known to be on utf8 boundaries
                   self.0.haystack().get_unchecked(a..b)
               })
           }
       }
     #+end_src

     ~MatchesInternal~ 也是一个 NewType 模式的结构体, 它包装了 ~P::Searcher~. 其
     中 ~next~ 和 ~next_back~ 方法内部分别调用了 ~P::Searcher~ 的 ~next_match~
     和 ~next_match_back~ 方法, 最终返回 ~Map~ 迭代器供将来 ~collect~ 使用.

     注意 ~Pattern<'a>~, 这个 trait 实际上是字符串匹配算法的抽象.

     ~Pattern<'a>~ 和 ~SearchStep~ 定义:
     #+begin_src rust
       #[derive(Copy, Clone, Eq, PartialEq, Debug)]
       pub enum SearchStep {
           // 代表匹配到的索引范围: hasystack[0..3]
           Match(usize, usize),
           // 代表未匹配到的索引范围
           Reject(usize, usize),
           // 代表匹配完毕
           Done,
       }

       pub trait Pattern<'a>: Sized {
           type Searcher: Searcher<'a>;

           // 通过 `into_searcher` 方法得到具体的搜索类型
           // `haystack` 为原字符串
           fn into_searcher(self, haystack: &'a str) -> Self::Searcher;

           #[inline]
           // 用于判断 `needle` 串是否包含在 `haystack` 串中
           fn is_contained_in(self, haystack: &'a str) -> bool {
               self.into_searcher(haystack).next_match().is_some()
           }

           #[inline]
           // 前缀: 除最后一个字符之外的其余字符的组合
           fn is_prefix_of(self, haystack: &'a str) -> bool {
               matches!(self.into_searcher(haystack).next(), SearchStep::Match(0, _))
           }

           #[inline]
           // 后缀: 除最后一个字符串之外的全部尾部字符的组合
           fn is_suffix_of(self, haystack: &'a str) -> bool
           where
               Self::Searcher: ReverseSearcher<'a>,
           {
               matches!(self.into_searcher(haystack).next_back(), SearchStep::Match(_, j) if haystack.len() == j)
           }
       }
     #+end_src

     通常 haystack 代表原字符串, needle 代表子串.

     在 KMP 算法中, 前缀和后缀用于产生部分匹配表, 而在 Rust 中这里使用的字符匹配
     算法并非 KMP, 而是它的变种 *双向(Two-Way)字符串匹配算法*, 该算法的优势在于
     拥有常量级的空间复杂度. 它和 KMP 的共同点在于其时间复杂度也是 O(n), 并且都
     用到了前缀和后缀的概念.

     ~Searcher<'a>~ 源码:
     #+begin_src rust
       pub unsafe trait Searcher<'a> {
           // 用于传递 `haystack` 串
           fn haystack(&self) -> &'a str;

           // 用于返回 `SearchStep`
           // eg: needle: "aaaa", haystack: "abaaaaab"
           // 此时 next 方法可以nadao: [Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]
           fn next(&mut self) -> SearchStep;

           #[inline]
           // 用于匹配 `SearchStep` 来返回最终匹配的索引范围
           fn next_match(&mut self) -> Option<(usize, usize)> {
               loop {
                   match self.next() {
                       SearchStep::Match(a, b) => return Some((a, b)),
                       SearchStep::Done => return None,
                       _ => continue,
                   }
               }
           }

           #[inline]
           // 用于匹配 `SearchStep` 来返回最终未匹配的索引范围
           fn next_reject(&mut self) -> Option<(usize, usize)> {
               loop {
                   match self.next() {
                       SearchStep::Reject(a, b) => return Some((a, b)),
                       SearchStep::Done => return None,
                       _ => continue,
                   }
               }
           }
       }
     #+end_src
     
     该 ~Searcher<'a>~ 类似于迭代器, 包含了 4 个方法.

     为 ~&'a str~ 类型实现 ~Pattern<'a>~ 的源码:
     #+begin_src rust
       impl<'a, 'b> Pattern<'a> for &'b str {
           type Searcher = StrSearcher<'a, 'b>;

           #[inline]
           // 生成用于匹配 `&'a str` 类型字符串的搜索类型
           fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> {
               StrSearcher::new(haystack, self)
           }

           #[inline]
           fn is_prefix_of(self, haystack: &'a str) -> bool {
               haystack.as_bytes().starts_with(self.as_bytes())
           }

           #[inline]
           fn is_suffix_of(self, haystack: &'a str) -> bool {
               haystack.as_bytes().ends_with(self.as_bytes())
           }
       }

       #[derive(Clone, Debug)]
       /// Associated type for `<&str as Pattern<'a>>::Searcher`.
       pub struct StrSearcher<'a, 'b> {
           // 原字符串
           haystack: &'a str,
           // 子串
           needle: &'b str,

           // 枚举体
           searcher: StrSearcherImpl,
       }

       #[derive(Clone, Debug)]
       enum StrSearcherImpl {
           // 空字符串情况
           Empty(EmptyNeedle),
           // 非空字符串情况
           // `TwoWaySearcher` 即为 *双向字符串匹配算法的具体实现*
           TwoWay(TwoWaySearcher),
       }


       unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b> {
           #[inline]
           fn haystack(&self) -> &'a str {
               self.haystack
           }

           #[inline]
           fn next(&mut self) -> SearchStep {
               match self.searcher {
                   StrSearcherImpl::Empty(ref mut searcher) => {
                       // empty needle rejects every char and matches every empty string between them
                       let is_match = searcher.is_match_fw;
                       searcher.is_match_fw = !searcher.is_match_fw;
                       let pos = searcher.position;
                       match self.haystack[pos..].chars().next() {
                           _ if is_match => SearchStep::Match(pos, pos),
                           None => SearchStep::Done,
                           Some(ch) => {
                               searcher.position += ch.len_utf8();
                               SearchStep::Reject(pos, searcher.position)
                           }
                       }
                   }
                   StrSearcherImpl::TwoWay(ref mut searcher) => {
                       // TwoWaySearcher produces valid *Match* indices that split at char boundaries
                       // as long as it does correct matching and that haystack and needle are
                       // valid UTF-8
                       // *Rejects* from the algorithm can fall on any indices, but we will walk them
                       // manually to the next character boundary, so that they are utf-8 safe.
                       if searcher.position == self.haystack.len() {
                           return SearchStep::Done;
                       }
                       let is_long = searcher.memory == usize::MAX;
                       match searcher.next::<RejectAndMatch>(
                           self.haystack.as_bytes(),
                           self.needle.as_bytes(),
                           is_long,
                       ) {
                           SearchStep::Reject(a, mut b) => {
                               // skip to next char boundary
                               while !self.haystack.is_char_boundary(b) {
                                   b += 1;
                               }
                               searcher.position = cmp::max(b, searcher.position);
                               SearchStep::Reject(a, b)
                           }
                           otherwise => otherwise,
                       }
                   }
               }
           }

           #[inline]
           fn next_match(&mut self) -> Option<(usize, usize)> {
               match self.searcher {
                   StrSearcherImpl::Empty(..) => loop {
                       match self.next() {
                           SearchStep::Match(a, b) => return Some((a, b)),
                           SearchStep::Done => return None,
                           SearchStep::Reject(..) => {}
                       }
                   },
                   StrSearcherImpl::TwoWay(ref mut searcher) => {
                       let is_long = searcher.memory == usize::MAX;
                       // write out `true` and `false` cases to encourage the compiler
                       // to specialize the two cases separately.
                       if is_long {
                           searcher.next::<MatchOnly>(
                               self.haystack.as_bytes(),
                               self.needle.as_bytes(),
                               true,
                           )
                       } else {
                           searcher.next::<MatchOnly>(
                               self.haystack.as_bytes(),
                               self.needle.as_bytes(),
                               false,
                           )
                       }
                   }
               }
           }
       }
     #+end_src

     以上就是 *字符串匹配算法的背后机制*, 使用 ~Pattern<'a>~, ~Searcher<'a>~ 和
     ~SearchStep~ 来抽象字符串匹配算法, 然后 *利用迭代器模式* 进行检索. 这里也是
     Rust 一致性的体现.

*** 与其他类型相互转换
**** 将字符串转换为其他类型
     可以通过 ~std::str~ 模块中提供的 ~parse~ 泛型方法来将字符串转换为指定的类型.
     
     ~parse~ 方法为泛型方法, 使用时需要指定类型, 可以使用 turbofish 操作符.

     ~parse~ 方法内部是使用 ~FromStr::from_str~ 方法来实现转换的. ~FromStr~ 是一
     个 trait, 其命名符合 Rust 的一致性惯例.

     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       pub trait FromStr: Sized {
           #[stable(feature = "rust1", since = "1.0.0")]
           type Err;

           #[stable(feature = "rust1", since = "1.0.0")]
           fn from_str(s: &str) -> Result<Self, Self::Err>;
       }
     #+end_src

     该方法在解析失败时返回 ~Err~. Rust 为一些基本的原生类型, 布尔类型以及 IP 地
     址等少数类型实现了 ~FromStr~, 对于自定义的类型需要自己手工实现.
**** 将其他类型转换为字符串
     如果想把其他类型转换为字符串, 则可以使用 ~format!~ 宏. 该宏与 ~println!~ 及
     ~write!~ 宏类似, 同样可以通过格式化规则来生成 ~String~ 类型的字符串.

     ~format!~ 格式化规则:
     - *填充字符串宽度*: 格式: ~{:number}~, number 表示数字. 如果 number 的长度
       大于字符串长度, 则会默认填充空格来扩展字符串的长度.
     - *截取字符串*: 格式: ~{:.number}~, number 代表要截取的字符长度, 也可以和填
       充格式配合使用
     - *对齐字符串*: 格式为: ~{:>}~, ~{:^}~ 和 ~{:<}~, 分别表示左对齐, 位于中间
       和右对齐.

     ~format~ 格式化字符串实现按字符处理的, 不管字符串多长, 对于你们的 Unicode
     码位都会以单个字符位来处理.  

     除满足上述格式化规则之外, Rust 还提供了专门针对整数和浮点数的格式化代码.

     针对整数提供的格式化代码规则:
     - *符号+*: 表示强制输出整数的正负符号
     - *符号#*: 用于显示进制的前缀. eg: 16 进制显示 0x, 二进制显示 0b
     - *数字 0*: 用于把默认的空格替换为数字 0

     针对浮点数时, 某些格式化代码又表示不同的含义:
     - 指定小数点后的有效位: 符号 "~.~" 代表的是指定浮点数小数点后的有效位. 注
       意: 在指定有效位时会四舍五入.
     - 科学计数法: 使用 ~{:e}~ 可以将浮点数格式化为科学计数法的形式

     *以上所有的格式化规则, 对 ~println!~ 和 ~write!~ 宏均适用*.

     如果要对自定义类型格式化, 则需要实现 Display trait.

     实现 ~fmt~ 方法即可通过 ~format~ 宏根据该结构体实例生成字符串.

*** 回顾
    小例子回顾内容: 求出对角线位置的所有数字之和.
    #+begin_example
      1234
      5678
      9876
      4321



      1 + 6 + 7 + 1 + 4 + 7 + 8 + 4
    #+end_example

    使用原生字符串声明语法(r"...")可以将此数字方阵定义为字符串, 然后按行遍历其字
    符即可得到结果.

    原生字符串声明语法可以 *保留原来字符串中的特殊符号*.

** 集合类型
   Rust 标准库中提供的集合类型包括以下几种:
   - ~Vec<T>~: 动态可增长数组
   - ~VecDeque<T>~: 基于环形缓冲区的先进先出(FIFO)双端队列实现
   - ~LinkedList<T>~: 双向链表实现
   - ~BinaryHeap<T>~: 二叉堆(最大堆)实现, 可用作优先队列
   - ~HashSet<T>~: 无序集合实现
   - ~BTreeSet<T>~: 基于 B 树的有序集合实现

   以上最常用的集合类型为 ~Vec<T>~ 和 ~HashMap<K, V>~, 接下来主要介绍这两种集合
   类型

*** 动态可增长数组
    Rust 中数组有两种类型:  一种是原生类型 array, 它拥有固定的长度, 类型签名为
    ~[T;N]~; 另一种是动态可增长数组 Vector, 它是可增长的动态数组, 类型签名为
    ~Vec<T>~, 在运行时才可知道大小. array 和 Vector 的区别在于, array 中的元素可
    以在栈上存储; 而 Vector 中的元素只能在堆上分配. 本章着重介绍动态可增长数组
    Vector.
    
**** 基本操作与内存分配
     创建 ~Vector~ 和创建 ~String~ 类型字符串的方法很相似, 因为 ~String~ 类型的
     字符串本身就是对 ~Vec<u8>~ 类型的包装.

     使用 ~Vec::new()~ 时, 创建了一个可变的 ~Vector~ 空数组, 实际上未分配堆内存.
     如果整个函数都未为其填充元素, 则编译器认定为未初始化内存, 报错.

     从 ~pop()~ 弹出方法可以看出, ~Vector~ 数组天生就可以作为先进后出(FILO)的栈
     结构使用.

     ~truncate()~ 方法可以截断索引后的元素.

     ~shrink_to_fit()~ 方法相当于重新分配堆内存以适应当前元素内容.

     日常编程中, 使用 ~Vec::with_capacity~ 方法来创建 ~Vector~ 数组可以有效地避
     免频繁申请堆内存带来的性能损耗.

     有些类型在 Rust 中是不占直接的, 属于零大小类型(ZST).
     
     ~Vec::new()~ 初始化了一个 ~Vector~ 空数组. 本质属于一种智能指针, 跟
     ~String~ 一样也由三部分组成: 
     - 指向堆中字节序列的指针(~as_ptr~ 方法)
     - 记录堆中字节序列的字节长度(~len~ 方法)
     - 堆分配的容量(~capacity~ 方法).

     针对插入 ZST 类型的元素, 容量会等于 ~std::usize::MAX~, 这是 Rust 内部实现的
     一个技巧, 用一个实际不可能分配的最大值来表示 ZST 的容量. 所以可以放心地使用
     ~Vector~, 而不必担心内存分配会带来任何不安全的问题.

**** 查找与排序
     数组也支持字符串中提供的一些查找方法: eg: ~contains~, ~starts_with~ 和
     ~ends_with~ 方法.
     
     以上三种方法都是泛型方法. 它们有一个共同的 trait 限定: ~PartialEq<T>~, 该
     trait 定义了一些方法用于判断等价关系, 本章后面会有详细介绍. ~contains~ 只能
     接受引用类型, ~starts_with~ 和 ~ends_with~ 接受的是数组切片类型.

     除以上方法之外, 标准库中还提供了 ~binary_search~ 系列泛型方法来帮助开发者方
     便地检索数组中的元素.

     ~binary_search~ 方法又叫作二分查找或折半查找方法, 基本要求是待查找的数组必
     须是有序的, 该算法的平均时间复杂度为 O(logn), 空间复杂度用迭代实现, 所以是
     O(1).
     
     该方法参数为一个引用类型, 且该参数类型 *必须实现 Ord*. Ord trait 抽象了比较
     操作, 本章后面会有详细介绍. 返回 ~Result~ 类型的索引值.

     ~binary_search_by~ 方法的参数是一个 ~FnMut(&'a T) -> Ordering~ 闭包.
     ~Ordering~ 是一个枚举类型, 记录的是三种比较结果: 小于(Less), 等于(Equal) 和
     大于(Greater). 

     ~binary_search_by_key~ 方法接受的是 ~FnMut(&'a T) -> B~ 闭包, 其中 B 对应于
     参数的类型 (~&B~), 相比于上一种方法, 该方法的闭包参数覆盖范围比较广, 相当于
     开发者可以指定任意检索条件.

     ~binary_search~ 系列泛型方法前置要求为有序数组, 对于没有排序的数组, 可以使
     用 ~sort~ 和 ~sort_unstable~ 系列方法.

     ~sort~, ~sort_by~ 和 ~sort_by_key~ 方法内部所用的算法为自适应迭代归并排序
     (Adaptive/Iterative Merge Sort)算法, 灵感来自 Python 语言中的 TimSort 算法.
     该算法为稳定排序算法, 即: 序列中等价的元素在排序之后相对位置并不改变, 其时
     间复杂度为 O(n), 最坏情况为 O(nlogn).

     以上 ~sort~ 系列方法均可被直接替换为 ~sort_unstable~, ~sort_unstable_by~ 和
     ~sort_unstable_by_key~ 方法. 但是 ~sort_unstable~ 系列方法其内部实现的排序
     算法为模式消除快速排序(Pattern-Defeating Quicksort)算法, 该算法为不稳定排序
     算法, 也就是说, 序列中等价的元素在 *排序之后相对位置有可能发生变化*. 其时间
     复杂度为 O(n), 最坏情况为 O(nlogn). 在不考虑稳定性的情况下, 推荐使用
     ~sort_unstable~ 系列方法, 其性能要高于 sort 系列方法, 因为它们不会占用额外
     的内存.

     不管是 ~sort~ 系列方法还是 ~sort_unstable~ 系列方法, 其命名规则和
     ~binary_search~ 系列方法相类似, 所以他们在语义上也是相同的, xxxx_by 方法表
     示接收返回 ~Ordering~ 类型的闭包参数; 而 xxxx_by_key 方法接收的闭包参数覆盖
     范围更广, 适合表示任意检索(排序)条件.
     
**** 与排序和比较相关的 trait
     在上面介绍的诸多数组方法中, 其实都涉及数组内部元素的比较, eg: 判断是否存在、
     检索和排序都必须要在元素间进行比较. 在 Rust 中把比较操作也抽象为一些 trait,
     定义在 ~std::cmd~ 模块中. 该模块中定义的 trait 是基于数学集合论中的二元关系
     偏序、全序和等价的.

     *偏序* 的定义, 对于非空集合中的 a、b、c 来说, 满足下面条件为偏序关系
     - 自反性: a≤a
     - 反对称性: 如果 a≤b 且 b≤a, 则 a=b
     - 传递性: 若 a≤b 且 b≤c, 则 a≤c
     - 完全性: a<b, b<a 或 a==b 必须满足其一, 表示任何元素都可以相互比较

     *全序* 实际上是一种特殊的偏序:
     等价的定义, 对于非空集合中的 a、b、c 来说, 满足下面条件为等价关系
     - 自反性: a==b
     - 对称性: a==b, 意味着 b==a
     - 传递性: 若 a==b 且 b==c, 则 a==c

     在 Rust 中一共涉及 4 个 trait 和一个枚举体来表示上述二元关系. 4 个 trait 分
     别是 ~PartialEq~, ~Eq~, ~PartialOld~ 和 ~Ord~. 这些 trait 的关系可以总结为以
     下几点:
    
     - ~PartialEq~ 代表部分等价关系, 其中定义了 ~eq~ 和 ~ne~ 两个方法, 分别表示 == 和 != 操作
     - ~Eq~ 代表等价关系, 该 trait 继承自 ~PartialEq~, 但是其中没有定义任何方法.
       它实际上相当于标记实现了 ~Eq~ 的类型拥有等价关系.
     - ~PartialOrd~ 对应于偏序, 其中定义了 ~partial_cmp~, ~lt~, ~le~, ~gt~ 和
       ~ge~ 五个方法
     - ~Ord~ 对应于全序, 其中定义了 ~cmp~, ~max~ 和 ~min~ 三个方法.

     还有一个枚举体为 ~Ordering~, 用于表示比较结果, 其中定义了小于, 等于和大于三
     种状态.

     ~PartialEq~ 和 ~Eq~ 的定义
     #+begin_src rust
       #[lang = "eq"]
       #[stable(feature = "rust1", since = "1.0.0")]
       #[doc(alias = "==")]
       #[doc(alias = "!=")]
       #[rustc_on_unimplemented(
           message = "can't compare `{Self}` with `{Rhs}`",
           label = "no implementation for `{Self} == {Rhs}`"
       )]
       pub trait PartialEq<Rhs: ?Sized = Self> {
           #[must_use]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn eq(&self, other: &Rhs) -> bool;

           #[inline]
           #[must_use]
           #[stable(feature = "rust1", since = "1.0.0")]
           // `ne` 有默认实现
           fn ne(&self, other: &Rhs) -> bool {
               !self.eq(other)
           }
       }

       #[doc(alias = "==")]
       #[doc(alias = "!=")]
       #[stable(feature = "rust1", since = "1.0.0")]
       // 仅标记, 无实际方法
       pub trait Eq: PartialEq<Self> {
           #[doc(hidden)]
           #[inline]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn assert_receiver_is_total_eq(&self) {}
       }
     #+end_src

     ~PartialOrd~ 定义
     #+begin_src rust
       #[lang = "partial_ord"]
       #[stable(feature = "rust1", since = "1.0.0")]
       #[doc(alias = ">")]
       #[doc(alias = "<")]
       #[doc(alias = "<=")]
       #[doc(alias = ">=")]
       #[rustc_on_unimplemented(
           message = "can't compare `{Self}` with `{Rhs}`",
           label = "no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`"
       )]
       pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {
           #[must_use]
           #[stable(feature = "rust1", since = "1.0.0")]
           // 表示具体的比较规则, 注意返回类型
           // 对于偏序的比较来说, 并不是所有元素都具有可比性, 有些元素的比较结果可能为 `None`
           // 如果要给某个类型实现 `PatrialOrd`, 只需要实现此方法即可
           fn partial_cmp(&self, other: &Rhs) -> Option<Ordering>;

           #[inline]
           #[must_use]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn lt(&self, other: &Rhs) -> bool {
               matches!(self.partial_cmp(other), Some(Less))
           }

           #[inline]
           #[must_use]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn le(&self, other: &Rhs) -> bool {
               matches!(self.partial_cmp(other), Some(Less | Equal))
           }

           #[inline]
           #[must_use]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn gt(&self, other: &Rhs) -> bool {
               matches!(self.partial_cmp(other), Some(Greater))
           }

           #[inline]
           #[must_use]
           #[stable(feature = "rust1", since = "1.0.0")]
           fn ge(&self, other: &Rhs) -> bool {
               matches!(self.partial_cmp(other), Some(Greater | Equal))
           }
       }

       #[derive(Clone, Copy, PartialEq, Debug, Hash)]
       #[stable(feature = "rust1", since = "1.0.0")]
       pub enum Ordering {
           #[stable(feature = "rust1", since = "1.0.0")]
           Less = -1,
           #[stable(feature = "rust1", since = "1.0.0")]
           Equal = 0,
           #[stable(feature = "rust1", since = "1.0.0")]
           Greater = 1,
       }
     #+end_src
    
     ~Ord~ 定义:
     #+begin_src rust
       #[doc(alias = "<")]
       #[doc(alias = ">")]
       #[doc(alias = "<=")]
       #[doc(alias = ">=")]
       #[stable(feature = "rust1", since = "1.0.0")]
       // 继承自: `Eq` 和 `PartialOrd`, 这是因为全序的比较必须满足三个条件:
       // 反对称性, 传递性和完全性, 其中完全性一定是每个元素都可以相互比较
       // eg: 浮点数中用于定义特殊情况值而使用的 `NaN`, 其本身就不可比较, 因为 `NaN != NaN`, 它不满足全序的完全性
       // 所以浮点数只能实现 `PartialEq` 和 `PartialOrd`, 而不能实现 `Ord`
       // 如果要实现 `Ord`, 只需要实现 `cmp` 方法即可. 因为 `max` 和 `min` 都有没咯嗯实现
       pub trait Ord: Eq + PartialOrd<Self> {
           #[must_use]
           #[stable(feature = "rust1", since = "1.0.0")]
           // 注意: 返回的不是 `Option<Ordering>` 类型
           // 因为对于全序关系来说, 每个元素都是可以获得合法的比较结果的
           fn cmp(&self, other: &Self) -> Ordering;

           #[stable(feature = "ord_max_min", since = "1.21.0")]
           #[inline]
           #[must_use]
           fn max(self, other: Self) -> Self
           where
               Self: Sized,
           {
               max_by(self, other, Ord::cmp)
           }

           #[stable(feature = "ord_max_min", since = "1.21.0")]
               #[inline]
               #[must_use]
           fn min(self, other: Self) -> Self
           where
               Self: Sized,
           {
               min_by(self, other, Ord::cmp)
           }

           #[must_use]
               #[unstable(feature = "clamp", issue = "44095")]
           fn clamp(self, min: Self, max: Self) -> Self
           where
               Self: Sized,
           {
               assert!(min <= max);
               if self < min {
                   min
               } else if self > max {
                   max
               } else {
                   self
               }
           }
       }
     #+end_src

     如果要在自定义类型中实现相关 trait, 则必须搞清楚全序和偏序关系, 然后再实现相
     应地 trait. 可以手工实现, 也可以使用 ~#[derive]~ 来自动派生.

**** 回顾与展望
     本节虽然重点介绍的是 ~Vector~, 但是里面涉及的方法同样适用于 array. 因为这些
     方法实际上是为 ~[T]~ 类型实现的.

     当然, array 也有自己专用的方法. eg: 连接两个 array 可以使用 ~join~ 方法. 在
     标准库中还为数组提供了很多其他方法.

     在 Rust 2018 中, 还加入了针对 array 数组和切片进行 match 匹配的新语法.

*** 映射集
    在日常编程中, 另一个常用的数组结构非 *映射集(Map)* 莫属. Map 是依照键值对
    (Key-Value)形式存储的数据结构, 每个键值对都被称为一个 *Entry*. 在 Map 中不能
    存在重复的 Key, 并且每个 Key 必须有一个一一对应的值. Map 提供的查找、插入和
    删除操作的时间复杂度基本都是 O(1), 最坏情况也只是 O(n), 虽然需要消耗额外的空
    间, 但是随着当下可利用的内存越来越多, 这种用空间换时间的做法也是值得的. Rust
    提供了两种类型的 Map: 基于哈希表(HashTable)的 *HashMap* 和基于多路平衡查找树
    (B-Tree)的 *BTreeMap*. 本节主要介绍 HashMap.

**** HashMap 的增删改查
     通过 ~keys()~ 和 ~values()~ 方法可以分别单独获取 ~HashMap~ 中的键和值, 注意
     这两个方法是迭代器. 因为 ~HashMap~ 是无序的映射表, 所以在迭代键和值的时候,
     输出的顺序并不一定和插入的顺序相同.

     通过 Index 优化可以按指定的键来获取对应的值. 需要注意的是: 只支持 Index, 而
     不支持 IndexMut. 也就是说, 只可以通过 ~hash[key]~ 方式来取值, 而不能通过
     ~hash[key]=value~ 方式来插入键值对, 这是因为针对该特性正在准备一个更好的设
     计方案, 并在不远的将来得到支持.
          
**** Entry 模式
     对于 ~HashMap~ 中的单个桶(Bucket) 来说, 其状态无非是 "空" 和 "满", 所以
     Rust 对此做了一层抽象, 使用 Entry 枚举体来表示每个键值对:
     ~Entry~ 定义:
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       pub enum Entry<'a, K: 'a, V: 'a> {
           #[stable(feature = "rust1", since = "1.0.0")]
           // 代表占用
           Occupied(#[stable(feature = "rust1", since = "1.0.0")] OccupiedEntry<'a, K, V>),

           // 代表留空
           #[stable(feature = "rust1", since = "1.0.0")]
           Vacant(#[stable(feature = "rust1", since = "1.0.0")] VacantEntry<'a, K, V>),
       }
     #+end_src

     调用 ~entry()~ 方法传入参数后, 首先会判断哈希表是否有足够的空间, 如果没有,
     则自动进行扩容. 接下来调用内部的 ~hash()~ 函数生成此键的 hash 值, 然后通过
     这个 hash 值在底层中的哈希表中搜索. 若能找到, 返回相应的桶(~Occupied~), 否
     则返回空桶(~Vacant~). 最后, 将得到的桶转换为 ~Entry<K, V>~ 并返回.

     在得到 ~Entry~ 之后, 就可以调用其实现的 ~or_insert()~ 方法, 该方法的参数就
     是要插入的值, 并且返回该值得 *可变借用*. 此时可以用解引用操作符进行修改.

     使用 ~or_insert_with()~ 方法可以传递一个可计算的闭包作为要插入的值. 
     *注意*: 其只允许传入 ~FnOnce() -> V~ 的闭包, 也就是说, 闭包不能包含参数.

     ~or_insert()~ 方法源码:
     #+begin_src rust
       pub fn or_insert(self, default: V) -> &'a mut V {
           match self {
               // 该方法将其变为可变引用
               Occupied(entry) => entry.into_mut(),
               Vacant(entry) => entry.insert(default),
           }
       }
     #+end_src

**** 合并 HashMap
     通过 ~extend~ 方法合并两个 ~HashMap~ 时, 本质上, ~extend~ 方法内部也将
     ~HashMap~ 转换为迭代器进行操作.

**** HashMap 底层实现原理
     不管哪门语言, 实现一个 ~HashMap~ 的过程均可以分为三大步骤:
     1. 实现一个 Hash 函数
     2. 合理地解决 Hash 冲突
     3. 实现 HashMap 的操作方法

     ~HashMap~ 的底层实际上是基于数组来存储的, 当插入键值对时, 并不是直接插入该
     数组中, 而是通过对键进行 Hash 运算得到 Hash 值, 然后和数组的容量(Capacity)
     取模, 得到具体的位置后再插入的.
     #+begin_example
       map.entry("year").or_insert(2017);




       "year" -> (Hash Function) -> hash("year") % Capaticy
                                             ↓
                         -------------------(k,v)------------------- Buckets
                         |               Capacity                   |
     #+end_example

     从 ~HashMap~ 中取值的过程与之相似, 对指定的键求得 Hash 值, 再和容量取模之后
     就能得到底层数组对应的索引位置, 如果指定的键和存储的键相匹配, 则返回该键值
     对; 如果不匹配, 则代表没有找到对应的键.

     在整个过程中最重要的是 *Hash 函数*. 一个好的 Hash 函数不仅性能优越, 而且还
     会让存储于底层数组中的值分布地更加均匀, 减少冲突的发生. 简单来说, Hash 函数
     相当于把原来的数据映射到一个比它更小的空间中, 所以冲突是无法避免的, 可以做
     的只能是减少 Hash 碰撞发生的概率. 一个好的 Hash 函数增强了映射的随机性, 所
     以碰撞的概率会降低.

     *Hash 碰撞(Hash Collistion)* 也叫 Hash 冲突, 是指两个元素通过 Hash 函数得到
     了相同的索引地址, 该存储哪一个是需要解决的问题, 而这两个元素就叫做同义词.
     除 Hash 函数的好坏之外, Hash 冲突还取决于 *负载因子(Load Factor)* 这个因素.
     负载因子是存储的键值对数目与容量的比例, eg: 容量为 100, 存储了 90 个键值对,
     负载因子就是 0.9. 负载因子决定了 ~HashMap~ 什么时候扩容, 如果它的值太大了,
     则说明存储的键值对接近容量, 增加了冲突的风险; 如果值太小了, 则浪费空间. 所
     以, 单靠 Hash 函数和负载因子是不行的, 还需要有另外解决冲突的方法.

     Rust 标准库实现的 ~HashMap~, 默认的 Hash 函数算法是 SipHash13. 另外, 标准库
     还实现了 SipHash24. [[https://en.wikipedia.org/wiki/SipHash][SipHash]] 算法可以防止 *[[https://en.wikipedia.org/wiki/Collision_attack][Hash 碰撞拒绝访问攻击]]* (Hash
     Collistion DOS), 这种攻击是一种基于各语言 Hash 算法的随机性而精心构造出来的
     增强 Hash 碰撞的手段, 被攻击的服务器 CPU 占用率会轻松地飙升到 100%, 造成服
     务的性能呈指数级下降. 正是基于这个原因, 很多语言都换成了 SipHash 算法, 该算
     法配合随机种子可以起到很好的防范作用. Rust 提供的 SipHash13 性能更好, 而
     SipHash24 更安全. 但使用 SipHash 并非强制性的, Rust 提供了 *可插拔* 的实现
     机制, 让开发者可以根据实际需要更换 Hash 算法, eg: 换成随机性更好的 Fnv 算法.

     Rust 中与 Hash 相关的 trait 源码:
     #+begin_src rust
       // 对具体 `Hash` 算法的抽象
       #[stable(feature = "rust1", since = "1.0.0")]
       pub trait Hasher {
           // 得到最终的写入结果
           #[stable(feature = "rust1", since = "1.0.0")]
           fn finish(&self) -> u64;

           // 根据传入的键写入相应的映射结果
           #[stable(feature = "rust1", since = "1.0.0")]
           fn write(&mut self, bytes: &[u8]);
       }

       #[stable(feature = "rust1", since = "1.0.0")]
       pub trait Hash {
           // 对 `Hasher` 中 `write()` 行为的包装
           #[stable(feature = "rust1", since = "1.0.0")]
           fn hash<H: Hasher>(&self, state: &mut H);
       }

       // 对 `Hasher` 的抽象
       #[stable(since = "1.7.0", feature = "build_hasher")]
       pub trait BuildHasher {
           #[stable(since = "1.7.0", feature = "build_hasher")]
           type Hasher: Hasher;

           // 通过该方法可以指定适合的 `Hasher`
           #[stable(since = "1.7.0", feature = "build_hasher")]
           fn build_hasher(&self) -> Self::Hasher;
       }
     #+end_src

     
     这三个 trait 是 Rust 中 Hash 算法可插拔的基础. 在 Rust 中, 每个实现了
     *Hash* 和 *Eq* 两个 trait 的类型, 均可以作为 ~HashMap~ 的键, 所以并不能直接
     用浮点数类型作为 ~HashMap~ 的键.

     Fnv 算法实现源码:
     #+begin_src rust
       #[allow(missing_copy_implementations)]
       pub struct FnvHasher(u64);

       impl Hasher for FnvHasher {
           #[inline]
           fn finish(&self) -> u64 {
               self.0
           }

           #[inline]
           fn write(&mut self, bytes: &[u8]) {
               let FnvHasher(mut hash) = *self;

               for byte in bytes.iter() {
                   hash = hash ^ (*byte as u64);
                   hash = hash.wrapping_mul(0x100000001b3);
               }

               *self = FnvHasher(hash);
           }
       }
     #+end_src

     如上所示, 只需实现 ~Hasher~ 即可更换算法.

     标准库中的 ~HashMap~ 实现源码:
     #+begin_src rust
       #[derive(Clone)]
       #[cfg_attr(not(test), rustc_diagnostic_item = "hashmap_type")]
       #[stable(feature = "rust1", since = "1.0.0")]
       // `RandomState` 类型实际包装了一个 `DefaultHasher`, 指定了 SipHash13 为默认的 Hash 算法
       // 并且在线程启动时指定了一个随机种子, 以此来增强对 Hash 碰撞拒绝服务的保护
       pub struct HashMap<K, V, S = RandomState> {
           base: base::HashMap<K, V, S>,
       }

       impl<K, V> HashMap<K, V, RandomState> {
           #[inline]
           #[stable(feature = "rust1", since = "1.0.0")]
           pub fn new() -> HashMap<K, V, RandomState> {
               Default::default()
           }
       }

       #[stable(feature = "rust1", since = "1.0.0")]
       impl<K, V, S> Default for HashMap<K, V, S>
       where
           S: Default,
       {
           #[inline]
           // 实现 `default()` 方法, `with_hasher()` 方法调用的是默认的 SipHash13
           fn default() -> HashMap<K, V, S> {
               HashMap::with_hasher(Default::default())
           }
       }
     #+end_src

     现在完成了第一步: 实现并创建了合理的 hash 函数, 接下来要寻找一种方法阿来合
     理地解决 Hash 冲突. 在业界一共有 4 类解决 Hash 冲突的方法: *外部拉链法*, 
     *开放定址法*, *公共溢出区* 和 *再 Hash 法*.

     *外部拉链法* 并不直接在桶中存储键值对, 它基于属组合哦链表的组合来解决冲突,
     每个 Bucket 都链接一个链表, 当发生冲突时, 将冲突的键值对插入链表中. 外部拉
     链法的有点在于方法简单, 非同义词之间也不会产生聚集现象(相比于开发定址法),
     并且其空间结构是动态申请的, 所以比较适合无法确定表长的情况; 却带了是链表指
     针需要额外的空间, 并且遇到碰撞拒绝服务时 ~HashMap~ 会退化为单链表.

     *开放定址法* 是指在发生冲突时直接去寻找下一个空的地址, 只要底层的表足够大,
     就总能找到空的地址. 这种寻找下一个空地址的行为, 叫作 *探测(Probe)*. 如何探
     测也是非常有讲究的, 直接依次一个个地寻找叫做 *线性探测(Linear Probing)*,
     但是它在处理冲突时很容易聚集在一起. 因此还有二次探测(Quadratic Probing),
     应该算是目前最常用的一种探测方法. 另外还有随机探测, eg: Ruby 语言在 2.4 版
     本中就使用了这种探测方法, 在此之前, Ruby 用的还是外部拉链法来解决冲突问题,
     而 Python 中的字典使用的是开放定址法和二次探测. 开放定址法的优点在于计算简
     单快捷, 处理方便; 缺点是它会产生聚集现象, 并且删除元素也会变得十分复杂.

     *公共溢出区* 就是指建立一个独立的公共区, 把冲突的键值对都放在其中. *再 Hash
     法* 就是指另外一个 Hash 函数来算 Hash 值. 这两种方法不太常用.

     Rust 采用的是 *开放定址法 + 线性检测*, 对于线性探测容易聚集在一起的缺陷,
     Rust 使用了 *罗宾汉(Robin Hood Hashing)算法* 来解决. 在线性探测时, 如果遇到
     空桶, 则正常插入; 如果遇到桶已经被占用, 那么就要看占用这个桶的键值对是经历
     过几次探测才被插入该位置的, 如果该键值对的探测次数比当前待插入的键值对的探
     测次数少, 则它属于 "富翁", 就把当前的键值对插入该位置, 再接着找下一个位置来
     安置被替换的 "富翁" 键值对. 正是因为这种 "劫富济贫" 的思路, 这种算法才被称
     为罗宾汉算法.

     当调用 HashMap 的 ~insert()~ 方法时, 首先会通过 ~make_hash()~ 方法, 将传入
     的键生成 Hash 值, 通过内部的特殊处理(为了防止冲突)生成 SafeHash. 得到 Hash
     值之后, 通过 ~resize()~ 方法判断是否需要扩容, 不管是否需要扩容, 最终都会调
     用到 ~search_hashed()~ 方法.

     *TODO*: 疑问, 源码已更改?
     ~search_hashed()~ 方法需要三个参数: HashMap 的内部 ~table~ 指针, ~SafeHash~
     和用于指定检索条件的 ~FnMut(&K) -> bool~ 闭包. 该方法是按线性探测来寻找桶的,
     如果找到的是 "空桶(Vacant)", 则直接返回. 在内部, 朋友两种类型的桶被认为是空
     桶: 即 ~NoElem~ 和 ~NeqElem~, 分别表示底层数组索引违背占用的桶.

     *TODO*: 疑问, 源码已更改?
     ~VacantEntryState~ 内部定义:
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       pub struct VacantEntry<'a, K: 'a, V: 'a> {
           base: base::RustcVacantEntry<'a, K, V>,
       }

       // 书中源码
       enum VacantEntryState<K, V, M> {
           // 底层被占用的桶
           NeqElem(FullBucket<K, V, M>, usize),
           // 空桶
           NoElem(EmptyBucket<K, V, M>, usize)
       }
     #+end_src

     对于底层的桶, 只有占用和空两种状态, 而通过 ~VacantEntryState~ 包装之后, 空
     桶(Vacant)就多了一层语义: 真正的空桶和值随时可以被替换的桶. 此处也体现了
     Rust 中 Enum 枚举体的方便性.

     如果在线性探测过程中找到的是 ~EmptyBucket~, 那么就将其包装为 ~NoElem~ 返回,
     然后就可以调用 ~NoElem~ 的 ~insert()~ 方法将值直接插入. 如果此时返回的是
     ~FullBucket~, 那么需要判断其探测次数是否比当前要插入的键值对的探测次数少,
     如果少, 则将此桶中的值包装为 ~NeqElem~ 并返回.

     对于 ~NeqElem~, 其包含的是当前 ~FullBucket~ 中存储的值, Rust 内部会使用
     ~robin_hood()~ 方法用新的值将其替换掉. 替换掉的值不能扔掉, 而要再次通过线性
     探测为其找到新的位置. 在 ~robin_ho()~ 方法内部通过两个嵌套的 ~loop~ 循环来
     保证新值和替换掉的值均被存储到合适的桶中.

     如果探测次数不满足要求, 那么比对 ~FullBucket~ 中存储的值得 Hash 值是否和
     ~search_hashed()~ 方法传入的 Hash 值相匹配, 若匹配则再比对存储的键是否一致,
     若一致就返回 "满桶(Occupied)". 满桶(Occupied)是指最终查找到的和指定键一一对
     应的桶. 如果是 ~insert()~ 操作, 则其内部会调用 ~std::mem::swap~ 方法用新值
     替换掉旧值. 如果是 ~get()~ 操作, 则返回该桶中保存的值.

     以上就是 ~HashMap~ 的整个实现思路. 开放定址法的一个缺点是根据指定的键删除键
     值对比较复杂, 因为并不能真的删除, 否则会破坏寻址的正确性, 但是 Rust 很轻松
     地解决了这个问题.

     当使用 ~HashMap~ 的 ~remove()~ 方法删除键值对时, 同样需要将传入的键通过
     Hash 函数计算出 Hash 值, 然后经过 ~search_hashed()~ 方法的检索, 返回满桶(如
     果没有找到则返回 ~None~), 再调用内部的 ~pop_internel()~ 方法对桶进行删除处
     理. 但这个删除并非真正的删除, 而是通过 ~gap_peek()~ 方法返回一个枚举类型
     ~GapThenFull~.

     ~GapThenFull~ 枚举体示意:
     #+begin_src rust
       // 书中代码
       pub struct GapThenFull<K, V, M> {
           gap: EmptyBucket<K, V, ()>,
           full: FullBucket<K, V, M>,
       }
     #+end_src
     
     使用该枚举体表示内部桶的两种状态, 就完美地解决了 ~remove()~ 的问题.

     在了解了 ~HashMap~ 的各种使用方法及其实现原理之后, 有一点需要注意: 在使用
     ~HashMap~ 时, 如果要合并两个或多个 ~HashMap~, 则尽量使用 ~extend~ 或其他迭
     代器适配器方式, 而不要用 ~for~ 循环来插入, 否则会带来性能问题.

** 理解容量
   无论是 ~Vec~ 还是 ~HashMap~, 使用这些集合龙骑类型, 最重要的是理解容量
   (Capacity)和大小(Size/Len)的区别.

   容量是指为集合容器分配的内容容量, 而大小是指该集合中包含的元素数量. 也就是说,
   容量和内存分配有关系, 大小只是衡量该集合容器中包含的元素. 当容量满了之后, 这
   些集合容器都会自动扩容. 但是对于不同的集合容器, 定义容量 *满* 或 *空* 两种状
   态是不同的. 如果搞不清楚这个问题, 就可能会写出有安全漏洞的代码, 即便是 Rust
   这种号称内存安全的语言, 也无法避免这种逻辑上的漏洞.

   在 Rust 1.3 到 1.21 中, ~VecDeque~ 集合类型中的 ~reserve()~ 方法暴露了一个缓
   冲区溢出漏洞, 允许任意代码执行. 就是这样的逻辑漏洞, 本质原因就是搞错了容量.

   Rust 的 ~VecDeque<T>~ 是一种可增长容量的双端队列(Double-Ended Queue), 具体用
   法在第二张介绍过. 其内部主要维护一个 *环形缓冲区(Ring Buffer)*.
   
   eg: 头指针写入, 尾指针读取, 环形内索引为 0 ~ 8

   该环形缓冲区由两个指针和一个可增长数组组成. 这两个指针分别为: *头指针(Head
   Pointer)* 和 *尾指针(Tail Pointer)*. 其中头指针永远指向该写入数据的位置, 而尾
   指针永远指向可以读取的第一个元素.

   当环形缓冲区为空时, 两个指针都指向位置 0. 当有新元素插入时, 如果直接插入位置
   0, 则将用于写入数据的 Head 指针指向位置 1, 而用于读取数据的 Tail 指针指向位
   置 0. 以此类推, 当插入第 8 个元素时, Head 和 Tail 指针将再次重叠. 那么在这种
   情况下, 该如何区分头和尾? 如果此时继续给缓冲区添加新元素, 那么位置 0 处的数据
   将被其他数据覆盖, 这就回造成 *缓冲区溢出攻击*. 所以, 为了避免这种情况, 需要空
   出一个位置, 不能插入元素, 这样才可以区分头和尾.

   在 Rust 中 ~VecDeque<T>~ 也是按这种思路来实现环形缓冲区的. 在创建新的缓冲区时,
   自动保留一位.

   ~VecDeque<T>~ 中的 ~with_capacity()~ 方法源码
   #+begin_src rust
     #[stable(feature = "rust1", since = "1.0.0")]
     pub fn with_capacity(capacity: usize) -> VecDeque<T> {
         // +1 since the ringbuffer always leaves one space empty
         // 此处使用 +1 因为 `ringbuffer` 总是需要一个预留空位
         // `next_power_of_two()` 方法表示要分配的容量必须 >= 容量数 n 的最小二次幂
         // eg: 传入的 n 为 2, 则分配容量为 4
         // 如果传入的容量数溢出, 则容量值返回 0, 也就是不预分配内容.
         let cap = cmp::max(capacity + 1, MINIMUM_CAPACITY + 1).next_power_of_two();
         assert!(cap > capacity, "capacity overflow");

         VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity(cap) }
     }
   #+end_src

   综上所述, 要判断环形缓冲区是否为满状态, 就必须看容量和大小的差是否为 1.
   
   ~VecDeque<T>~ 中的 ~is_full()~ 方法:
   #+begin_src rust
     #[inline]
     fn is_full(&self) -> bool {
         self.cap() - self.len() == 1
     }
   #+end_src

   #+begin_src rust
     #[stable(feature = "rust1", since = "1.0.0")]
     pub fn reserve(&mut self, additional: usize) {
         let old_cap = self.cap();
         let used_cap = self.len() + 1;
         let new_cap = used_cap
             .checked_add(additional)
             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())
             .expect("capacity overflow");

         // 问题代码:
         if new_cap > self.capacity() {
         // if new_cap > old_cap {
             self.buf.reserve_exact(used_cap, new_cap - used_cap);
             unsafe {
                 self.handle_capacity_increase(old_cap);
             }
         }
     }
   #+end_src

   该方法一般用来为集合容器生成指定的更多的容量, 这样可以避免频繁扩容.

   但是使用 ~capacity()~ 方法来判断容量是一个致命错误. ~capacity()~ 方法用于给开
   发者展示可用的逻辑容量, 而 ~cap()~ 方法展示的才是真正的物理容量, 它们之间的关
   系是 ~cap=capacity + 1~, 因为环形缓冲区溢出必须保留一个空位. 所以此处使用
   ~capacity()~ 方法判断容量会导致容量分配少一位. 若容量分配少一位, 那么在读写数
   据的过程中, 指针还是按 ~cap()~ 表示的真实容量来计算, 最终的后果就是本来空出的
   一位, 也被写入了数据. 这样就出现了指针错乱的情况. 在这种情况下, 如果再写入新
   的数据, 就会产生缓冲区溢出的分析.

   通过此案例了解到, 容量不仅仅是 "物理" 上的内容容量, 还包括相应数据结构特性产
   生的 "逻辑" 容量. 在日常开发中要注意避免引入逻辑漏洞.
