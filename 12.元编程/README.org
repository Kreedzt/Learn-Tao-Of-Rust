* 元编程
  元编程来源于 *Meta-Programming* 一词, *Meta* 表示 "关于某事本身的某事". 所以
  Meta-Programming 就代表了 *元编程*.  通过元编程的手段可以让程序生成新的程序. 

  元编程在计算机领域是一个非常重要的概念, 它允许程序将代码作为数据, 在运行(或编
  译)时对代码进行修改或替换, 从而让编程语言产生更加强大的表达能力. 总之, 元编程
  就是支持用代码生成代码的一种方式. 各种编程语言中或多或少都提供了基本的元编程能
  力. eg: C/C++ 中, 可以使用预编译器对 *宏定义* 进行文本替换. eg: Rust、Ruby 或
  Elixir 等语言, 则是通过操作 AST 来提供更强大的元编程能力. 另外, Rust 中利用泛
  型进行静态分发, 所以放心也是元编程的一种能力, 同样, C++ 中的模板也可以做到和泛
  型编程类似的事情.

  元编程技术大概可以分为以下几类:

  - *简单文本替换*: eg: C/C++ 中的宏定义, 在编译期直接进行文本替换
  - *类型模板*: eg: C++ 语言支持模板元编程
  - *反射*: eg: Ruby、Java、Go 和 Rust 等或多或少都支持反射, 在运行时或编译时获
    取程序的内部信息
  - *语法扩展*: eg: Ruby、Elixir、Rust 等语言可以对 AST 进行操作而扩展语言的语法
  - *代码自动生成*: eg: Go 语言提供 go generate 命令来根据指定的注释自动生成代码.

  其实语法扩展和代码自动生成的关系比较微妙, 语法扩展是对 AST 进行扩展, 实际上也
  相当于生成了代码. 但是语法扩展是为了扩展语法而生成代码, eg: Rust 的 derive 属
  性, 可以为结构体自动实现一些 trait. 而代码自动生成是指在开发中为了减少代码重复
  或其他原因而自动生成一些代码.

  使用元编程可以做到很多普通函数做不到的事情, eg: 复用代码、编写领域专用语言
  (DSL)等. Rust 语言通过反射和 AST 语法扩展两种手段来支持元编程.

** 反射
   反射(Reflect)机制一般是指程序自我访问、检测和修改其自身状态或行为的能力. Rust
   标准库提供了 ~std::any::Any~ 来支持运行时反射

   #+begin_src rust
     #[stable(feature = "rust1", since = "1.0.0")]
     // 注意: 该 trait 加上了 `'static` 生命周期限定, 意味着该 trait 不能被非生命周期的类型实现.
     pub trait Any: 'static {
         #[stable(feature = "get_type_id", since = "1.34.0")]
         // 返回 唯一标识 的 TypeId 类型, 该标识在编译时生成
         // 每个 TypeId 都是一个 "黑盒", 不能检查其内部内容, 但是允许复制、比较、打印等其他操作
         // TypeId 同样仅限于静态生命周期的类型, 但在未来可能会取消该限制
         fn type_id(&self) -> TypeId;
     }


     #[stable(feature = "rust1", since = "1.0.0")]
     // 任何满足 `'static` 生命周期的类型均实现了它
     impl<T: 'static + ?Sized> Any for T {
         fn type_id(&self) -> TypeId {
             TypeId::of::<T>()
         }
     }
   #+end_src

   Any 还实现了一些方法用于 *运行时检查类型*:
   
   Any 中实现的 ~is()~ 方法源码
   #+begin_src rust
     impl dyn Any {
         #[stable(feature = "rust1", since = "1.0.0")]
         #[inline]
         // 因为 `Any` 是 trait, 此处的 `&self` 必然是一个 trait 对象
         pub fn is<T: Any>(&self) -> bool {
             // Get `TypeId` of the type this function is instantiated with.
             // 通过 `TypeId::of()` 函数来获取类型 T 的全局唯一标识符 t
             let t = TypeId::of::<T>();

             // Get `TypeId` of the type in the trait object (`self`).
             // 同样得到一个全局唯一标识符 `concrete`, 实际上也是调用了 `TypeId::of()` 函数
             let concrete = self.type_id();

             // Compare both `TypeId`s on equality.
             // 比较 t 和 concrete 值是否相等
             t == concrete
         }
     }
   #+end_src

*** 通过 is 函数判断类型
    通过 ~println()~ 输出可以看出, TypeId 是一个结构体, 其字段 t 存储了一串数字,
    这就是 *全局唯一类型标识符*, 实际上是 u64 类型. 代表唯一标识符的这串数字, 在
    不同的编译环境中, 产生的结果是不同的. 所以在实际开发中, 最好不要将 TypeId 暴
    露到外部接口中被当作依赖.

*** 转换到具体类型
    Any 也提供了 ~downcast_ref()~ 和 ~downcast_mut()~ 两个成对的泛型方法, 用于将
    方向 T 向下转为具体的类型. 返回值分别为 ~Option<&T>~ 和 ~Option<&mut T>~ 类
    型. 其中 ~downcast_ref()~ 将内心 T 转换为不可变引用, 而 ~downcast_mut()~ 将
    类型 T 转换为可变引用.
    
    *注意*: ~Box<Any>~ 类型是独占所有权的类型, 所以无法像 12-5 那样匹配多种类型.

*** 非静态生命周期类型
    非静态生命周期类型没有实现 Any. 所以无法赋值给 Any 类型.

    对于带生命周期的结构体, 成员内生命周期为 ~static~ 时, 结构体作为已实现 Any
    的结构体.

** 宏系统
   Rust 中反射的功能虽然有限, 但除此之外, Rust 还提供了功能强大的 *宏(Macro)* 来
   支持元编程. 宏是一种批处理的称谓, 通常来说, 是根据预定义的规则转换成相应地输
   出. 这种转换过程叫做 *宏展开*.

*** 起源
    现在很多语言都提供了宏操作, 大致可以分为两类: *文本替换* 和 *语法扩展*.

    C 语言中的宏函数就属于文本替换. 由于 C 的宏是纯文本替换, 预处理器并不会对宏
    体做任何检查, 所以使用它的时候经常会出现问题.
    
    另外一种可以进行语法扩展的宏起源于 Lisp 语言. Lisp 的宏可以利用 *S 表达式
    (S-Expr)*, 将代码作为数据, 生成新的代码, 而这些代码又可以被执行, 这就赋予了
    Lisp 宏强大的可能性, 包括可以由此进行语法扩展, 甚至创造新的语法. 简单来说,
    Lisp 宏就是将一个 S 表达式转变为另一个 S 表达式.
    
    #+begin_src lisp
      (defmacro one! (var)
        (list 'setq var 1)
        )

      (+ (one! x ) 2) ;; 调用 one!
      (+ (setq x 1) 2) ;; 宏展开
      )
    #+end_src

    以上表达式通过宏展开, 将 ~one!~ 替换为 ~(setq x 1)~, 从而生成新的 S 表达式
    ~(+ (setq x 1) 2)~

    所谓 S 表达式, 是指人类可读的文本形式的一种三元结构, 形如 "(1 2 3)" 在 Lisp
    语言中既可以作为代码, 也可用作数据. ~(+ setq x 1) 2)~ 就是一个 S 表达式. S
    表达式实际上等价于二叉树结构.

    #+begin_example
      (+
        (setq x 1)
        2
        )


                                         +
                  macro  expension      / \
      (one! x) ------------------->  setq  2
                                     /  \
                                    x    1
    #+end_example

    上图展示了 S 表达式等价的二叉树结构, 其中每个节点就是 S 表达式中的元素. 当 S
    表达式中存在宏的时候, 就会将其展开, 从而让之前的 S 表达式形成新的 S 表达式.
    *这里值得注意的是*, 宏调用和函数调用之间的区别, 宏调用产生的是 S 表达式, 而
    函数调用会产生具体的值, 认清这个区别比较重要. S 表达式是 Lisp 语言精华化所在,
    这种思想对现在的很多语言都影响颇深.

    除了 C 语言的文本替换宏外, 其他现代编程语言中提供的宏都可以通过直接操作抽象
    语法树的方式来进行语法苦中含. 不同的语言提供的宏形式有所不同. 有的提供了显式
    地宏语法, eg: ~defmacro~ / ~macro~ 等关键字来定义宏, 有的语言则通过其他形式,
    eg: Python 中的装饰器(decorator) 和 Ruby 中的块(block), 均可以达成操作抽象语
    法树的目的, 殊途同归. 而抽象语法树就等价于 Lisp 中的 S 表达式, 用 S 表达式可
    以表示任何语言的抽象语法树.

    Rust 开发者可以编写特定的宏, 在编译时通过宏展开的方式操作抽象语法树, 从而达
    到语法扩展的目的.

*** Rust 中宏的种类
    Rust 的宏系统按定义的方式可以分为两大类:
    - *声明宏* (Declarative Macro)
    - *过程宏* (Procedural Macro)

    *警告*: 内容有改动
    声明宏是指通过 ~macro_rules!~ 声明定义的宏, 它是 Rust 中最常用的宏.(当前版本
    已可在 Stable 下使用).

    过程宏是编译器语法扩展的方式之一. Rust 允许通过特定的语法编写编译器插件, 但
    该编写插件的语法还未稳定, 所以提供了过程宏来让开发者实现自定义派生属性的功能.
    eg: Serde 库实现的 ~#[derive(Serialize, Deserialize)]~ 就是基于过程实现的.

    具体到宏使用的语法形式又分为以下几种:
    - *调用宏*: 形如 ~println!~, ~assert_eq!~, ~thread_local!~ 等可以当作函数调
      用的宏. 这种形式的宏通常由声明宏来实现, 也可以通过过程宏实现.
    - *属性宏*: 也就是形如 ~#[derive(Debug)]~ 或 ~#[cfg]~ 这种形式的语法. 这种形
      式的宏可以通过过程宏来实现, 也可以通过编译器插件来实现.

    按宏的 *来源*, 可以分为以下两类:
    - *内置宏*: 指 Rust 本身内置的一些宏, 包括 2 种: 一种由标准库中具体的代码实
      现, 另一种属于编译器固有行为.
    - *自定义宏*: 指由开发者自己定义的声明宏或者过程宏等

    内置宏展示
    #+begin_src rust
      #[macro_export]
      #[stable(feature = "rust1", since = "1.0.0")]
      #[allow_internal_unstable(print_internals, format_args_nl)]
      macro_rules! println {
          () => ($crate::print!("\n"));
          ($($arg:tt)*) => ({
              $crate::io::_print($crate::format_args_nl!($($arg)*));
          })
      }
    #+end_src

    
*** 编译过程
    Rust 整个编译过程
    #+begin_example
                 分词            解析
      Rust Code ----->  Token  ------> AST
                                        |
                                    简  |
                                    化  |
                                        ↓
                                       HIR
                                        |
                                        | 简
                                        | 化
                                        ↓    转译             优化
                                       MIR -------> LLVM IR -----> Machine Code
    #+end_example

    Rust 源码的整个编译过程可以大致分为六个主要阶段:
    1. *分词阶段*: 通过词法分析将源码分为一系列的词条(Token)
    2. *解析阶段*: 通过语法解析, 将词条解析为 AST
    3. *提炼 HIR*: 通过对 AST 进一步提炼简化, 得到高级中间语言(High-Level IR,
       HIR), 专门用于类型检查和一些相关的分析工作. HIR 相比于 AST, 简化了语法信
       息, 因为 HIR 不需要知道代码的语法元素
    4. *提炼 MIR*: 通过对 HIR 的再次提炼, 剔除一些不必要的元素之后得到中级中间语
       言(Middle-Level IR, MIR), 专门用于检查以及其他的优化工作, eg: 支持增量编
       译等
    5. *转译为 LLVM IR*: 将 MIR 转译 生成为 LLVMIR 语言, 交由 LLVM 去做后续处理.
    6. *生成机器码*: 将 LLVM IR 警告一系列的优化生成机器码(.o)文件, 最终交给链接
       器去处理.

    以上工作均由 Rust 编译器来完成, 不同的阶段使用了不同的内部组件, 并且不同的编
    译阶段有不同的工作目标. 现在只关注与宏系统相关的分词和解析.

**** 词条流
     Rust 代码编译器的第一步, 就是通过词法分析把代码文本分词为一系列的词条
     (Tokens).

     词条一般包括以下几类:
     - *标识符*: 源码汇总的关键字、变量等都被识别为标识符
     - *字面量*: eg: 字符串字面量
     - *运算符*: eg: 四目运算, 逻辑运算符等
     - *界符*: eg: 分号、逗号、冒号、圆括号、花括号、箭头灯

     以 12-15 的函数 ~t~ 为例来说, 编译器会对该函数从左到右依次识别. ~fn~ 关键字
     会被识别为一个标识符(Identifier), 函数名 ~t~ 同样也是一个标识符. 当碰到圆括
     号的时候, 编译器会以圆括号为界, 将其看做一个独立的组合进行分词处理. 函数签
     名代表返回值的右箭头(->)也会被识别为一个独立的界符词条, 返回值类型 ~i32~ 同
     样也是一个标识符. 最后的函数体会以花括号为界, 作为一个独立的组合进行分词处
     理.

     通过编译器提供的命令可以查看 12-15 代码生成的词条和 AST 信息

     输出语法树的 rustc 命令:
     #+begin_src sh
       # 若为独立文件
       rustc -Z ast-json main.rs
       # 若为 cargo 生成的二进制包
       cargo rustc -- -Z ast-json
     #+end_src

     以上命令会生成 JSON 格式的 AST 信息, 其中包含了词法分析之后的词条信息和 AST
     信息.

     执行过后, 代码汇总的空格换行已经被丢弃, 关键字等各种语法元素已经被识别为单
     独的词条. 整段函数最后就变为词条组成的序列, 称为词条流. 词条流对于编译期后
     续生成 AST 来说意义重大

**** 抽象语法树
     词条流虽然可以区分标识符、括号或箭头灯其他语法元素, 但本身并不携带任何语法
     信息, 必须经过语法解析阶段, 生成 AST, 编译器才能最终识别 Rust 代码的意义.

     用 S 表达式来表示 AST:
     #+begin_example
       // a + b + ( c + d[0] ) + e
          (
            +
            (
              +
              ( + a b )
              (+ c (index d 0) )
            )
            e
          )
     #+end_example
     
     在生成 AST 之后, 编译器就可以完全识别原始代码中所携带的语法信息. 接下来只需
     要依次遍历节点就可以进行之后的工作, eg: 节点中如果包含了宏, 则继续将其展开
     为 AST, 知道最终节点中不包含任何宏为止

