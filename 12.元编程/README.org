* 元编程
  元编程来源于 *Meta-Programming* 一词, *Meta* 表示 "关于某事本身的某事". 所以
  Meta-Programming 就代表了 *元编程*.  通过元编程的手段可以让程序生成新的程序. 

  元编程在计算机领域是一个非常重要的概念, 它允许程序将代码作为数据, 在运行(或编
  译)时对代码进行修改或替换, 从而让编程语言产生更加强大的表达能力. 总之, 元编程
  就是支持用代码生成代码的一种方式. 各种编程语言中或多或少都提供了基本的元编程能
  力. eg: C/C++ 中, 可以使用预编译器对 *宏定义* 进行文本替换. eg: Rust、Ruby 或
  Elixir 等语言, 则是通过操作 AST 来提供更强大的元编程能力. 另外, Rust 中利用泛
  型进行静态分发, 所以放心也是元编程的一种能力, 同样, C++ 中的模板也可以做到和泛
  型编程类似的事情.

  元编程技术大概可以分为以下几类:

  - *简单文本替换*: eg: C/C++ 中的宏定义, 在编译期直接进行文本替换
  - *类型模板*: eg: C++ 语言支持模板元编程
  - *反射*: eg: Ruby、Java、Go 和 Rust 等或多或少都支持反射, 在运行时或编译时获
    取程序的内部信息
  - *语法扩展*: eg: Ruby、Elixir、Rust 等语言可以对 AST 进行操作而扩展语言的语法
  - *代码自动生成*: eg: Go 语言提供 go generate 命令来根据指定的注释自动生成代码.

  其实语法扩展和代码自动生成的关系比较微妙, 语法扩展是对 AST 进行扩展, 实际上也
  相当于生成了代码. 但是语法扩展是为了扩展语法而生成代码, eg: Rust 的 derive 属
  性, 可以为结构体自动实现一些 trait. 而代码自动生成是指在开发中为了减少代码重复
  或其他原因而自动生成一些代码.

  使用元编程可以做到很多普通函数做不到的事情, eg: 复用代码、编写领域专用语言
  (DSL)等. Rust 语言通过反射和 AST 语法扩展两种手段来支持元编程.

** 反射
   反射(Reflect)机制一般是指程序自我访问、检测和修改其自身状态或行为的能力. Rust
   标准库提供了 ~std::any::Any~ 来支持运行时反射

   #+begin_src rust
     #[stable(feature = "rust1", since = "1.0.0")]
     // 注意: 该 trait 加上了 `'static` 生命周期限定, 意味着该 trait 不能被非生命周期的类型实现.
     pub trait Any: 'static {
         #[stable(feature = "get_type_id", since = "1.34.0")]
         // 返回 唯一标识 的 TypeId 类型, 该标识在编译时生成
         // 每个 TypeId 都是一个 "黑盒", 不能检查其内部内容, 但是允许复制、比较、打印等其他操作
         // TypeId 同样仅限于静态生命周期的类型, 但在未来可能会取消该限制
         fn type_id(&self) -> TypeId;
     }


     #[stable(feature = "rust1", since = "1.0.0")]
     // 任何满足 `'static` 生命周期的类型均实现了它
     impl<T: 'static + ?Sized> Any for T {
         fn type_id(&self) -> TypeId {
             TypeId::of::<T>()
         }
     }
   #+end_src

   Any 还实现了一些方法用于 *运行时检查类型*:
   
   Any 中实现的 ~is()~ 方法源码
   #+begin_src rust
     impl dyn Any {
         #[stable(feature = "rust1", since = "1.0.0")]
         #[inline]
         // 因为 `Any` 是 trait, 此处的 `&self` 必然是一个 trait 对象
         pub fn is<T: Any>(&self) -> bool {
             // Get `TypeId` of the type this function is instantiated with.
             // 通过 `TypeId::of()` 函数来获取类型 T 的全局唯一标识符 t
             let t = TypeId::of::<T>();

             // Get `TypeId` of the type in the trait object (`self`).
             // 同样得到一个全局唯一标识符 `concrete`, 实际上也是调用了 `TypeId::of()` 函数
             let concrete = self.type_id();

             // Compare both `TypeId`s on equality.
             // 比较 t 和 concrete 值是否相等
             t == concrete
         }
     }
   #+end_src

*** 通过 is 函数判断类型
    通过 ~println()~ 输出可以看出, TypeId 是一个结构体, 其字段 t 存储了一串数字,
    这就是 *全局唯一类型标识符*, 实际上是 u64 类型. 代表唯一标识符的这串数字, 在
    不同的编译环境中, 产生的结果是不同的. 所以在实际开发中, 最好不要将 TypeId 暴
    露到外部接口中被当作依赖.

*** 转换到具体类型
    Any 也提供了 ~downcast_ref()~ 和 ~downcast_mut()~ 两个成对的泛型方法, 用于将
    方向 T 向下转为具体的类型. 返回值分别为 ~Option<&T>~ 和 ~Option<&mut T>~ 类
    型. 其中 ~downcast_ref()~ 将内心 T 转换为不可变引用, 而 ~downcast_mut()~ 将
    类型 T 转换为可变引用.
    
    *注意*: ~Box<Any>~ 类型是独占所有权的类型, 所以无法像 12-5 那样匹配多种类型.

*** 非静态生命周期类型
    非静态生命周期类型没有实现 Any. 所以无法赋值给 Any 类型.

    对于带生命周期的结构体, 成员内生命周期为 ~static~ 时, 结构体作为已实现 Any
    的结构体.
