* 超越安全的边界
  Rust 语言可以分为 *Safe Rust* 和 *Unsafe Rust* 两部分.

  Safe Rust 涵盖了前面章节中所介绍的内容, 包括类型系统和所有权等静态分析机制. 在
  使用 Safe Rust 的时候, 开发者完全不必担心由内存不安全的问题出现. 但是当需要和
  其他语言交互, 甚至与底层操作系统或硬件设备交互的时候, 就只能依靠 Unsafe Rust.

** Unsafe Rust 介绍
   Unsafe Rust 是 Safe Rust 的一个超集. 也就是说, 在 Unsafe Rust 中, 并不会禁用
   Safe Rust 中的任何安全检查.

   即使在 Unsafe Rust 下, 如果依旧编写 Safe Rust 的代码, 也完全可以保证某种程度
   的安全性.

   Unsafe Rust 是指在进以下 5 种操作的时候, 并不会提供任何安全检查:
   - 解引用裸指针
   - 调用 unsafe 的函数或方法
   - 访问或修改可变静态变量
   - *实现* unsafe trait
   - 读写 *Union* 联合体中的字段

   这 5 种操作基本上适用于 Rust 和外部环境 "打交道" 的所有场景. 对于这些场景的操
   作来说, Rust 的安全检查完全无用武之地, 反而会是一种障碍. eg: 解引用裸指针时,
   也许会是一个空指针或悬垂指针, 此时就会造成未定义行为, 从而也就完全无法和外部
   环境 "打交道" 了. 所以, 针对这 5 种操作, 就完全不提供任何安全检查.

   Unsafe Rust 和 Safe Rust 的区分带来了 *以下三方面结果*:
   - Unsafe Rust 由于不需要安全检查, 意味着有一定的性能提升
   - Unsafe Rust 内存安全完全交给开发者来验证, 否则会出现未定义行为
   - 区分了编译器和开发者的职责, 如果代码出现了问题, 可以先排查 Unsafe Rust 的代
     码

   *注意*: Unsafe Rust 的存在并不与 Safe Rust 相矛盾, 也不与 Rust 语言保证内存安
   全的目标相冲突. 反而是 Unsafe Rust 的存在成就了 Rust.

*** Unsafe 语法
    通过 unsafe 关键字和 unsafe 块就可以使用 Unsafe Rust, 它们的作用如下:
    - *unsafe 关键字*: 用于标记(或者说声明)函数、方法和 trait.
    - *unsafe 块*: 用于执行 Unsafe Rust 允许的 5 种操作

**** unsafe 关键字
     Rust 标准库中包含了很多倍 unsafe 关键字标记的函数、方法和 trait.
     
     String 中内置的 unsafe 函数示意:
     #+begin_src rust
       #[inline]
       #[stable(feature = "rust1", since = "1.0.0")]
       // 此处的 unsafe 表明未对传入的参数进行任何合法验证
       // 如果传入的是一个非法的 UTF-8 字节序列, 则会出现内存不安全的问题
       // 表明使用该函数时有可能会发生违反 "契约" 的风险
       pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {
           String { vec: bytes }
       }
     #+end_src

     函数 ~from_utf8_unchecked()~ 的 "契约" 是指: 传入的参数是有效的 UTF-8 字节
     序列. 这就是 unsafe 关键字存在的意义. 该函数被标记上 unsafe 之后, 使用该函
     数的开发者就会主动去了解这一 "契约", 看看当前的使用是否满足 "契约" 的要求.
     如果开发者没有做到满足 "契约" 的要求, 将来出现了问题, 也可以在 unsafe 标记
     的范围内排查问题.

     所以, 在使用 Rust 编写一个函数的时候, 需要注意该函数在使用的时候是否存在违
     反 "契约" 的风险. 如果存在风险, 请使用 unsafe 关键字将其标记出来, 在其他人
     使用该函数时, 就可以多加注意. 这里最大的风险在于: 如果一个函数存在违反 "契
     约" 的风险, 而开发者并没有使用 unsafe 关键字将其标记, 那该函数就很可能成为
     Bug 的 "温床".

     除标记函数或方法外, *unsafe* 也用于标记 trait.

     标准库中包含的 *unsafe trait* 有 *Send* 和 *Sync*. 编译器依赖 Rust 内置的类
     型和内部严格的规则, 为开发者自定义的类型自动实现者两个 trait, 这是 Rust 能
     保证并发安全的基石. 使用 unsafe 对 Send 和 Sync 进行标记, 就意味着开发者手
     动实现它会有安全风险.

     标准库中另外一个 unsafe trait 就是 ~std::str::pattern::Searcher~, 在字符串
     章节中已介绍过它, 它是字符串搜索模式的抽象, 提供了一系列方法, 行为像迭代器.

     Searcher 示意:
     #+begin_src rust
       pub unsafe trait Searcher<'a> {
           // ...
           fn next(&mut self) -> SearchStep;
           // ...
       }
     #+end_src

     此处不在 ~next()~ 上标记 unsafe 的原因: 要实现 Searcher 里的 ~next()~ 方法,
     必须要保证其返回的索引位于有效的 UTF-8 边界上, 否则会出现内存不安全的问题.
     而依据 Searcher 的工作机制来看, ~next()~ 方法并不会引起任何内存不安全问题,
     只是它的返回结果在另外一个地方使用才会发生问题. 而考虑到字符串检索的性能,
     Searcher 也不想对结果进行检查. 所以, 这里只能给 trait 加上 unsafe 标记, 以
     此来警告实现该 trait 的开发者在实现该 trait 时必须遵守这些条件. 另外, 在实
     现 unsafe trait 的时候, 也必须相应地使用 *unsafe impl* 才可以.

**** unsafe 块
     *被 unsafe 关键字标记的不安全函数或方法只能在 unsafe 块中被调用*

*** 访问和修改可变静态变量
    静态变量是全局可访问的. 对于不可变静态变量来说, 访问它不存在任何安全问题.
    Rust 也允许定义可变的静态变量, 但是 Safe Rust 的安全检查不允许多线程多个线程
    同时访问这个可变静态变量. 该操作必须在 unsafe 块中操作.

    和其他语言交互(eg: C) 的时候, 可变静态变量就会非常有用.

*** Union 联合体
    Rust 也提供了像 C 语言中那样的 Union 联合体. Union 和 Enum 相似, Enum 属于
    Tagged Union, 优点在于其存储的 Tag 可以保证内存安全, 缺点是 Tag 要占用多余的
    内存空间. 而 Union 并不需要多余的 Tag, 如果想访问其中的字段, 就必须靠程序逻
    辑来保证其安全性, 如果访问错误, 就会引发未定义行为. 所以, 它的优点是比 Enum
    省内存空间, 缺点是使用起来不安全.

    Union 的内存布局和 Enum 也是相似的, 字段共用同一片内存空间, 所以也被称为共用
    体. 内存对齐方式也是按字段中内存占用最大的类型为主. Rust 里引入 Union 的主要
    原因还是为了方便 Rust 和 C 语言 "打交道".

    在 Safe Rust(Rust 1.50) 下, Rust *不支持 Union 联合体的字段未非 Copy类型*,
    联合体 MyZero 中的字段就是非 Copy 类型. 需要使用
    ~#![feature(untagged_unions)]~ 特性才可正常编译

    联合体和枚举体一样, 每次只能使用一个字段, 因为联合体中的字段均共用内存空间.
    如果使用未初始化的字段, 则可能发生未定义行为.

    
*** 解引用原生指针
    Rust 提供了 ~*const T~ (不变) 和 ~*mut T~ (可变) 两种指针类型. 因为这两种指
    针和 C 语言的指针十分相近, 所以叫其 *原生指针* (Raw Pointer). 具有以下特点:
    
    - *并不保证指向合法的内存*: eg: 很可能是一个空指针
    - *不能像智能指针那样自动清理内存*: 需要像 C 语言那样手动管理内存
    - *没有生命周期的概念*: 编译器不会对其提供借用检查
    - *不能保证线程安全*

    原生指针并不受 Safe Rust 提供的那一层 "安全外衣" 保护, 所以也被称为 *裸指针*. 

    所以, 在对裸指针进行解引用操作的时候, 属于不安全行为.

    通过 ~as~ 操作符可以将变量的不可变引用引用和可变引用转换成裸指针 ~*const
    String~ 和 ~*mut String~. 
    *注意*: 即使同时出现不可变和可变的指针, 依旧不会编译错误. 创建裸指针本身并不
    会触发任何未定义行为, 所以不需要放到 unsafe 块中操作.
    
    解引用随意定义的裸指针会引发 *段错误(Segmentation Fault)*. 无法确定它所指向
    的是否为合法内存.

** 基于 Unsafe 进行安全抽象
   通过 unsafe 关键字和 unsafe 块可以执行一些跳过安全检查的特定操作, 但并不代表
   使用了 unsafe 就不安全. 在日常开发中, 往往需要在 unsafe 的基础上抽象安全的函
   数. 使用 unsafe 块的函数需要满足基本的 "契约", 才能保证整改函数的安全性. 除此
   之外, 还需要了解一些其他的概念, 才能更安全地使用 Unsafe Rust.

*** 原生指针
    原生指针是 Unsafe Rust 中最常用的, 它主要由以下两种用途:

    - *在需要的时候跳过 Rust 安全检查*: 有些情况下, 程序逻辑完全不会有任何的内存
      安全问题, 使用原生指针就可以避免那些不必要的安全检查, 从而提升性能.
    - *与 C 语言 "打交道"*: 需要使用原生指针

    标准库为原生指针内建了很多方法和函数, 为开发者利用指针进行各种操作提供了方便.
    在此主要介绍以下几个内建函数和方法:

    - ~std::ptr::null()~ 函数和 ~is_null()~ 方法
    - ~offset()~ 方法
    - ~read/write~ 方法
    - ~replace()/swap()~ 方法

    这几个是比较常用的函数和方法, 在标准库原生指针模块中还有其他很多方法.

**** 创建空指针
     可以通过 ~std::ptr~ 模块提供的 ~null()~ 函数创建一个空指针, 通过
     ~is_null()~ 方法啊可以判断其是否为空.

     因字符串是以字节为单位存储的, 所以指针的类型为 ~*const u8~.

     在创建空指针的时候, 并不会引起任何未定义行为, 所以不需要使用 unsafe 块.

**** 使用 offset 方法
     顾名思义, *offset* 就是指 *偏移量*, 通过该方法可以指定相对于指针地址的偏移
     字节数, 从而得到相应地址的内容.
     
     *解引用操作优先级低于方法调用, 但高于 as 操作符*. offset 方法以字节为单位指
     定偏移量. 如果超出边界, 就可能产生未定义行为, 所以该方法被标记为 unsafe 方
     法.

**** 使用 read/write 方法
     通过 read 和 write 方法可以读取或写入指针相应内存中的内容. 
     *注意*: 这两个方法也是 unsafe 方法.

     通过 ~read()~ 方法可以读取当前指针指向的内存, 但不会转移所有权. 也就是说:
     在该指针读取完内存之后, 该内存有可能会被其他内容覆盖.

     *注意*: 通过 ~as_ptr()~ 得到的指针是字符串或数组内部的指向存放数据堆(或栈)
     内存的指针, 而引用则是对字符串或数组本身的引用.

     ~write()~ 方法会覆盖掉指定位置上内存的内容

**** 使用 replace/swap 方法
     利用 ~replace()~ 或 ~swap()~ 方法, 可以快速替换指定位置的内存数据.

     ~replace()~ 方法替换指针指向的数据

     ~swap()~ 方法将其指向内存位置上的数据进行互换.
     *警告*: 操作的内存区域可能有重叠的地方, 这种曹忠很有可能引起内部数据混乱,
     从而引发未定义行为, 所以也是 unsafe 方法.

     ~std::mem~ 模块中提供了一个安全的 swap 方法, 其函数签名为 ~fn swap<T>(x:
     &mut T, y: &mut T)~, 注意其参数为可变引用. 因为可变引用是独占的, 不可能对同
     一个变量进行两次可变借用, 所以就保证了该方法不可能出现内存重叠的情况. 同样,
     ~std::mem~ 模块中也提供了 *安全的 replace* 方法.

**** 使用原生指针进行安全抽象
     在标准库中有很多方法是基于 Unsafe Rust 实现的安全抽象. eg: ~Vec<T>~ 动态数
     组的 ~insert()~ 方法. 假设使用 Safe Rust 来实现 ~insert()~ 方法, 将无法避免
     使用多次 ~&mut Vec<T>~. Safe Rust 的借用检查不允许对同一个变量进行多次可变
     借用. 在这种情况下, 使用原生指针是唯一的办法.

     ~Vec<T>~ 的 ~insert()~ 方法源码
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       pub fn insert(&mut self, index: usize, element: T) {
           #[cold]
           #[inline(never)]
           fn assert_failed(index: usize, len: usize) -> ! {
               panic!("insertion index (is {}) should be <= len (is {})", index, len);
           }

           let len = self.len();
           // 断言保证 index 的值不能超过数组长度(越界检测)
           if index > len {
               assert_failed(index, len);
           }

           // space for the new element
           // 判断长度是否达到容量的极限
           if len == self.buf.capacity() {
               self.reserve(1);
           }

           unsafe {
               // 完整的插入逻辑, 放到独立的代码块
               // infallible
               // The spot to put the new value
               {
                   let p = self.as_mut_ptr().add(index);
                   // Shift everything over to make space. (Duplicating the
                   // `index`th element into two consecutive places.)
                   // 将当前位置的内容右移一位
                   ptr::copy(p, p.offset(1), len - index);
                   // Write it in, overwriting the first copy of the `index`th
                   // element.
                   // 写入新的元素
                   ptr::write(p, element);
               }
               self.set_len(len + 1);
           }
       }
     #+end_src

     因为有越界断言和容量极限判断, 所以可以不必在方法签名前面加 unsafe 标签.
