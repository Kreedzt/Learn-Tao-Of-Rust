* 超越安全的边界
  Rust 语言可以分为 *Safe Rust* 和 *Unsafe Rust* 两部分.

  Safe Rust 涵盖了前面章节中所介绍的内容, 包括类型系统和所有权等静态分析机制. 在
  使用 Safe Rust 的时候, 开发者完全不必担心由内存不安全的问题出现. 但是当需要和
  其他语言交互, 甚至与底层操作系统或硬件设备交互的时候, 就只能依靠 Unsafe Rust.

** Unsafe Rust 介绍
   Unsafe Rust 是 Safe Rust 的一个超集. 也就是说, 在 Unsafe Rust 中, 并不会禁用
   Safe Rust 中的任何安全检查.

   即使在 Unsafe Rust 下, 如果依旧编写 Safe Rust 的代码, 也完全可以保证某种程度
   的安全性.

   Unsafe Rust 是指在进以下 5 种操作的时候, 并不会提供任何安全检查:
   - 解引用裸指针
   - 调用 unsafe 的函数或方法
   - 访问或修改可变静态变量
   - *实现* unsafe trait
   - 读写 *Union* 联合体中的字段

   这 5 种操作基本上适用于 Rust 和外部环境 "打交道" 的所有场景. 对于这些场景的操
   作来说, Rust 的安全检查完全无用武之地, 反而会是一种障碍. eg: 解引用裸指针时,
   也许会是一个空指针或悬垂指针, 此时就会造成未定义行为, 从而也就完全无法和外部
   环境 "打交道" 了. 所以, 针对这 5 种操作, 就完全不提供任何安全检查.

   Unsafe Rust 和 Safe Rust 的区分带来了 *以下三方面结果*:
   - Unsafe Rust 由于不需要安全检查, 意味着有一定的性能提升
   - Unsafe Rust 内存安全完全交给开发者来验证, 否则会出现未定义行为
   - 区分了编译器和开发者的职责, 如果代码出现了问题, 可以先排查 Unsafe Rust 的代
     码

   *注意*: Unsafe Rust 的存在并不与 Safe Rust 相矛盾, 也不与 Rust 语言保证内存安
   全的目标相冲突. 反而是 Unsafe Rust 的存在成就了 Rust.

*** Unsafe 语法
    通过 unsafe 关键字和 unsafe 块就可以使用 Unsafe Rust, 它们的作用如下:
    - *unsafe 关键字*: 用于标记(或者说声明)函数、方法和 trait.
    - *unsafe 块*: 用于执行 Unsafe Rust 允许的 5 种操作

**** unsafe 关键字
     Rust 标准库中包含了很多倍 unsafe 关键字标记的函数、方法和 trait.
     
     String 中内置的 unsafe 函数示意:
     #+begin_src rust
       #[inline]
       #[stable(feature = "rust1", since = "1.0.0")]
       // 此处的 unsafe 表明未对传入的参数进行任何合法验证
       // 如果传入的是一个非法的 UTF-8 字节序列, 则会出现内存不安全的问题
       // 表明使用该函数时有可能会发生违反 "契约" 的风险
       pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {
           String { vec: bytes }
       }
     #+end_src

     函数 ~from_utf8_unchecked()~ 的 "契约" 是指: 传入的参数是有效的 UTF-8 字节
     序列. 这就是 unsafe 关键字存在的意义. 该函数被标记上 unsafe 之后, 使用该函
     数的开发者就会主动去了解这一 "契约", 看看当前的使用是否满足 "契约" 的要求.
     如果开发者没有做到满足 "契约" 的要求, 将来出现了问题, 也可以在 unsafe 标记
     的范围内排查问题.

     所以, 在使用 Rust 编写一个函数的时候, 需要注意该函数在使用的时候是否存在违
     反 "契约" 的风险. 如果存在风险, 请使用 unsafe 关键字将其标记出来, 在其他人
     使用该函数时, 就可以多加注意. 这里最大的风险在于: 如果一个函数存在违反 "契
     约" 的风险, 而开发者并没有使用 unsafe 关键字将其标记, 那该函数就很可能成为
     Bug 的 "温床".

     除标记函数或方法外, *unsafe* 也用于标记 trait.

     标准库中包含的 *unsafe trait* 有 *Send* 和 *Sync*. 编译器依赖 Rust 内置的类
     型和内部严格的规则, 为开发者自定义的类型自动实现者两个 trait, 这是 Rust 能
     保证并发安全的基石. 使用 unsafe 对 Send 和 Sync 进行标记, 就意味着开发者手
     动实现它会有安全风险.

     标准库中另外一个 unsafe trait 就是 ~std::str::pattern::Searcher~, 在字符串
     章节中已介绍过它, 它是字符串搜索模式的抽象, 提供了一系列方法, 行为像迭代器.

     Searcher 示意:
     #+begin_src rust
       pub unsafe trait Searcher<'a> {
           // ...
           fn next(&mut self) -> SearchStep;
           // ...
       }
     #+end_src

     此处不在 ~next()~ 上标记 unsafe 的原因: 要实现 Searcher 里的 ~next()~ 方法,
     必须要保证其返回的索引位于有效的 UTF-8 边界上, 否则会出现内存不安全的问题.
     而依据 Searcher 的工作机制来看, ~next()~ 方法并不会引起任何内存不安全问题,
     只是它的返回结果在另外一个地方使用才会发生问题. 而考虑到字符串检索的性能,
     Searcher 也不想对结果进行检查. 所以, 这里只能给 trait 加上 unsafe 标记, 以
     此来警告实现该 trait 的开发者在实现该 trait 时必须遵守这些条件. 另外, 在实
     现 unsafe trait 的时候, 也必须相应地使用 *unsafe impl* 才可以.

**** unsafe 块
     *被 unsafe 关键字标记的不安全函数或方法只能在 unsafe 块中被调用*

*** 访问和修改可变静态变量
    静态变量是全局可访问的. 对于不可变静态变量来说, 访问它不存在任何安全问题.
    Rust 也允许定义可变的静态变量, 但是 Safe Rust 的安全检查不允许多线程多个线程
    同时访问这个可变静态变量. 该操作必须在 unsafe 块中操作.

    和其他语言交互(eg: C) 的时候, 可变静态变量就会非常有用.

*** Union 联合体
    Rust 也提供了像 C 语言中那样的 Union 联合体. Union 和 Enum 相似, Enum 属于
    Tagged Union, 优点在于其存储的 Tag 可以保证内存安全, 缺点是 Tag 要占用多余的
    内存空间. 而 Union 并不需要多余的 Tag, 如果想访问其中的字段, 就必须靠程序逻
    辑来保证其安全性, 如果访问错误, 就会引发未定义行为. 所以, 它的优点是比 Enum
    省内存空间, 缺点是使用起来不安全.

    Union 的内存布局和 Enum 也是相似的, 字段共用同一片内存空间, 所以也被称为共用
    体. 内存对齐方式也是按字段中内存占用最大的类型为主. Rust 里引入 Union 的主要
    原因还是为了方便 Rust 和 C 语言 "打交道".

    在 Safe Rust(Rust 1.50) 下, Rust *不支持 Union 联合体的字段未非 Copy类型*,
    联合体 MyZero 中的字段就是非 Copy 类型. 需要使用
    ~#![feature(untagged_unions)]~ 特性才可正常编译

    联合体和枚举体一样, 每次只能使用一个字段, 因为联合体中的字段均共用内存空间.
    如果使用未初始化的字段, 则可能发生未定义行为.

    
*** 解引用原生指针
    Rust 提供了 ~*const T~ (不变) 和 ~*mut T~ (可变) 两种指针类型. 因为这两种指
    针和 C 语言的指针十分相近, 所以叫其 *原生指针* (Raw Pointer). 具有以下特点:
    
    - *并不保证指向合法的内存*: eg: 很可能是一个空指针
    - *不能像智能指针那样自动清理内存*: 需要像 C 语言那样手动管理内存
    - *没有生命周期的概念*: 编译器不会对其提供借用检查
    - *不能保证线程安全*

    原生指针并不受 Safe Rust 提供的那一层 "安全外衣" 保护, 所以也被称为 *裸指针*. 

    所以, 在对裸指针进行解引用操作的时候, 属于不安全行为.

    通过 ~as~ 操作符可以将变量的不可变引用引用和可变引用转换成裸指针 ~*const
    String~ 和 ~*mut String~. 
    *注意*: 即使同时出现不可变和可变的指针, 依旧不会编译错误. 创建裸指针本身并不
    会触发任何未定义行为, 所以不需要放到 unsafe 块中操作.
    
    解引用随意定义的裸指针会引发 *段错误(Segmentation Fault)*. 无法确定它所指向
    的是否为合法内存.

** 基于 Unsafe 进行安全抽象
   通过 unsafe 关键字和 unsafe 块可以执行一些跳过安全检查的特定操作, 但并不代表
   使用了 unsafe 就不安全. 在日常开发中, 往往需要在 unsafe 的基础上抽象安全的函
   数. 使用 unsafe 块的函数需要满足基本的 "契约", 才能保证整改函数的安全性. 除此
   之外, 还需要了解一些其他的概念, 才能更安全地使用 Unsafe Rust.

*** 原生指针
    原生指针是 Unsafe Rust 中最常用的, 它主要由以下两种用途:

    - *在需要的时候跳过 Rust 安全检查*: 有些情况下, 程序逻辑完全不会有任何的内存
      安全问题, 使用原生指针就可以避免那些不必要的安全检查, 从而提升性能.
    - *与 C 语言 "打交道"*: 需要使用原生指针

    标准库为原生指针内建了很多方法和函数, 为开发者利用指针进行各种操作提供了方便.
    在此主要介绍以下几个内建函数和方法:

    - ~std::ptr::null()~ 函数和 ~is_null()~ 方法
    - ~offset()~ 方法
    - ~read/write~ 方法
    - ~replace()/swap()~ 方法

    这几个是比较常用的函数和方法, 在标准库原生指针模块中还有其他很多方法.

**** 创建空指针
     可以通过 ~std::ptr~ 模块提供的 ~null()~ 函数创建一个空指针, 通过
     ~is_null()~ 方法啊可以判断其是否为空.

     因字符串是以字节为单位存储的, 所以指针的类型为 ~*const u8~.

     在创建空指针的时候, 并不会引起任何未定义行为, 所以不需要使用 unsafe 块.

**** 使用 offset 方法
     顾名思义, *offset* 就是指 *偏移量*, 通过该方法可以指定相对于指针地址的偏移
     字节数, 从而得到相应地址的内容.
     
     *解引用操作优先级低于方法调用, 但高于 as 操作符*. offset 方法以字节为单位指
     定偏移量. 如果超出边界, 就可能产生未定义行为, 所以该方法被标记为 unsafe 方
     法.

**** 使用 read/write 方法
     通过 read 和 write 方法可以读取或写入指针相应内存中的内容. 
     *注意*: 这两个方法也是 unsafe 方法.

     通过 ~read()~ 方法可以读取当前指针指向的内存, 但不会转移所有权. 也就是说:
     在该指针读取完内存之后, 该内存有可能会被其他内容覆盖.

     *注意*: 通过 ~as_ptr()~ 得到的指针是字符串或数组内部的指向存放数据堆(或栈)
     内存的指针, 而引用则是对字符串或数组本身的引用.

     ~write()~ 方法会覆盖掉指定位置上内存的内容

**** 使用 replace/swap 方法
     利用 ~replace()~ 或 ~swap()~ 方法, 可以快速替换指定位置的内存数据.

     ~replace()~ 方法替换指针指向的数据

     ~swap()~ 方法将其指向内存位置上的数据进行互换.
     *警告*: 操作的内存区域可能有重叠的地方, 这种曹忠很有可能引起内部数据混乱,
     从而引发未定义行为, 所以也是 unsafe 方法.

     ~std::mem~ 模块中提供了一个安全的 swap 方法, 其函数签名为 ~fn swap<T>(x:
     &mut T, y: &mut T)~, 注意其参数为可变引用. 因为可变引用是独占的, 不可能对同
     一个变量进行两次可变借用, 所以就保证了该方法不可能出现内存重叠的情况. 同样,
     ~std::mem~ 模块中也提供了 *安全的 replace* 方法.

**** 使用原生指针进行安全抽象
     在标准库中有很多方法是基于 Unsafe Rust 实现的安全抽象. eg: ~Vec<T>~ 动态数
     组的 ~insert()~ 方法. 假设使用 Safe Rust 来实现 ~insert()~ 方法, 将无法避免
     使用多次 ~&mut Vec<T>~. Safe Rust 的借用检查不允许对同一个变量进行多次可变
     借用. 在这种情况下, 使用原生指针是唯一的办法.

     ~Vec<T>~ 的 ~insert()~ 方法源码
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       pub fn insert(&mut self, index: usize, element: T) {
           #[cold]
           #[inline(never)]
           fn assert_failed(index: usize, len: usize) -> ! {
               panic!("insertion index (is {}) should be <= len (is {})", index, len);
           }

           let len = self.len();
           // 断言保证 index 的值不能超过数组长度(越界检测)
           if index > len {
               assert_failed(index, len);
           }

           // space for the new element
           // 判断长度是否达到容量的极限
           if len == self.buf.capacity() {
               self.reserve(1);
           }

           unsafe {
               // 完整的插入逻辑, 放到独立的代码块
               // infallible
               // The spot to put the new value
               {
                   let p = self.as_mut_ptr().add(index);
                   // Shift everything over to make space. (Duplicating the
                   // `index`th element into two consecutive places.)
                   // 将当前位置的内容右移一位
                   ptr::copy(p, p.offset(1), len - index);
                   // Write it in, overwriting the first copy of the `index`th
                   // element.
                   // 写入新的元素
                   ptr::write(p, element);
               }
               self.set_len(len + 1);
           }
       }
     #+end_src

     因为有越界断言和容量极限判断, 所以可以不必在方法签名前面加 unsafe 标签.
*** 子类型与形变
    *子类型(subtype)* 在计算机科学中是相对另外一种有替代关系的数据类型(父类型,
    supertype)而言的. 一般来说, 可以用在父类型的地方, 也可以用子类型来替代. 在类
    型理论中, 子类型关系一般写为: *A<:B*, 这意味着 A 是 B 的子类型.

    在面向对象语言中, 子类型也被称为 *子类型多态(subtype polymorphism)*, 通过多
    态消除了类型之间的耦合性, 实现统一接口. eg: 在需要圆形工作的环境, 也可以使用
    其他任何圆形几何体(eg: 圆环), 它们的关系可表示为 *Ring<:Circle*. 在面向对象
    语言中, 一般用 *[[https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99][里氏替换原则]]* (Liskov Substitution Principle, LSP) 来描述这
    种关系: 所有引用基类(父类)的地方必须能透明地使用其子类的对象. 通俗的说: 允许
    子类可以方便扩展父类的功能, 但不能改变父类原有的功能. LSP 是接口设计和继承复
    用的基石, 遵循该原则可以让代码有更好的维护性和复用性.

**** 型变的基本概念
     在原始类型的基础上通过类型构造器构造更复杂的类型时, 原始类型的子类型关系在
     复杂类型之上如何变化, 也是支持子类型编程语言需要考虑的问题. 计算机科学中把
     根据原始子类型关系确定复杂类型子类型关系的规则则称为 *型变* (variance).

     型变一般可以分为 3 种形式:
     - *协变(covariant)*: 可以继续保持子类型关系.
       eg: Cat 是 Animal 的子类型, 那么 List<Cat> 也是 List<Animal> 的子类型
     - *逆变(contravariant)*: 逆转子类型关系.
       eg: Cat 是 Animal 的子类型, 那么 List<Animal> 是 List<Cat> 的子类型
     - *不变(invariant)*: 即不保持, 也不逆转子类型关系.
       eg: Cat 是 Animal 的子类型, 但 List<Animal> 和 List<Cat> 无关系

     Rust 语言中 *只有生命周期具有子类型关系*. 
     eg: 有生命周期满足 ~'long: 'short~ 这样的关系, 可以说 ~'long~ 是 ~'short~
     的子类型, 这个关系代表生命周期 ~'long~ 存活的时间比 ~'short~ 要长, 也可以说,
     长生命周期是短生命周期的子类型. 
     eg2: ~&'static str~ 是 ~&'a str~ 的子类型.

     
**** 未合理使用型变将会引起未定义行为
     13-17 存在 *未定义行为的风险*, 但是依旧可以编译运行. 原因为: *协变类型*.
     传入的生命周期为 ~&'static i32~, 因为 ~&'static i32~ 是 ~&'a i32~ 的子类型,
     所以 ~&MyCell<&'static i32>~ 是 ~&MyCell<&'a i32>~ 的子类型, 按照子类型的规
     则, 两者可以代替.

     实际上, Rust 允许这种协变是以 *忘记原始生命周期* 为代价的. 所以 ~&val~ 的生
     命周期 ~'a~ 允许协变而成为 ~'static~, 借用检查通过.

     可以把 ~MyCell<T>~ 的协变性质改成逆变或不变就可以.

**** 使用 PhantomData<T>
     ~PhantomData<T>~ 是一个 *零大小类型的标记结构体*, 也叫做 "*幻影类型*", 在需
     要制定一个并不使用的类型时, 就可以使用它, 初次之外, ~PhantomData<T>~ 还扮演
     以下三种其他角色:
     - *型变*: 可以产生协变、逆变和不变三种情况
     - *标记拥有关系*: 和 drop 检查有关
     - *自动 trait 实现*: eg: Send 和 Sync
     
**** 协变、逆变与不变类型列表
     *更多参考*: [[https://doc.rust-lang.org/nomicon/subtyping.html][nomicon-subtyping]]

     Rust 中的几个重要的型变类型:
     - ~&'a T~ 在 ~'a~ 和 ~T~ 上是协变, 对应的 ~*const T~ 也是协变
     - ~&'a mut T~ 在 ~'a~ 上是协变, 但是在 ~T~ 上是不变
     - ~Fn(T)->U~ 在 ~T~ 上是不变, 在 ~U~ 上是协变
     - ~Box<T>~, ~Vec<T>~ 以及其他集合对于它们包含的类型来说都是协变.
     - ~UnsafeCell<T>~, ~Cell<T>~, ~RefCell<T>~, ~Mutex<T>~, 以及其他内部可变类
       型在 ~T~ 上都是不变, 对应的 ~*mut T~ 也是不变.

     *警告*: 此处有争议: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/295][issue]]
     eg: ~&mut &'static~ 和 ~&mut &'a str~ 不存在子类型关系, 所以它们是不变. 如
     果允许协变, 将会有产生未定义行为的可能. 所以, ~UnsafeCell<T>~ 等内部可变性
     (包括可变原生指针 ~*mut T~) 都是 *不变*.

     对结构体来说, 如果包含的字段全部是协变, 则结构体是协变, 否则为不变. 所以,
     对 ~Phantomdata<T>~ 类型来说, 则有以下规则:

     - ~PhantomData<T>~: 在 ~T~ 上是协变
     - ~PhantomData<&'a T>~: 在 ~'a~ 和 ~T~ 上是协变
     - ~PhantomData<&'a mut T>~: 在 ~'a~ 上是协变, 在 ~T~ 上是不变
     - ~PhantomData<*const T>~: 在 ~T~ 上是协变
     - ~PhantomData<*mut T>~: 在 ~T~ 上是不变
     - ~PhantomData<fn(T)>~: 在 ~T~ 上是逆变, 如果以后修改语法, 会成为不变
     - ~PhantomData<fn() -> T>~: 在 ~T~ 上是协变
     - ~PhantomData<fn(T) -> T>~: 在 ~T~ 上是不变
     - ~PhantomData<Cell<&'a ()>>~: 在 ~'a~ 上是不变

     Rust 中仅存在 ~fn(T)~ 的 *逆变情况*.

     从 13-19 代码中, 得出以下结论:
     - ~fn(T)~ *在实现 trait 方法时, 是逆变*. 因为 ~&'static str<: &'a str~, 而
       现在 ~fn(&'a str)~ 可以替代需要 ~fn(&'static str)~ 的情况, 所以得出
       ~fn(&'a str) <: fn(&'static str)~, 逆转了原有类型的子类型关系.
     - *普通的函数调用, 参数是不变*: 当参数需要 ~&'static str~ 类型时, 不能用
       ~&str~ 代替它. 但是函数的返回值是协变, 当返回值是 ~&str~ 的时候, 可以返回
       ~&'static str~ 类型的值作为替代.
       
     *在不久的将来, Rust 官方有可能取消逆变*.

     *当协变不会引起未定义行为的时候, 可以用协变, 否则就保证该类型为不变或逆变*.
