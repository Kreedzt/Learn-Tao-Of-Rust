* 超越安全的边界
  Rust 语言可以分为 *Safe Rust* 和 *Unsafe Rust* 两部分.

  Safe Rust 涵盖了前面章节中所介绍的内容, 包括类型系统和所有权等静态分析机制. 在
  使用 Safe Rust 的时候, 开发者完全不必担心由内存不安全的问题出现. 但是当需要和
  其他语言交互, 甚至与底层操作系统或硬件设备交互的时候, 就只能依靠 Unsafe Rust.

** Unsafe Rust 介绍
   Unsafe Rust 是 Safe Rust 的一个超集. 也就是说, 在 Unsafe Rust 中, 并不会禁用
   Safe Rust 中的任何安全检查.

   即使在 Unsafe Rust 下, 如果依旧编写 Safe Rust 的代码, 也完全可以保证某种程度
   的安全性.

   Unsafe Rust 是指在进以下 5 种操作的时候, 并不会提供任何安全检查:
   - 解引用裸指针
   - 调用 unsafe 的函数或方法
   - 访问或修改可变静态变量
   - *实现* unsafe trait
   - 读写 *Union* 联合体中的字段

   这 5 种操作基本上适用于 Rust 和外部环境 "打交道" 的所有场景. 对于这些场景的操
   作来说, Rust 的安全检查完全无用武之地, 反而会是一种障碍. eg: 解引用裸指针时,
   也许会是一个空指针或悬垂指针, 此时就会造成未定义行为, 从而也就完全无法和外部
   环境 "打交道" 了. 所以, 针对这 5 种操作, 就完全不提供任何安全检查.

   Unsafe Rust 和 Safe Rust 的区分带来了 *以下三方面结果*:
   - Unsafe Rust 由于不需要安全检查, 意味着有一定的性能提升
   - Unsafe Rust 内存安全完全交给开发者来验证, 否则会出现未定义行为
   - 区分了编译器和开发者的职责, 如果代码出现了问题, 可以先排查 Unsafe Rust 的代
     码

   *注意*: Unsafe Rust 的存在并不与 Safe Rust 相矛盾, 也不与 Rust 语言保证内存安
   全的目标相冲突. 反而是 Unsafe Rust 的存在成就了 Rust.

*** Unsafe 语法
    通过 unsafe 关键字和 unsafe 块就可以使用 Unsafe Rust, 它们的作用如下:
    - *unsafe 关键字*: 用于标记(或者说声明)函数、方法和 trait.
    - *unsafe 块*: 用于执行 Unsafe Rust 允许的 5 种操作

**** unsafe 关键字
     Rust 标准库中包含了很多倍 unsafe 关键字标记的函数、方法和 trait.
     
     String 中内置的 unsafe 函数示意:
     #+begin_src rust
       #[inline]
       #[stable(feature = "rust1", since = "1.0.0")]
       // 此处的 unsafe 表明未对传入的参数进行任何合法验证
       // 如果传入的是一个非法的 UTF-8 字节序列, 则会出现内存不安全的问题
       // 表明使用该函数时有可能会发生违反 "契约" 的风险
       pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {
           String { vec: bytes }
       }
     #+end_src

     函数 ~from_utf8_unchecked()~ 的 "契约" 是指: 传入的参数是有效的 UTF-8 字节
     序列. 这就是 unsafe 关键字存在的意义. 该函数被标记上 unsafe 之后, 使用该函
     数的开发者就会主动去了解这一 "契约", 看看当前的使用是否满足 "契约" 的要求.
     如果开发者没有做到满足 "契约" 的要求, 将来出现了问题, 也可以在 unsafe 标记
     的范围内排查问题.

     所以, 在使用 Rust 编写一个函数的时候, 需要注意该函数在使用的时候是否存在违
     反 "契约" 的风险. 如果存在风险, 请使用 unsafe 关键字将其标记出来, 在其他人
     使用该函数时, 就可以多加注意. 这里最大的风险在于: 如果一个函数存在违反 "契
     约" 的风险, 而开发者并没有使用 unsafe 关键字将其标记, 那该函数就很可能成为
     Bug 的 "温床".

     除标记函数或方法外, *unsafe* 也用于标记 trait.

     标准库中包含的 *unsafe trait* 有 *Send* 和 *Sync*. 编译器依赖 Rust 内置的类
     型和内部严格的规则, 为开发者自定义的类型自动实现者两个 trait, 这是 Rust 能
     保证并发安全的基石. 使用 unsafe 对 Send 和 Sync 进行标记, 就意味着开发者手
     动实现它会有安全风险.

     标准库中另外一个 unsafe trait 就是 ~std::str::pattern::Searcher~, 在字符串
     章节中已介绍过它, 它是字符串搜索模式的抽象, 提供了一系列方法, 行为像迭代器.

     Searcher 示意:
     #+begin_src rust
       pub unsafe trait Searcher<'a> {
           // ...
           fn next(&mut self) -> SearchStep;
           // ...
       }
     #+end_src

     此处不在 ~next()~ 上标记 unsafe 的原因: 要实现 Searcher 里的 ~next()~ 方法,
     必须要保证其返回的索引位于有效的 UTF-8 边界上, 否则会出现内存不安全的问题.
     而依据 Searcher 的工作机制来看, ~next()~ 方法并不会引起任何内存不安全问题,
     只是它的返回结果在另外一个地方使用才会发生问题. 而考虑到字符串检索的性能,
     Searcher 也不想对结果进行检查. 所以, 这里只能给 trait 加上 unsafe 标记, 以
     此来警告实现该 trait 的开发者在实现该 trait 时必须遵守这些条件. 另外, 在实
     现 unsafe trait 的时候, 也必须相应地使用 *unsafe impl* 才可以.

**** unsafe 块
     *被 unsafe 关键字标记的不安全函数或方法只能在 unsafe 块中被调用*

*** 访问和修改可变静态变量
    静态变量是全局可访问的. 对于不可变静态变量来说, 访问它不存在任何安全问题.
    Rust 也允许定义可变的静态变量, 但是 Safe Rust 的安全检查不允许多线程多个线程
    同时访问这个可变静态变量. 该操作必须在 unsafe 块中操作.

    和其他语言交互(eg: C) 的时候, 可变静态变量就会非常有用.

*** Union 联合体
    Rust 也提供了像 C 语言中那样的 Union 联合体. Union 和 Enum 相似, Enum 属于
    Tagged Union, 优点在于其存储的 Tag 可以保证内存安全, 缺点是 Tag 要占用多余的
    内存空间. 而 Union 并不需要多余的 Tag, 如果想访问其中的字段, 就必须靠程序逻
    辑来保证其安全性, 如果访问错误, 就会引发未定义行为. 所以, 它的优点是比 Enum
    省内存空间, 缺点是使用起来不安全.

    Union 的内存布局和 Enum 也是相似的, 字段共用同一片内存空间, 所以也被称为共用
    体. 内存对齐方式也是按字段中内存占用最大的类型为主. Rust 里引入 Union 的主要
    原因还是为了方便 Rust 和 C 语言 "打交道".

    在 Safe Rust(Rust 1.50) 下, Rust *不支持 Union 联合体的字段未非 Copy 类型*,
    联合体 MyZero 中的字段就是非 Copy 类型. 需要使用
    ~#![feature(untagged_unions)]~ 特性才可正常编译

    联合体和枚举体一样, 每次只能使用一个字段, 因为联合体中的字段均共用内存空间.
    如果使用未初始化的字段, 则可能发生未定义行为.

    
*** 解引用原生指针
    Rust 提供了 ~*const T~ (不变) 和 ~*mut T~ (可变) 两种指针类型. 因为这两种指
    针和 C 语言的指针十分相近, 所以叫其 *原生指针* (Raw Pointer). 具有以下特点:
    
    - *并不保证指向合法的内存*: eg: 很可能是一个空指针
    - *不能像智能指针那样自动清理内存*: 需要像 C 语言那样手动管理内存
    - *没有生命周期的概念*: 编译器不会对其提供借用检查
    - *不能保证线程安全*

    原生指针并不受 Safe Rust 提供的那一层 "安全外衣" 保护, 所以也被称为 *裸指针*. 

    所以, 在对裸指针进行解引用操作的时候, 属于不安全行为.

    通过 ~as~ 操作符可以将变量的不可变引用引用和可变引用转换成裸指针 ~*const
    String~ 和 ~*mut String~. 
    *注意*: 即使同时出现不可变和可变的指针, 依旧不会编译错误. 创建裸指针本身并不
    会触发任何未定义行为, 所以不需要放到 unsafe 块中操作.
    
    解引用随意定义的裸指针会引发 *段错误(Segmentation Fault)*. 无法确定它所指向
    的是否为合法内存.

** 基于 Unsafe 进行安全抽象
   通过 unsafe 关键字和 unsafe 块可以执行一些跳过安全检查的特定操作, 但并不代表
   使用了 unsafe 就不安全. 在日常开发中, 往往需要在 unsafe 的基础上抽象安全的函
   数. 使用 unsafe 块的函数需要满足基本的 "契约", 才能保证整改函数的安全性. 除此
   之外, 还需要了解一些其他的概念, 才能更安全地使用 Unsafe Rust.

*** 原生指针
    原生指针是 Unsafe Rust 中最常用的, 它主要由以下两种用途:

    - *在需要的时候跳过 Rust 安全检查*: 有些情况下, 程序逻辑完全不会有任何的内存
      安全问题, 使用原生指针就可以避免那些不必要的安全检查, 从而提升性能.
    - *与 C 语言 "打交道"*: 需要使用原生指针

    标准库为原生指针内建了很多方法和函数, 为开发者利用指针进行各种操作提供了方便.
    在此主要介绍以下几个内建函数和方法:

    - ~std::ptr::null()~ 函数和 ~is_null()~ 方法
    - ~offset()~ 方法
    - ~read/write~ 方法
    - ~replace()/swap()~ 方法

    这几个是比较常用的函数和方法, 在标准库原生指针模块中还有其他很多方法.

**** 创建空指针
     可以通过 ~std::ptr~ 模块提供的 ~null()~ 函数创建一个空指针, 通过
     ~is_null()~ 方法啊可以判断其是否为空.

     因字符串是以字节为单位存储的, 所以指针的类型为 ~*const u8~.

     在创建空指针的时候, 并不会引起任何未定义行为, 所以不需要使用 unsafe 块.

**** 使用 offset 方法
     顾名思义, *offset* 就是指 *偏移量*, 通过该方法可以指定相对于指针地址的偏移
     字节数, 从而得到相应地址的内容.
     
     *解引用操作优先级低于方法调用, 但高于 as 操作符*. offset 方法以字节为单位指
     定偏移量. 如果超出边界, 就可能产生未定义行为, 所以该方法被标记为 unsafe 方
     法.

**** 使用 read/write 方法
     通过 read 和 write 方法可以读取或写入指针相应内存中的内容. 
     *注意*: 这两个方法也是 unsafe 方法.

     通过 ~read()~ 方法可以读取当前指针指向的内存, 但不会转移所有权. 也就是说:
     在该指针读取完内存之后, 该内存有可能会被其他内容覆盖.

     *注意*: 通过 ~as_ptr()~ 得到的指针是字符串或数组内部的指向存放数据堆(或栈)
     内存的指针, 而引用则是对字符串或数组本身的引用.

     ~write()~ 方法会覆盖掉指定位置上内存的内容

**** 使用 replace/swap 方法
     利用 ~replace()~ 或 ~swap()~ 方法, 可以快速替换指定位置的内存数据.

     ~replace()~ 方法替换指针指向的数据

     ~swap()~ 方法将其指向内存位置上的数据进行互换.
     *警告*: 操作的内存区域可能有重叠的地方, 这种曹忠很有可能引起内部数据混乱,
     从而引发未定义行为, 所以也是 unsafe 方法.

     ~std::mem~ 模块中提供了一个安全的 swap 方法, 其函数签名为 ~fn swap<T>(x:
     &mut T, y: &mut T)~, 注意其参数为可变引用. 因为可变引用是独占的, 不可能对同
     一个变量进行两次可变借用, 所以就保证了该方法不可能出现内存重叠的情况. 同样,
     ~std::mem~ 模块中也提供了 *安全的 replace* 方法.

**** 使用原生指针进行安全抽象
     在标准库中有很多方法是基于 Unsafe Rust 实现的安全抽象. eg: ~Vec<T>~ 动态数
     组的 ~insert()~ 方法. 假设使用 Safe Rust 来实现 ~insert()~ 方法, 将无法避免
     使用多次 ~&mut Vec<T>~. Safe Rust 的借用检查不允许对同一个变量进行多次可变
     借用. 在这种情况下, 使用原生指针是唯一的办法.

     ~Vec<T>~ 的 ~insert()~ 方法源码
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       pub fn insert(&mut self, index: usize, element: T) {
           #[cold]
           #[inline(never)]
           fn assert_failed(index: usize, len: usize) -> ! {
               panic!("insertion index (is {}) should be <= len (is {})", index, len);
           }

           let len = self.len();
           // 断言保证 index 的值不能超过数组长度(越界检测)
           if index > len {
               assert_failed(index, len);
           }

           // space for the new element
           // 判断长度是否达到容量的极限
           if len == self.buf.capacity() {
               self.reserve(1);
           }

           unsafe {
               // 完整的插入逻辑, 放到独立的代码块
               // infallible
               // The spot to put the new value
               {
                   let p = self.as_mut_ptr().add(index);
                   // Shift everything over to make space. (Duplicating the
                   // `index`th element into two consecutive places.)
                   // 将当前位置的内容右移一位
                   ptr::copy(p, p.offset(1), len - index);
                   // Write it in, overwriting the first copy of the `index`th
                   // element.
                   // 写入新的元素
                   ptr::write(p, element);
               }
               self.set_len(len + 1);
           }
       }
     #+end_src

     因为有越界断言和容量极限判断, 所以可以不必在方法签名前面加 unsafe 标签.
*** 子类型与形变
    *子类型(subtype)* 在计算机科学中是相对另外一种有替代关系的数据类型(父类型,
    supertype)而言的. 一般来说, 可以用在父类型的地方, 也可以用子类型来替代. 在类
    型理论中, 子类型关系一般写为: *A<:B*, 这意味着 A 是 B 的子类型.

    在面向对象语言中, 子类型也被称为 *子类型多态(subtype polymorphism)*, 通过多
    态消除了类型之间的耦合性, 实现统一接口. eg: 在需要圆形工作的环境, 也可以使用
    其他任何圆形几何体(eg: 圆环), 它们的关系可表示为 *Ring<:Circle*. 在面向对象
    语言中, 一般用 *[[https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99][里氏替换原则]]* (Liskov Substitution Principle, LSP) 来描述这
    种关系: 所有引用基类(父类)的地方必须能透明地使用其子类的对象. 通俗的说: 允许
    子类可以方便扩展父类的功能, 但不能改变父类原有的功能. LSP 是接口设计和继承复
    用的基石, 遵循该原则可以让代码有更好的维护性和复用性.

**** 型变的基本概念
     在原始类型的基础上通过类型构造器构造更复杂的类型时, 原始类型的子类型关系在
     复杂类型之上如何变化, 也是支持子类型编程语言需要考虑的问题. 计算机科学中把
     根据原始子类型关系确定复杂类型子类型关系的规则则称为 *型变* (variance).

     型变一般可以分为 3 种形式:
     - *协变(covariant)*: 可以继续保持子类型关系.
       eg: Cat 是 Animal 的子类型, 那么 List<Cat> 也是 List<Animal> 的子类型
     - *逆变(contravariant)*: 逆转子类型关系.
       eg: Cat 是 Animal 的子类型, 那么 List<Animal> 是 List<Cat> 的子类型
     - *不变(invariant)*: 即不保持, 也不逆转子类型关系.
       eg: Cat 是 Animal 的子类型, 但 List<Animal> 和 List<Cat> 无关系

     Rust 语言中 *只有生命周期具有子类型关系*. 
     eg: 有生命周期满足 ~'long: 'short~ 这样的关系, 可以说 ~'long~ 是 ~'short~
     的子类型, 这个关系代表生命周期 ~'long~ 存活的时间比 ~'short~ 要长, 也可以说,
     长生命周期是短生命周期的子类型. 
     eg2: ~&'static str~ 是 ~&'a str~ 的子类型.

     
**** 未合理使用型变将会引起未定义行为
     13-17 存在 *未定义行为的风险*, 但是依旧可以编译运行. 原因为: *协变类型*.
     传入的生命周期为 ~&'static i32~, 因为 ~&'static i32~ 是 ~&'a i32~ 的子类型,
     所以 ~&MyCell<&'static i32>~ 是 ~&MyCell<&'a i32>~ 的子类型, 按照子类型的规
     则, 两者可以代替.

     实际上, Rust 允许这种协变是以 *忘记原始生命周期* 为代价的. 所以 ~&val~ 的生
     命周期 ~'a~ 允许协变而成为 ~'static~, 借用检查通过.

     可以把 ~MyCell<T>~ 的协变性质改成逆变或不变就可以.

**** 使用 PhantomData<T>
     ~PhantomData<T>~ 是一个 *零大小类型的标记结构体*, 也叫做 "*幻影类型*", 在需
     要制定一个并不使用的类型时, 就可以使用它, 初次之外, ~PhantomData<T>~ 还扮演
     以下三种其他角色:
     - *型变*: 可以产生协变、逆变和不变三种情况
     - *标记拥有关系*: 和 drop 检查有关
     - *自动 trait 实现*: eg: Send 和 Sync
     
**** 协变、逆变与不变类型列表
     *更多参考*: [[https://doc.rust-lang.org/nomicon/subtyping.html][nomicon-subtyping]]

     Rust 中的几个重要的型变类型:
     - ~&'a T~ 在 ~'a~ 和 ~T~ 上是协变, 对应的 ~*const T~ 也是协变
     - ~&'a mut T~ 在 ~'a~ 上是协变, 但是在 ~T~ 上是不变
     - ~Fn(T)->U~ 在 ~T~ 上是不变, 在 ~U~ 上是协变
     - ~Box<T>~, ~Vec<T>~ 以及其他集合对于它们包含的类型来说都是协变.
     - ~UnsafeCell<T>~, ~Cell<T>~, ~RefCell<T>~, ~Mutex<T>~, 以及其他内部可变类
       型在 ~T~ 上都是不变, 对应的 ~*mut T~ 也是不变.

     *警告*: 此处有争议: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/295][issue]]
     eg: ~&mut &'static~ 和 ~&mut &'a str~ 不存在子类型关系, 所以它们是不变. 如
     果允许协变, 将会有产生未定义行为的可能. 所以, ~UnsafeCell<T>~ 等内部可变性
     (包括可变原生指针 ~*mut T~) 都是 *不变*.

     对结构体来说, 如果包含的字段全部是协变, 则结构体是协变, 否则为不变. 所以,
     对 ~Phantomdata<T>~ 类型来说, 则有以下规则:

     - ~PhantomData<T>~: 在 ~T~ 上是协变
     - ~PhantomData<&'a T>~: 在 ~'a~ 和 ~T~ 上是协变
     - ~PhantomData<&'a mut T>~: 在 ~'a~ 上是协变, 在 ~T~ 上是不变
     - ~PhantomData<*const T>~: 在 ~T~ 上是协变
     - ~PhantomData<*mut T>~: 在 ~T~ 上是不变
     - ~PhantomData<fn(T)>~: 在 ~T~ 上是逆变, 如果以后修改语法, 会成为不变
     - ~PhantomData<fn() -> T>~: 在 ~T~ 上是协变
     - ~PhantomData<fn(T) -> T>~: 在 ~T~ 上是不变
     - ~PhantomData<Cell<&'a ()>>~: 在 ~'a~ 上是不变

     Rust 中仅存在 ~fn(T)~ 的 *逆变情况*.

     从 13-19 代码中, 得出以下结论:
     - ~fn(T)~ *在实现 trait 方法时, 是逆变*. 因为 ~&'static str<: &'a str~, 而
       现在 ~fn(&'a str)~ 可以替代需要 ~fn(&'static str)~ 的情况, 所以得出
       ~fn(&'a str) <: fn(&'static str)~, 逆转了原有类型的子类型关系.
     - *普通的函数调用, 参数是不变*: 当参数需要 ~&'static str~ 类型时, 不能用
       ~&str~ 代替它. 但是函数的返回值是协变, 当返回值是 ~&str~ 的时候, 可以返回
       ~&'static str~ 类型的值作为替代.
       
     *在不久的将来, Rust 官方有可能取消逆变*.

     *当协变不会引起未定义行为的时候, 可以用协变, 否则就保证该类型为不变或逆变*.

*** 未绑定生命周期
    Unsafe 代码很容易产生 *未绑定生命周期(Unbound Lifetime)*, 即可以被随意推断的
    生命周期. 主要 *注意下面两种情况*:

    - 当从原生指针得到引用时, eg: ~&*raw_ptr~.
    - 使用 ~std::mem::transmute()~ 方法但没有显式给定生命周期. 
      eg: ~transmute::<&T, &U>(foo)~

    代码 13-21 中, input 参数为原生指针 ~*const u32~ 类型, 然后通过解引用原生指
    针和引用符号将其转为引用, 其中 ~&*input~ 相当于 ~&(*input)~.

    最后 x 为一个 *悬垂指针*. ~foo()~ 函数产生了一个未绑定生命周期的借用, 所以就
    跳过了 Rust 的借用检查.

    ~std::mem::transmute<T, U>>(ptr)~ 方法可以将类型 ~T~ 转为类型 ~U~.

    从原生指针得到引用的时候, 需要避免未定义行为的发生.

*** Drop 检查
    Drop 检查(dropck)是借用检查器的附属程序, 它是为了让析构函数可以更安全合理地
    被调用而存在.

    一般来说, 析构函数的调用顺序与变量的声明顺序相反. 也就是说, 如果存在明确的声
    明顺序, 则编译器可以推断析构函数的调用顺序. 但是对于同时声明的情况, eg: 声明
    一个元组是2, 其内部元素的生命周期是相同的, 编译器无法推断到底该先调用谁的析
    构函数. 当出现这种情况的时候, 就容易产生悬垂指针.

**** 在 Safe Rust 中由 dropck 引起的问题 [Rust 1.50 Nightly 中尚未存在此问题]
     在 Safe Rust 中出现这种情况时, Rust 编译器会报错.(现有 NLL 存在, 不会报错)

**** _#[may_dangle] 属性与 dropck
     [Rust 1.50 Nightly 中尚未存在此问题]
     尝试在 13-23 代码基础上新增一个自定义的结构体 ~MyBox<T>~, 该结构体利用原生
     指针来替代 ~Box<T>~. 这需要手动在堆上分配内存, 所以需要在 Nightly Rust 版本
     之下使用 ~#![feature(allocator_api)]~ 特性.

     使用 ~System.alloc()~ 方法分配堆内存时, 参数 ~Layout::array::<T>(1)~ 按照
     ~T~ 类型来指定布局. 在分配好内存之后, 再通过得到的指针写入数据. 最后将指针
     存入 ~MyBox<T>~ 结构体实例中.

     ~#[may_dangle]~ 表示可能出现悬垂指针的意思. ~<#[may_dangle] T>~ 代表在
     ~drop()~ 方法实现中, 将不会用到 ~T~, 否则可能出现悬垂指针. 因为这是需要开发
     人员去保证的, 所以要用 unsafe 关键字来标记 impl.

     *交换声明顺序后出现问题*: 产生了悬垂指针
     
**** 使用 PhantomData<T> 得到更严格的 drop 检查
     因为 ~MyBox<T>~ 用了原生指针, 而原生指针没有所有权语义. 也就是说, Rust 编译
     器 *不会认为* ~MyBox<T>~ 拥有 ~T~. 这就意味着: 在进行 drop 检查时, 不会严
     格要求 ~T~ 的生命周期必须长于 ~MyBox<T>~. 所以在 ~MyBox<T>~ 的 ~drop()~ 方
     法中使用 ~T~ 的时候, 编译器完全忽视了 ~T~ 很可能被提前释放的可能.
     ~PhantomData<T>~ 的功能之一就是标记拥有关系, 正好可以解决这个问题.

     在 13-29 基础上, 再重新创建 ~MyBox2<T>~ 结构体.

     所以在处理 *drop 检查* 的时候, 可以通过以下 2 个维度来处理代码避免出现未定
     义行为:
     
     - ~#[may_dangle]~ 属性: 该属性使用 unsafe 对 ~impl Drop~ 进行标记, 以此来警
       示开发者不要在析构函数中使用其拥有的数据
     - ~PhantomData<T>~: 用于标记符合类型拥有其包含的数据. 这意味着: 该符合类型
       将会遵循严格的 drop 检查, 包含数据的生命周期必须长于复合类型的生命周期.

**** 来自标准库的用法
     在 Rust 标准库中经常结合两者使用. 

     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       #[cfg_attr(not(test), rustc_diagnostic_item = "vec_type")]
       pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: AllocRef = Global> {
           // 通过 `RawVec` 间接拥有 T
           buf: RawVec<T, A>,
           len: usize,
       }

       #[allow(missing_debug_implementations)]
       pub struct RawVec<T, A: AllocRef = Global> {
           // 靠 `Unique` 间接拥有 T
           ptr: Unique<T>,
           cap: usize,
           alloc: A,
       }

       #[unstable(
           feature = "ptr_internals",
           issue = "none",
           reason = "use `NonNull` instead and consider `PhantomData<T>` \
                     (if you also use `#[may_dangle]`), `Send`, and/or `Sync`"
       )]
       #[doc(hidden)]
       #[repr(transparent)]
       #[rustc_layout_scalar_valid_range_start(1)]
       pub struct Unique<T: ?Sized> {
           pointer: *const T,
           // NOTE: this marker has no consequences for variance, but is necessary
           // for dropck to understand that we logically own a `T`.
           //
           // For details, see:
           // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data
           // 使用 `PhantomData<T>` 保证拥有关系
           _marker: PhantomData<T>,
       }

       // 警示开发者注意不要去使用拥有的数据
       #[stable(feature = "rust1", since = "1.0.0")]
       unsafe impl<#[may_dangle] T, A: AllocRef> Drop for Vec<T, A> {
           fn drop(&mut self) {
               unsafe {
                   // use drop for [T]
                   // use a raw slice to refer to the elements of the vector as weakest necessary type;
                   // could avoid questions of validity in certain cases
                   ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
               }
               // RawVec handles deallocation
           }
       }
     #+end_src

     
**** 使用 std::mem::forget 组织析构函数调用
     Rust 中的析构函数默认是会被调用的, 但在有些场合不希望调用析构函数. eg: 通过
     FFI 和 C 语言交互, 在 Rust 中创建的数据需要在 C 中被调用, 若在 Rust 中被释
     放, 则 C 中调用的时候回出问题. ~std::mem::forget~ 来处理这种情况

     对于结构体内的转移所有权, 在不实现 Drop 的 trait 情况下是合法的操作.

     ~mem::uninitialized()~ 是一个 unsafe 函数, 在 take 方法中, 将 a 和 b 的值都
     通过该函数修改为 "*伪装的初始化值*", *用于跳过 Rust 的内存初始化检查*. 但这
     样做是危险的, 如果此时对 a 和 b 进行读取或写入, 都会 *引起未定义行为*. 该函
     数一般用于 FFI 和 C 语言交互.

     另外, ~mem::forgot()~ 函数会将当前的实例 "忘掉", 这样实例就不会被释放, 析构
     函数也不会被调用. 但 ~forget()~ 函数不是 unsafe 函数, 因为使用该函数引起的
     后果是 *内存泄露*, 对 Rust 来说, *属于安全范畴*. 而对开发者来说, *需要在适
     合的地方手动调用 ~drop()~ 方法来允许析构函数*.

**** 在析构函数中手动指定析构顺序
     在 ~std::mem~ 模块中还提供了一个联合体 ~ManuallyDrop~, 通过它可以实现在析构
     函数中手动指定析构顺序.

     *警告*: 源码内容有改动: 见 [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/311][issue]]
     #+begin_src rust
       #[stable(feature = "manually_drop", since = "1.20.0")]
       #[lang = "manually_drop"]
       #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
       #[repr(transparent)]
       pub struct ManuallyDrop<T: ?Sized> {
           value: T,
       }

       impl<T> ManuallyDrop<T> {
           #[must_use = "if you don't need the wrapper, you can use `mem::forget` instead"]
           #[stable(feature = "manually_drop", since = "1.20.0")]
           #[rustc_const_stable(feature = "const_manually_drop", since = "1.36.0")]
           #[inline(always)]
           pub const fn new(value: T) -> ManuallyDrop<T> {
               ManuallyDrop { value }
           }
       }

       impl<T: ?Sized> ManuallyDrop<T> {
           #[stable(feature = "manually_drop", since = "1.20.0")]
           #[inline]
           pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {
               // SAFETY: we are dropping the value pointed to by a mutable reference
               // which is guaranteed to be valid for writes.
               // It is up to the caller to make sure that `slot` isn't dropped again.
               unsafe { ptr::drop_in_place(&mut slot.value) }
           }
       }
     #+end_src

     如上所示, 只要通过 ~ManuallyDrop::new()~ 方法创建一个实例, 就只能通过
     ~ManuallyDrop::drop()~ 函数手动调用析构函数. 实际上, ~std::mem::forget<T>~
     函数的实现就是用了 ~ManuallyDrop::new()~ 方法:
     
     ~forget<T>~ 函数源码示意:
     #+begin_src rust
       #[inline]
       #[rustc_const_stable(feature = "const_forget", since = "1.46.0")]
       #[stable(feature = "rust1", since = "1.0.0")]
       pub const fn forget<T>(t: T) {
           let _ = ManuallyDrop::new(t);
       }
     #+end_src

*** NonNull<T> 指针
    ~NonNull<T>~ 指针实际上是一种特殊的 ~*mut T~ 原生指针, 它的特殊之处有 2 点:
    *协变(covariant)* 和 *非零(non-zero)*.

    ~NonNull<T>~ 旨在成为 *Unsafe Rust 默认的原生指针*, 而非 ~*const T~ 和 ~*mut
    T~. 因为 ~*const T~ 和 ~*mut T~ 基本上是等价的, 它们可以相互转换. 但 *不能从
    ~*const T~ 直接得到 ~&mut T~.*
    
    在 NonNull 被引入之前, Unsafe 代码中最常见的模式就是使用 ~*const T~, 结合
    ~PhantomData<T>~ 得到协变结构体, 并且在需要的时候会将 ~*const T~ 转换为
    ~*mut T~. 使用 ~NonNull<T>~ 就不需要进行转换了, 因为 *它本身就等价于一个协变
    版本的 ~*mut T~.*, 但是还需要 ~PhantomData<T>~ 在必要时提供 *不变* 或 *加强
    drop 检查*.

**** NonNull<T> 的本质
     *警告*: 源码有改动
     ~NonNull<T>~ 源码示意:
     #+begin_src rust
       #[stable(feature = "nonnull", since = "1.25.0")]
       #[repr(transparent)]
       #[rustc_layout_scalar_valid_range_start(1)]
       #[rustc_nonnull_optimization_guaranteed]
       pub struct NonNull<T: ?Sized> {
           pointer: *const T,
       }
     #+end_src

     ~NonNull::dangling()~ 函数用来创建新的悬垂指针, 但它的内存是对齐的. 它在一
     些场景里用于类型初始化. eg: 使用 ~Vec::new()~ 创建一个空的动态数组, 需要初
     始化一个指针. 它是安全的.

**** 空指针优化
     因为 NonNull 的 *非零特性*, 所以可以 *帮助编译器进行优化*.

     Rust 对包含了 ~NonNull<T>~ 指针的 ~Option<T>~ 类型进行了优化行为, 这种优化
     叫做 "空指针优化". 因为 ~NonNull<T>~ 因为是不可能为空的, 所以 ~Option<T>~
     本身是不可能为空的, 所以 ~Option<T>~ 就不需要多余的判别式(tag)来判断是不是
     None, 这样在内存布局上就不需要占用多余的内存. 而对 ~*mut T~ 指针来说, 无法
     保证它一定不是空指针, 所以 ~Option<*mut u64>~ 还需要保留判别式, 内存布局还
     需要按正常的枚举体来进行对齐, 所以会多占用一倍内存.

     空指针优化固然可以省内存, 但在使用 FFI 和 C 语言 "打交道" 的时候要慎用.

**** Unsafe 与恐慌安全
     在 Unsafe Rust 中就需要小心恐慌安全, 这里是 Rust 编译器鞭长莫及的地方.

     代码 13-44 中, 整个函数唯一有可能发生恐慌的地方就是 *clone* 方法, 因为其他
     方法都是简单的函数, 并不会发生恐慌, *但是 ~clone()~ 方法 的实现是未知的, 存
     在发生恐慌的可能*. 所以整个 ~push_all()~ 函数就不是恐慌安全的函数, 它也不保
     证内存安全. 若 ~clone()~ 方法发生了恐慌, 那么后续的元素将无法继续写入内存,
     但是之前已经使用 ~reserve()~ 预分配了内存, 并通过 ~set_len()~ 方法为数组设
     置了长度, 若后继的元素无法写入内存, 那么就会出现未初始化的内存, 最终导致内
     存不安全. 但是出于 Rust 的设计, 这些未初始化的内存并不会被暴露出来. 所以,
     总的来说, 相比于其他语言, eg: C++, Rust 程序员几乎不会担心恐慌安全的问题.

     Rust 也提供了 ~catch_unwind()~ 方法来让开发者捕获恐慌, 恢复当前线程. 但是,
     对于 13-44 中的非恐慌安全的 ~push_all()~ 函数来说, 若想捕获 ~clone()~ 方法
     可能引发的恐慌, 则需小心. 数组的长度已经确定, 但是还有未初始化的内存, 整改
     数据结构的不变性被破坏了. 所以 Rust 编译器也不会允许开发者在 ~push_all()~
     函数中使用 ~catch_unwind()~.
