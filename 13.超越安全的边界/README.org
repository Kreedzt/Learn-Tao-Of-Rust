* 超越安全的边界
  Rust 语言可以分为 *Safe Rust* 和 *Unsafe Rust* 两部分.

  Safe Rust 涵盖了前面章节中所介绍的内容, 包括类型系统和所有权等静态分析机制. 在
  使用 Safe Rust 的时候, 开发者完全不必担心由内存不安全的问题出现. 但是当需要和
  其他语言交互, 甚至与底层操作系统或硬件设备交互的时候, 就只能依靠 Unsafe Rust.

** Unsafe Rust 介绍
   Unsafe Rust 是 Safe Rust 的一个超集. 也就是说, 在 Unsafe Rust 中, 并不会禁用
   Safe Rust 中的任何安全检查.

   即使在 Unsafe Rust 下, 如果依旧编写 Safe Rust 的代码, 也完全可以保证某种程度
   的安全性.

   Unsafe Rust 是指在进以下 5 种操作的时候, 并不会提供任何安全检查:
   - 解引用裸指针
   - 调用 unsafe 的函数或方法
   - 访问或修改可变静态变量
   - *实现* unsafe trait
   - 读写 *Union* 联合体中的字段

   这 5 种操作基本上适用于 Rust 和外部环境 "打交道" 的所有场景. 对于这些场景的操
   作来说, Rust 的安全检查完全无用武之地, 反而会是一种障碍. eg: 解引用裸指针时,
   也许会是一个空指针或悬垂指针, 此时就会造成未定义行为, 从而也就完全无法和外部
   环境 "打交道" 了. 所以, 针对这 5 种操作, 就完全不提供任何安全检查.

   Unsafe Rust 和 Safe Rust 的区分带来了 *以下三方面结果*:
   - Unsafe Rust 由于不需要安全检查, 意味着有一定的性能提升
   - Unsafe Rust 内存安全完全交给开发者来验证, 否则会出现未定义行为
   - 区分了编译器和开发者的职责, 如果代码出现了问题, 可以先排查 Unsafe Rust 的代
     码

   *注意*: Unsafe Rust 的存在并不与 Safe Rust 相矛盾, 也不与 Rust 语言保证内存安
   全的目标相冲突. 反而是 Unsafe Rust 的存在成就了 Rust.

*** Unsafe 语法
    通过 unsafe 关键字和 unsafe 块就可以使用 Unsafe Rust, 它们的作用如下:
    - *unsafe 关键字*: 用于标记(或者说声明)函数、方法和 trait.
    - *unsafe 块*: 用于执行 Unsafe Rust 允许的 5 种操作

**** unsafe 关键字
     Rust 标准库中包含了很多倍 unsafe 关键字标记的函数、方法和 trait.
     
     String 中内置的 unsafe 函数示意:
     #+begin_src rust
       #[inline]
       #[stable(feature = "rust1", since = "1.0.0")]
       // 此处的 unsafe 表明未对传入的参数进行任何合法验证
       // 如果传入的是一个非法的 UTF-8 字节序列, 则会出现内存不安全的问题
       // 表明使用该函数时有可能会发生违反 "契约" 的风险
       pub unsafe fn from_utf8_unchecked(bytes: Vec<u8>) -> String {
           String { vec: bytes }
       }
     #+end_src

     函数 ~from_utf8_unchecked()~ 的 "契约" 是指: 传入的参数是有效的 UTF-8 字节
     序列. 这就是 unsafe 关键字存在的意义. 该函数被标记上 unsafe 之后, 使用该函
     数的开发者就会主动去了解这一 "契约", 看看当前的使用是否满足 "契约" 的要求.
     如果开发者没有做到满足 "契约" 的要求, 将来出现了问题, 也可以在 unsafe 标记
     的范围内排查问题.

     所以, 在使用 Rust 编写一个函数的时候, 需要注意该函数在使用的时候是否存在违
     反 "契约" 的风险. 如果存在风险, 请使用 unsafe 关键字将其标记出来, 在其他人
     使用该函数时, 就可以多加注意. 这里最大的风险在于: 如果一个函数存在违反 "契
     约" 的风险, 而开发者并没有使用 unsafe 关键字将其标记, 那该函数就很可能成为
     Bug 的 "温床".

     除标记函数或方法外, *unsafe* 也用于标记 trait.

     标准库中包含的 *unsafe trait* 有 *Send* 和 *Sync*. 编译器依赖 Rust 内置的类
     型和内部严格的规则, 为开发者自定义的类型自动实现者两个 trait, 这是 Rust 能
     保证并发安全的基石. 使用 unsafe 对 Send 和 Sync 进行标记, 就意味着开发者手
     动实现它会有安全风险.

     标准库中另外一个 unsafe trait 就是 ~std::str::pattern::Searcher~, 在字符串
     章节中已介绍过它, 它是字符串搜索模式的抽象, 提供了一系列方法, 行为像迭代器.

     Searcher 示意:
     #+begin_src rust
       pub unsafe trait Searcher<'a> {
           // ...
           fn next(&mut self) -> SearchStep;
           // ...
       }
     #+end_src

     此处不在 ~next()~ 上标记 unsafe 的原因: 要实现 Searcher 里的 ~next()~ 方法,
     必须要保证其返回的索引位于有效的 UTF-8 边界上, 否则会出现内存不安全的问题.
     而依据 Searcher 的工作机制来看, ~next()~ 方法并不会引起任何内存不安全问题,
     只是它的返回结果在另外一个地方使用才会发生问题. 而考虑到字符串检索的性能,
     Searcher 也不想对结果进行检查. 所以, 这里只能给 trait 加上 unsafe 标记, 以
     此来警告实现该 trait 的开发者在实现该 trait 时必须遵守这些条件. 另外, 在实
     现 unsafe trait 的时候, 也必须相应地使用 *unsafe impl* 才可以.

**** unsafe 块
     *被 unsafe 关键字标记的不安全函数或方法只能在 unsafe 块中被调用*

*** 访问和修改可变静态变量
    静态变量是全局可访问的. 对于不可变静态变量来说, 访问它不存在任何安全问题.
    Rust 也允许定义可变的静态变量, 但是 Safe Rust 的安全检查不允许多线程多个线程
    同时访问这个可变静态变量. 该操作必须在 unsafe 块中操作.

    和其他语言交互(eg: C) 的时候, 可变静态变量就会非常有用.

*** Union 联合体
    Rust 也提供了像 C 语言中那样的 Union 联合体. Union 和 Enum 相似, Enum 属于
    Tagged Union, 优点在于其存储的 Tag 可以保证内存安全, 缺点是 Tag 要占用多余的
    内存空间. 而 Union 并不需要多余的 Tag, 如果想访问其中的字段, 就必须靠程序逻
    辑来保证其安全性, 如果访问错误, 就会引发未定义行为. 所以, 它的优点是比 Enum
    省内存空间, 缺点是使用起来不安全.

    Union 的内存布局和 Enum 也是相似的, 字段共用同一片内存空间, 所以也被称为共用
    体. 内存对齐方式也是按字段中内存占用最大的类型为主. Rust 里引入 Union 的主要
    原因还是为了方便 Rust 和 C 语言 "打交道".

    在 Safe Rust(Rust 1.50) 下, Rust *不支持 Union 联合体的字段未非 Copy 类型*,
    联合体 MyZero 中的字段就是非 Copy 类型. 需要使用
    ~#![feature(untagged_unions)]~ 特性才可正常编译

    联合体和枚举体一样, 每次只能使用一个字段, 因为联合体中的字段均共用内存空间.
    如果使用未初始化的字段, 则可能发生未定义行为.

    
*** 解引用原生指针
    Rust 提供了 ~*const T~ (不变) 和 ~*mut T~ (可变) 两种指针类型. 因为这两种指
    针和 C 语言的指针十分相近, 所以叫其 *原生指针* (Raw Pointer). 具有以下特点:
    
    - *并不保证指向合法的内存*: eg: 很可能是一个空指针
    - *不能像智能指针那样自动清理内存*: 需要像 C 语言那样手动管理内存
    - *没有生命周期的概念*: 编译器不会对其提供借用检查
    - *不能保证线程安全*

    原生指针并不受 Safe Rust 提供的那一层 "安全外衣" 保护, 所以也被称为 *裸指针*. 

    所以, 在对裸指针进行解引用操作的时候, 属于不安全行为.

    通过 ~as~ 操作符可以将变量的不可变引用引用和可变引用转换成裸指针 ~*const
    String~ 和 ~*mut String~. 
    *注意*: 即使同时出现不可变和可变的指针, 依旧不会编译错误. 创建裸指针本身并不
    会触发任何未定义行为, 所以不需要放到 unsafe 块中操作.
    
    解引用随意定义的裸指针会引发 *段错误(Segmentation Fault)*. 无法确定它所指向
    的是否为合法内存.

** 基于 Unsafe 进行安全抽象
   通过 unsafe 关键字和 unsafe 块可以执行一些跳过安全检查的特定操作, 但并不代表
   使用了 unsafe 就不安全. 在日常开发中, 往往需要在 unsafe 的基础上抽象安全的函
   数. 使用 unsafe 块的函数需要满足基本的 "契约", 才能保证整改函数的安全性. 除此
   之外, 还需要了解一些其他的概念, 才能更安全地使用 Unsafe Rust.

*** 原生指针
    原生指针是 Unsafe Rust 中最常用的, 它主要由以下两种用途:

    - *在需要的时候跳过 Rust 安全检查*: 有些情况下, 程序逻辑完全不会有任何的内存
      安全问题, 使用原生指针就可以避免那些不必要的安全检查, 从而提升性能.
    - *与 C 语言 "打交道"*: 需要使用原生指针

    标准库为原生指针内建了很多方法和函数, 为开发者利用指针进行各种操作提供了方便.
    在此主要介绍以下几个内建函数和方法:

    - ~std::ptr::null()~ 函数和 ~is_null()~ 方法
    - ~offset()~ 方法
    - ~read/write~ 方法
    - ~replace()/swap()~ 方法

    这几个是比较常用的函数和方法, 在标准库原生指针模块中还有其他很多方法.

**** 创建空指针
     可以通过 ~std::ptr~ 模块提供的 ~null()~ 函数创建一个空指针, 通过
     ~is_null()~ 方法啊可以判断其是否为空.

     因字符串是以字节为单位存储的, 所以指针的类型为 ~*const u8~.

     在创建空指针的时候, 并不会引起任何未定义行为, 所以不需要使用 unsafe 块.

**** 使用 offset 方法
     顾名思义, *offset* 就是指 *偏移量*, 通过该方法可以指定相对于指针地址的偏移
     字节数, 从而得到相应地址的内容.
     
     *解引用操作优先级低于方法调用, 但高于 as 操作符*. offset 方法以字节为单位指
     定偏移量. 如果超出边界, 就可能产生未定义行为, 所以该方法被标记为 unsafe 方
     法.

**** 使用 read/write 方法
     通过 read 和 write 方法可以读取或写入指针相应内存中的内容. 
     *注意*: 这两个方法也是 unsafe 方法.

     通过 ~read()~ 方法可以读取当前指针指向的内存, 但不会转移所有权. 也就是说:
     在该指针读取完内存之后, 该内存有可能会被其他内容覆盖.

     *注意*: 通过 ~as_ptr()~ 得到的指针是字符串或数组内部的指向存放数据堆(或栈)
     内存的指针, 而引用则是对字符串或数组本身的引用.

     ~write()~ 方法会覆盖掉指定位置上内存的内容

**** 使用 replace/swap 方法
     利用 ~replace()~ 或 ~swap()~ 方法, 可以快速替换指定位置的内存数据.

     ~replace()~ 方法替换指针指向的数据

     ~swap()~ 方法将其指向内存位置上的数据进行互换.
     *警告*: 操作的内存区域可能有重叠的地方, 这种曹忠很有可能引起内部数据混乱,
     从而引发未定义行为, 所以也是 unsafe 方法.

     ~std::mem~ 模块中提供了一个安全的 swap 方法, 其函数签名为 ~fn swap<T>(x:
     &mut T, y: &mut T)~, 注意其参数为可变引用. 因为可变引用是独占的, 不可能对同
     一个变量进行两次可变借用, 所以就保证了该方法不可能出现内存重叠的情况. 同样,
     ~std::mem~ 模块中也提供了 *安全的 replace* 方法.

**** 使用原生指针进行安全抽象
     在标准库中有很多方法是基于 Unsafe Rust 实现的安全抽象. eg: ~Vec<T>~ 动态数
     组的 ~insert()~ 方法. 假设使用 Safe Rust 来实现 ~insert()~ 方法, 将无法避免
     使用多次 ~&mut Vec<T>~. Safe Rust 的借用检查不允许对同一个变量进行多次可变
     借用. 在这种情况下, 使用原生指针是唯一的办法.

     ~Vec<T>~ 的 ~insert()~ 方法源码
     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       pub fn insert(&mut self, index: usize, element: T) {
           #[cold]
           #[inline(never)]
           fn assert_failed(index: usize, len: usize) -> ! {
               panic!("insertion index (is {}) should be <= len (is {})", index, len);
           }

           let len = self.len();
           // 断言保证 index 的值不能超过数组长度(越界检测)
           if index > len {
               assert_failed(index, len);
           }

           // space for the new element
           // 判断长度是否达到容量的极限
           if len == self.buf.capacity() {
               self.reserve(1);
           }

           unsafe {
               // 完整的插入逻辑, 放到独立的代码块
               // infallible
               // The spot to put the new value
               {
                   let p = self.as_mut_ptr().add(index);
                   // Shift everything over to make space. (Duplicating the
                   // `index`th element into two consecutive places.)
                   // 将当前位置的内容右移一位
                   ptr::copy(p, p.offset(1), len - index);
                   // Write it in, overwriting the first copy of the `index`th
                   // element.
                   // 写入新的元素
                   ptr::write(p, element);
               }
               self.set_len(len + 1);
           }
       }
     #+end_src

     因为有越界断言和容量极限判断, 所以可以不必在方法签名前面加 unsafe 标签.
*** 子类型与形变
    *子类型(subtype)* 在计算机科学中是相对另外一种有替代关系的数据类型(父类型,
    supertype)而言的. 一般来说, 可以用在父类型的地方, 也可以用子类型来替代. 在类
    型理论中, 子类型关系一般写为: *A<:B*, 这意味着 A 是 B 的子类型.

    在面向对象语言中, 子类型也被称为 *子类型多态(subtype polymorphism)*, 通过多
    态消除了类型之间的耦合性, 实现统一接口. eg: 在需要圆形工作的环境, 也可以使用
    其他任何圆形几何体(eg: 圆环), 它们的关系可表示为 *Ring<:Circle*. 在面向对象
    语言中, 一般用 *[[https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99][里氏替换原则]]* (Liskov Substitution Principle, LSP) 来描述这
    种关系: 所有引用基类(父类)的地方必须能透明地使用其子类的对象. 通俗的说: 允许
    子类可以方便扩展父类的功能, 但不能改变父类原有的功能. LSP 是接口设计和继承复
    用的基石, 遵循该原则可以让代码有更好的维护性和复用性.

**** 型变的基本概念
     在原始类型的基础上通过类型构造器构造更复杂的类型时, 原始类型的子类型关系在
     复杂类型之上如何变化, 也是支持子类型编程语言需要考虑的问题. 计算机科学中把
     根据原始子类型关系确定复杂类型子类型关系的规则则称为 *型变* (variance).

     型变一般可以分为 3 种形式:
     - *协变(covariant)*: 可以继续保持子类型关系.
       eg: Cat 是 Animal 的子类型, 那么 List<Cat> 也是 List<Animal> 的子类型
     - *逆变(contravariant)*: 逆转子类型关系.
       eg: Cat 是 Animal 的子类型, 那么 List<Animal> 是 List<Cat> 的子类型
     - *不变(invariant)*: 即不保持, 也不逆转子类型关系.
       eg: Cat 是 Animal 的子类型, 但 List<Animal> 和 List<Cat> 无关系

     Rust 语言中 *只有生命周期具有子类型关系*. 
     eg: 有生命周期满足 ~'long: 'short~ 这样的关系, 可以说 ~'long~ 是 ~'short~
     的子类型, 这个关系代表生命周期 ~'long~ 存活的时间比 ~'short~ 要长, 也可以说,
     长生命周期是短生命周期的子类型. 
     eg2: ~&'static str~ 是 ~&'a str~ 的子类型.

     
**** 未合理使用型变将会引起未定义行为
     13-17 存在 *未定义行为的风险*, 但是依旧可以编译运行. 原因为: *协变类型*.
     传入的生命周期为 ~&'static i32~, 因为 ~&'static i32~ 是 ~&'a i32~ 的子类型,
     所以 ~&MyCell<&'static i32>~ 是 ~&MyCell<&'a i32>~ 的子类型, 按照子类型的规
     则, 两者可以代替.

     实际上, Rust 允许这种协变是以 *忘记原始生命周期* 为代价的. 所以 ~&val~ 的生
     命周期 ~'a~ 允许协变而成为 ~'static~, 借用检查通过.

     可以把 ~MyCell<T>~ 的协变性质改成逆变或不变就可以.

**** 使用 PhantomData<T>
     ~PhantomData<T>~ 是一个 *零大小类型的标记结构体*, 也叫做 "*幻影类型*", 在需
     要制定一个并不使用的类型时, 就可以使用它, 初次之外, ~PhantomData<T>~ 还扮演
     以下三种其他角色:
     - *型变*: 可以产生协变、逆变和不变三种情况
     - *标记拥有关系*: 和 drop 检查有关
     - *自动 trait 实现*: eg: Send 和 Sync
     
**** 协变、逆变与不变类型列表
     *更多参考*: [[https://doc.rust-lang.org/nomicon/subtyping.html][nomicon-subtyping]]

     Rust 中的几个重要的型变类型:
     - ~&'a T~ 在 ~'a~ 和 ~T~ 上是协变, 对应的 ~*const T~ 也是协变
     - ~&'a mut T~ 在 ~'a~ 上是协变, 但是在 ~T~ 上是不变
     - ~Fn(T)->U~ 在 ~T~ 上是不变, 在 ~U~ 上是协变
     - ~Box<T>~, ~Vec<T>~ 以及其他集合对于它们包含的类型来说都是协变.
     - ~UnsafeCell<T>~, ~Cell<T>~, ~RefCell<T>~, ~Mutex<T>~, 以及其他内部可变类
       型在 ~T~ 上都是不变, 对应的 ~*mut T~ 也是不变.

     *警告*: 此处有争议: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/295][issue]]
     eg: ~&mut &'static~ 和 ~&mut &'a str~ 不存在子类型关系, 所以它们是不变. 如
     果允许协变, 将会有产生未定义行为的可能. 所以, ~UnsafeCell<T>~ 等内部可变性
     (包括可变原生指针 ~*mut T~) 都是 *不变*.

     对结构体来说, 如果包含的字段全部是协变, 则结构体是协变, 否则为不变. 所以,
     对 ~Phantomdata<T>~ 类型来说, 则有以下规则:

     - ~PhantomData<T>~: 在 ~T~ 上是协变
     - ~PhantomData<&'a T>~: 在 ~'a~ 和 ~T~ 上是协变
     - ~PhantomData<&'a mut T>~: 在 ~'a~ 上是协变, 在 ~T~ 上是不变
     - ~PhantomData<*const T>~: 在 ~T~ 上是协变
     - ~PhantomData<*mut T>~: 在 ~T~ 上是不变
     - ~PhantomData<fn(T)>~: 在 ~T~ 上是逆变, 如果以后修改语法, 会成为不变
     - ~PhantomData<fn() -> T>~: 在 ~T~ 上是协变
     - ~PhantomData<fn(T) -> T>~: 在 ~T~ 上是不变
     - ~PhantomData<Cell<&'a ()>>~: 在 ~'a~ 上是不变

     Rust 中仅存在 ~fn(T)~ 的 *逆变情况*.

     从 13-19 代码中, 得出以下结论:
     - ~fn(T)~ *在实现 trait 方法时, 是逆变*. 因为 ~&'static str<: &'a str~, 而
       现在 ~fn(&'a str)~ 可以替代需要 ~fn(&'static str)~ 的情况, 所以得出
       ~fn(&'a str) <: fn(&'static str)~, 逆转了原有类型的子类型关系.
     - *普通的函数调用, 参数是不变*: 当参数需要 ~&'static str~ 类型时, 不能用
       ~&str~ 代替它. 但是函数的返回值是协变, 当返回值是 ~&str~ 的时候, 可以返回
       ~&'static str~ 类型的值作为替代.
       
     *在不久的将来, Rust 官方有可能取消逆变*.

     *当协变不会引起未定义行为的时候, 可以用协变, 否则就保证该类型为不变或逆变*.

*** 未绑定生命周期
    Unsafe 代码很容易产生 *未绑定生命周期(Unbound Lifetime)*, 即可以被随意推断的
    生命周期. 主要 *注意下面两种情况*:

    - 当从原生指针得到引用时, eg: ~&*raw_ptr~.
    - 使用 ~std::mem::transmute()~ 方法但没有显式给定生命周期. 
      eg: ~transmute::<&T, &U>(foo)~

    代码 13-21 中, input 参数为原生指针 ~*const u32~ 类型, 然后通过解引用原生指
    针和引用符号将其转为引用, 其中 ~&*input~ 相当于 ~&(*input)~.

    最后 x 为一个 *悬垂指针*. ~foo()~ 函数产生了一个未绑定生命周期的借用, 所以就
    跳过了 Rust 的借用检查.

    ~std::mem::transmute<T, U>>(ptr)~ 方法可以将类型 ~T~ 转为类型 ~U~.

    从原生指针得到引用的时候, 需要避免未定义行为的发生.

*** Drop 检查
    Drop 检查(dropck)是借用检查器的附属程序, 它是为了让析构函数可以更安全合理地
    被调用而存在.

    一般来说, 析构函数的调用顺序与变量的声明顺序相反. 也就是说, 如果存在明确的声
    明顺序, 则编译器可以推断析构函数的调用顺序. 但是对于同时声明的情况, eg: 声明
    一个元组是 2, 其内部元素的生命周期是相同的, 编译器无法推断到底该先调用谁的析
    构函数. 当出现这种情况的时候, 就容易产生悬垂指针.

**** 在 Safe Rust 中由 dropck 引起的问题 [Rust 1.50 Nightly 中尚未存在此问题]
     在 Safe Rust 中出现这种情况时, Rust 编译器会报错.(现有 NLL 存在, 不会报错)

**** _#[may_dangle] 属性与 dropck
     [Rust 1.50 Nightly 中尚未存在此问题]
     尝试在 13-23 代码基础上新增一个自定义的结构体 ~MyBox<T>~, 该结构体利用原生
     指针来替代 ~Box<T>~. 这需要手动在堆上分配内存, 所以需要在 Nightly Rust 版本
     之下使用 ~#![feature(allocator_api)]~ 特性.

     使用 ~System.alloc()~ 方法分配堆内存时, 参数 ~Layout::array::<T>(1)~ 按照
     ~T~ 类型来指定布局. 在分配好内存之后, 再通过得到的指针写入数据. 最后将指针
     存入 ~MyBox<T>~ 结构体实例中.

     ~#[may_dangle]~ 表示可能出现悬垂指针的意思. ~<#[may_dangle] T>~ 代表在
     ~drop()~ 方法实现中, 将不会用到 ~T~, 否则可能出现悬垂指针. 因为这是需要开发
     人员去保证的, 所以要用 unsafe 关键字来标记 impl.

     *交换声明顺序后出现问题*: 产生了悬垂指针
     
**** 使用 PhantomData<T> 得到更严格的 drop 检查
     因为 ~MyBox<T>~ 用了原生指针, 而原生指针没有所有权语义. 也就是说, Rust 编译
     器 *不会认为* ~MyBox<T>~ 拥有 ~T~. 这就意味着: 在进行 drop 检查时, 不会严
     格要求 ~T~ 的生命周期必须长于 ~MyBox<T>~. 所以在 ~MyBox<T>~ 的 ~drop()~ 方
     法中使用 ~T~ 的时候, 编译器完全忽视了 ~T~ 很可能被提前释放的可能.
     ~PhantomData<T>~ 的功能之一就是标记拥有关系, 正好可以解决这个问题.

     在 13-29 基础上, 再重新创建 ~MyBox2<T>~ 结构体.

     所以在处理 *drop 检查* 的时候, 可以通过以下 2 个维度来处理代码避免出现未定
     义行为:
     
     - ~#[may_dangle]~ 属性: 该属性使用 unsafe 对 ~impl Drop~ 进行标记, 以此来警
       示开发者不要在析构函数中使用其拥有的数据
     - ~PhantomData<T>~: 用于标记符合类型拥有其包含的数据. 这意味着: 该符合类型
       将会遵循严格的 drop 检查, 包含数据的生命周期必须长于复合类型的生命周期.

**** 来自标准库的用法
     在 Rust 标准库中经常结合两者使用. 

     #+begin_src rust
       #[stable(feature = "rust1", since = "1.0.0")]
       #[cfg_attr(not(test), rustc_diagnostic_item = "vec_type")]
       pub struct Vec<T, #[unstable(feature = "allocator_api", issue = "32838")] A: AllocRef = Global> {
           // 通过 `RawVec` 间接拥有 T
           buf: RawVec<T, A>,
           len: usize,
       }

       #[allow(missing_debug_implementations)]
       pub struct RawVec<T, A: AllocRef = Global> {
           // 靠 `Unique` 间接拥有 T
           ptr: Unique<T>,
           cap: usize,
           alloc: A,
       }

       #[unstable(
           feature = "ptr_internals",
           issue = "none",
           reason = "use `NonNull` instead and consider `PhantomData<T>` \
                     (if you also use `#[may_dangle]`), `Send`, and/or `Sync`"
       )]
       #[doc(hidden)]
       #[repr(transparent)]
       #[rustc_layout_scalar_valid_range_start(1)]
       pub struct Unique<T: ?Sized> {
           pointer: *const T,
           // NOTE: this marker has no consequences for variance, but is necessary
           // for dropck to understand that we logically own a `T`.
           //
           // For details, see:
           // https://github.com/rust-lang/rfcs/blob/master/text/0769-sound-generic-drop.md#phantom-data
           // 使用 `PhantomData<T>` 保证拥有关系
           _marker: PhantomData<T>,
       }

       // 警示开发者注意不要去使用拥有的数据
       #[stable(feature = "rust1", since = "1.0.0")]
       unsafe impl<#[may_dangle] T, A: AllocRef> Drop for Vec<T, A> {
           fn drop(&mut self) {
               unsafe {
                   // use drop for [T]
                   // use a raw slice to refer to the elements of the vector as weakest necessary type;
                   // could avoid questions of validity in certain cases
                   ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))
               }
               // RawVec handles deallocation
           }
       }
     #+end_src

     
**** 使用 std::mem::forget 组织析构函数调用
     Rust 中的析构函数默认是会被调用的, 但在有些场合不希望调用析构函数. eg: 通过
     FFI 和 C 语言交互, 在 Rust 中创建的数据需要在 C 中被调用, 若在 Rust 中被释
     放, 则 C 中调用的时候回出问题. ~std::mem::forget~ 来处理这种情况

     对于结构体内的转移所有权, 在不实现 Drop 的 trait 情况下是合法的操作.

     ~mem::uninitialized()~ 是一个 unsafe 函数, 在 take 方法中, 将 a 和 b 的值都
     通过该函数修改为 "*伪装的初始化值*", *用于跳过 Rust 的内存初始化检查*. 但这
     样做是危险的, 如果此时对 a 和 b 进行读取或写入, 都会 *引起未定义行为*. 该函
     数一般用于 FFI 和 C 语言交互.

     另外, ~mem::forgot()~ 函数会将当前的实例 "忘掉", 这样实例就不会被释放, 析构
     函数也不会被调用. 但 ~forget()~ 函数不是 unsafe 函数, 因为使用该函数引起的
     后果是 *内存泄露*, 对 Rust 来说, *属于安全范畴*. 而对开发者来说, *需要在适
     合的地方手动调用 ~drop()~ 方法来允许析构函数*.

**** 在析构函数中手动指定析构顺序
     在 ~std::mem~ 模块中还提供了一个联合体 ~ManuallyDrop~, 通过它可以实现在析构
     函数中手动指定析构顺序.

     *警告*: 源码内容有改动: 见 [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/311][issue]]
     #+begin_src rust
       #[stable(feature = "manually_drop", since = "1.20.0")]
       #[lang = "manually_drop"]
       #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
       #[repr(transparent)]
       pub struct ManuallyDrop<T: ?Sized> {
           value: T,
       }

       impl<T> ManuallyDrop<T> {
           #[must_use = "if you don't need the wrapper, you can use `mem::forget` instead"]
           #[stable(feature = "manually_drop", since = "1.20.0")]
           #[rustc_const_stable(feature = "const_manually_drop", since = "1.36.0")]
           #[inline(always)]
           pub const fn new(value: T) -> ManuallyDrop<T> {
               ManuallyDrop { value }
           }
       }

       impl<T: ?Sized> ManuallyDrop<T> {
           #[stable(feature = "manually_drop", since = "1.20.0")]
           #[inline]
           pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {
               // SAFETY: we are dropping the value pointed to by a mutable reference
               // which is guaranteed to be valid for writes.
               // It is up to the caller to make sure that `slot` isn't dropped again.
               unsafe { ptr::drop_in_place(&mut slot.value) }
           }
       }
     #+end_src

     如上所示, 只要通过 ~ManuallyDrop::new()~ 方法创建一个实例, 就只能通过
     ~ManuallyDrop::drop()~ 函数手动调用析构函数. 实际上, ~std::mem::forget<T>~
     函数的实现就是用了 ~ManuallyDrop::new()~ 方法:
     
     ~forget<T>~ 函数源码示意:
     #+begin_src rust
       #[inline]
       #[rustc_const_stable(feature = "const_forget", since = "1.46.0")]
       #[stable(feature = "rust1", since = "1.0.0")]
       pub const fn forget<T>(t: T) {
           let _ = ManuallyDrop::new(t);
       }
     #+end_src

*** NonNull<T> 指针
    ~NonNull<T>~ 指针实际上是一种特殊的 ~*mut T~ 原生指针, 它的特殊之处有 2 点:
    *协变(covariant)* 和 *非零(non-zero)*.

    ~NonNull<T>~ 旨在成为 *Unsafe Rust 默认的原生指针*, 而非 ~*const T~ 和 ~*mut
    T~. 因为 ~*const T~ 和 ~*mut T~ 基本上是等价的, 它们可以相互转换. 但 *不能从
    ~*const T~ 直接得到 ~&mut T~.*
    
    在 NonNull 被引入之前, Unsafe 代码中最常见的模式就是使用 ~*const T~, 结合
    ~PhantomData<T>~ 得到协变结构体, 并且在需要的时候会将 ~*const T~ 转换为
    ~*mut T~. 使用 ~NonNull<T>~ 就不需要进行转换了, 因为 *它本身就等价于一个协变
    版本的 ~*mut T~.*, 但是还需要 ~PhantomData<T>~ 在必要时提供 *不变* 或 *加强
    drop 检查*.

**** NonNull<T> 的本质
     *警告*: 源码有改动
     ~NonNull<T>~ 源码示意:
     #+begin_src rust
       #[stable(feature = "nonnull", since = "1.25.0")]
       #[repr(transparent)]
       #[rustc_layout_scalar_valid_range_start(1)]
       #[rustc_nonnull_optimization_guaranteed]
       pub struct NonNull<T: ?Sized> {
           pointer: *const T,
       }
     #+end_src

     ~NonNull::dangling()~ 函数用来创建新的悬垂指针, 但它的内存是对齐的. 它在一
     些场景里用于类型初始化. eg: 使用 ~Vec::new()~ 创建一个空的动态数组, 需要初
     始化一个指针. 它是安全的.

**** 空指针优化
     因为 NonNull 的 *非零特性*, 所以可以 *帮助编译器进行优化*.

     Rust 对包含了 ~NonNull<T>~ 指针的 ~Option<T>~ 类型进行了优化行为, 这种优化
     叫做 "空指针优化". 因为 ~NonNull<T>~ 因为是不可能为空的, 所以 ~Option<T>~
     本身是不可能为空的, 所以 ~Option<T>~ 就不需要多余的判别式(tag)来判断是不是
     None, 这样在内存布局上就不需要占用多余的内存. 而对 ~*mut T~ 指针来说, 无法
     保证它一定不是空指针, 所以 ~Option<*mut u64>~ 还需要保留判别式, 内存布局还
     需要按正常的枚举体来进行对齐, 所以会多占用一倍内存.

     空指针优化固然可以省内存, 但在使用 FFI 和 C 语言 "打交道" 的时候要慎用.

**** Unsafe 与恐慌安全
     在 Unsafe Rust 中就需要小心恐慌安全, 这里是 Rust 编译器鞭长莫及的地方.

     代码 13-44 中, 整个函数唯一有可能发生恐慌的地方就是 *clone* 方法, 因为其他
     方法都是简单的函数, 并不会发生恐慌, *但是 ~clone()~ 方法 的实现是未知的, 存
     在发生恐慌的可能*. 所以整个 ~push_all()~ 函数就不是恐慌安全的函数, 它也不保
     证内存安全. 若 ~clone()~ 方法发生了恐慌, 那么后续的元素将无法继续写入内存,
     但是之前已经使用 ~reserve()~ 预分配了内存, 并通过 ~set_len()~ 方法为数组设
     置了长度, 若后继的元素无法写入内存, 那么就会出现未初始化的内存, 最终导致内
     存不安全. 但是出于 Rust 的设计, 这些未初始化的内存并不会被暴露出来. 所以,
     总的来说, 相比于其他语言, eg: C++, Rust 程序员几乎不会担心恐慌安全的问题.

     Rust 也提供了 ~catch_unwind()~ 方法来让开发者捕获恐慌, 恢复当前线程. 但是,
     对于 13-44 中的非恐慌安全的 ~push_all()~ 函数来说, 若想捕获 ~clone()~ 方法
     可能引发的恐慌, 则需小心. 数组的长度已经确定, 但是还有未初始化的内存, 整改
     数据结构的不变性被破坏了. 所以 Rust 编译器也不会允许开发者在 ~push_all()~
     函数中使用 ~catch_unwind()~.
*** 堆内存分配
    在编写 Unsafe Rust 的过程中, 也需要手动进行堆内存分配, 所以 Rust 标准库
    ~std::alloc~ 模块中也提供了堆内存分配的相关 API.

    Rust 在 *1.28 之前* 默认都是使用 *jemalloc* 作为默认内存分配器, 虽然
    jemalloc 很强大, 但它也带来不少问题, 所以 Rust 1.28 中将 jemalloc 分配器 *从
    标准库中剥离* 了出来, 作为一个可选的第三方库而存在, *标准库默认分配器就是
    System 分配器*.

    在 ~std::alloc~ 模块中有一个 ~GlobalAlloc~ trait, 其源码如下所示:
    #+begin_src rust
      #[stable(feature = "global_alloc", since = "1.28.0")]
      pub unsafe trait GlobalAlloc {
          // 内存分配
          #[stable(feature = "global_alloc", since = "1.28.0")]
          unsafe fn alloc(&self, layout: Layout) -> *mut u8;

          // 内存释放
          #[stable(feature = "global_alloc", since = "1.28.0")]
          unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
      }
    #+end_src

    *注意*: GlobalAlloc 和其定义方法都用 unsafe 做了标记.
    要实现该 trait, *必须注意遵守以下约定*:

    - 若全局分配器发生了恐慌, 则会产生未定义行为
    - 布局(Layout)的查询和计算必须正确.
      
    这就意味着: 开发者可以通过该 trait 而指定自己的全局分配器.

    ~System.alloc~ 和 ~System.dealloc~ 是标准库默认的分配器.

    使用 ~#[global_allocator]~ 属性 就可以将静态变量 *GLOBAL* 指派的 MyAllocator
    声明为全局分配器.

    *注意*: ~#[global_allocator]~ 属性 *只能用于静态变量*.
*** 混合代码内存安全架构三大原则
    除了前面介绍的编码注意事项, 还有来自社区的指导 Safe 和 Unsafe Rust 代码混合
    编程中保证内存安全的三大原则:

    - 不安全的组件不应该削弱其安全性, 特别是公共的 API 和数据结构
    - 不安全的组件应该尽可能小, 并与安全组件分离(隔离和模块化)
    - 不安全的组件应该明确标记并轻松升级

** 和其他语言交互
   Common Lisp 语言规范中首次提出了术语 "*外部函数接口(Foreign Function
   Interface, FFI)*", 用于规范语言间调用的语言特征. 后来, 该属于也逐渐被引入到
   Haskell 和 Python 等大多数语言中. 也有个别语言使用其他属于, eg: Ada 语言使用
   "*语言绑定(Language Bindings)*", Java 语言则将 FFI 称为 *JNI(Java Native
   Interface)*.
   
   所以, 现在编程语言之间都是通过 FFI 技术来进行交互的.

*** 外部函数接口
    FFI 技术的主要功能就是将一种编程语言的 *语义* 和 *调用约定* 与另一种编程语言
    的语义和调用约定 *相匹配*.

    不管哪种语言, 无论是编译执行还是解释执行, 最终都会到达处理器指令这个环节. 在
    这个环节所处的层面上, 编程语言之间的语法、数据类型等语义差异均以消除, 只需要
    匹配调用约定, 这就给编程语言之间的相互调用带来了可能

**** 应用程序二进制接口
     调用约定如何匹配, 与 *应用程序二进制接口(ABI)* 高度相关
     
     ABI 是一个规范, 主要涵盖以下内容:
     - *调用约定*: 一个函数的调用过程本质就是参数、函数、返回值如何传递. 编译器
       按照调用规则去编译, 把数据放到相应的堆栈中, 函数的调用方和被调用方(函数本
       身)都需要遵循这个统一的约定
     - *内存布局*: 规定了大小和对齐方式
     - *处理器指令集*: 不同平台的处理器指令集不同
     - *目标文件和库的二进制格式*

     ABI 规范由编译器、操作平台、硬件产商等共同制定. ABI 是 *二进制层面程序兼容
     的契约, 只要拥有相同的 ABI, 来自不同编译器之间的库才可以相互链接和调用*, 否
     则将无法链接, 或者即使可以链接, 也无法正确运行.

     不同的体系结构、操作系统、编程语言、每种编程语言的不同编译器实现基本都有自
     己规定或者遵循的 ABI 和调用规范. 目前只能通过 FFI 技术遵循 C 语言 ABI 才可
     以做到编程语言的相互调用. 也就是说, C 语言 ABI 是唯一通用的稳定的标准 ABI.
     这是由历史原因决定的, C 语言伴随着操作系统一路发展而来, 导致其成为事实上的
     "标准 ABI".

     Rust 语言也提供了 ABI, 但因为 Rust 语言目前处于上升期, 语言还在不断地完善和
     改进, 导致 ABI 还不能够稳定下来, 在不久的将来, Rust ABI 应该是可以稳定的.
     Rust 提供了 FFI 技术, 允许开发者通过稳定的 C-ABI 和其他语言进行交互.

     相关不稳定讨论: [[https://people.gnome.org/~federico/blog/rust-stable-abi.html][gnome]], [[https://news.ycombinator.com/item?id=24140848][HackerNews]]
     
     在 Rust 中使用 FFI 只需要通过 *extern 关键字* 和 *extern 块* 对 FFI 接口进
     行标注即可. 在编译时会由 LLVM 默认生成 C-ABI.

**** 链接与 Crate Type
     有了统一的 ABI 之后, 还需要经过 *链接* 才能实现最终的相互调用.

     链接是将编译单元产生的目标文件按照特定的约定组合在一起, 最终生成可执行文件、
     静态库或动态库. 链接产生于程序开发的模块化. 这里的模块是指编译层面的模块.
     eg: C/C++ 语言中每个文件都是一个编译单元, 所以也可以说是一个编译模块, 编译
     之后就能产生一个目标文件. Rust 和 C/C++ 不同, 它以包(crate)为编译单元. 在一
     个 Rust 包中通过 extern crate 声明来引入其他包之后, 编译器支持各种方法可以
     将包链接在一起, 生成指定的可执行文件、动态库或静态库.

     在一个编译模块中, 通过包含了函数和全局数据的定义. 函数和数据由符号来标识,
     一般有全局和静态之分. 全局符号可以在模块间禁用, 而静态符号只能在当前模块引
     用. 编译各个模块的时候, 编译器的一项重要工作就是建立 *符号表*. 符号表中包含
     了模块的哪些符号是全局符号, 哪些是静态符号, 每个符号都会关联一个地址. 在链
     接过程汇总, 链接器会扫描各个编译模块的符号表, 建立全局符号表, 由此决定, 符
     号在哪里被定义, 以及在哪里被调用. 这个过程叫做 *符号解析*. 除此之外, 因为可
     执行文件和库的内存地址空间使用的差异, 还需要进行存储空间的分配. 地址重新分
     配之后, 相应符号的引用也需要重新被跳转, 这个过程叫做 *重定位*. 经过符号解析、
     存储空间分配和重定位之后, 链接过程就完成了, 最终生成可执行文件或库.

     从概念上看, 库可以分为 2 种: *静态库* 和 *动态库*.
     
     *静态库* 是这样一种库: 在功能上, 可以在链接时将引用的代码和数据复制到引用该
     库的程序中; 在格式上, 它只是普通目标文件的集合, 只是一种简单的拼接. 静态库
     使用简单, 原理上容易理解, 但是它容易浪费空间. *动态库* 和静态库差异比较大.
     动态库可以把链接这个过程延迟到运行时进行, eg: 重定位发生在运行时而非编译时.
     动态库相对来说比较省空间.

     除可执行文件外, Rust 一共支持 4 种库:
     
     | crate_type | Rust  | 其他语言  |
     |------------+-------+-----------|
     | 动态库     | dylib | cdylib    |
     | 静态库     | rlib  | staticlib |

     可以通过命令行参数 *Flag* 或者 *crate_type* 属性指定生成的库类型:

     - ~--crate-type=bin~ 或 ~#[crate_type="bin"]~: 表示将生产一个可执行文件. 要
       求程序中必须包含一个 main 函数.

     - ~--crate-type=rlib~ 或 ~#[crate_type="rlib"]~: 可以理解为静态 Rust 库, 由
       Rust 编译器来使用

     - ~--crate-type=dylib~ 或 ~#[crate_type="dylib"]~: 可以理解为动态 Rust 库,
       同样由 Rust 编译器来使用. 该类型在 Linux 上会创建 ~*.so~ 文件, 在 MacOSX
       上会创建 ~*.dylib~ 文件, 在 Windows 上会创建 ~*.dll~ 文件.

     - ~--crate-type=staticlib~ 或 ~#[crate_type="staticlib"]~: 将生产静态系统库.
       Rust 编译器永远不会链接该库, 主要用于和 C 语言进行连接, 达成和其他语言交
       互的目的. 静态系统库在 Linux 和 MacOSX 上会创建 ~*.a~ 文件, 在 Windows 上
       会创建 ~*.lib~ 文件.

     - ~--crate-type=cdylib~ 或 ~#[crate_type="cdylib"]~: 将生产动态系统库. 同样
       用于生成 C 接口, 和其他语言交互. 该类型在 Linux 上会创建 ~*.so~ 文件, 在
       MacOSX 上会场景 ~*.dylib~ 文件, 在 Windows 上会创建 ~*.dll~ 文件.

     *注意*: *crate_type 可以指定多个*. 有时候会有以下情况: 包 A 依赖包 B, 包 B
     需要生成一个 staticlib 静态系统库. 这时, 就需要为包 B 同时指定 staticlib 和
     rlib 两种包类型.

     只要 ABI 统一, 两个库就可以相互链接. 链接之后, 就可以实现相互调用. 所以,
     Rust 要和其他语言交互, 可以通过导出为 C-ABI 接口的静态库或动态库, 然后其他
     语言链接该库, 就可以实现语言之间的相互调用.

**** 交叉编译
     以上说的是本地编译的情况, Rust 也支持 *交叉编译*, 几乎做到了开箱即用. 在本
     地平台上编译出需要放在其他平台运行的程序, 就叫交叉编译.

     #+begin_src sh
       rustc --target=arm-unknown-linux-gnueabihf hello.rs
     #+end_src
     
     输入后即可工作. 若是针对 ARM 嵌入式开发平台, 不能使用 std 标准库(因为 std
     不支持 ARM 单片机).

     #+begin_src rust
       #![crate_type="lib"]
       #![no_std]
       fn main() {
           println!("Hello, world!");
       }
     #+end_src

     嵌入式推荐的做法是使用 *core*.

     也可以使用 Cargo 进行交叉编译. 给 ~cargo build~ 命令传递 ~--target~ 参数即
     可. 默认情况下, cargo 命令会使用 cc 作为交叉编译器的链接器. 也可以通过修改
     Cargo 的配置文件来指定链接器.

     使用 cargo 进行交叉编译示意
     #+begin_src sh
       # 通过配置文件指定链接器
       cat ~/.cargo/config
       [target.arm-unknown-linux-gnuabihf]
       linker = "arm-linux-gnueabihf-gcc-4.8"
       # 使用 cargo 交叉编译
       cargo new --bin hello
       cd hello
       cargo build --target=arm-unknown-linux-gnueabihf
     #+end_src

     以上示例中, target 参数后面的格式称为 *target triple* 格式. Triple 格式是交
     叉编译前必须要确认好的, 格式含义如下:
     
     详见: [[https://doc.rust-lang.org/nightly/rustc/platform-support.html][platform-support]]

     #+begin_example
       {arch}-{vendor}-{sys}-{abi}
     #+end_example

     - arch: 代表编译程序的主机系统, 若是嵌入式, 就是 arm
     - vendor: 供应商, 若是位置, 就可以指定为 unknow
     - sys: 系统, eg: Linux
     - abi: ABI 接口, eg: gnueabihf 表示的是系统使用 glibc 作为 C 标准库(libc)的
       实现, 并具有硬件加速浮点运算(FPU)功能. 有时候也可以省略最后的 abi, eg2:
       x86_64-apple-darwin, wasm32-unknown-unknown 等.
       
     Rust 社区还提供了第三方交叉编译工具 *xargo*, 使用该工具可以更方便地进行交叉
     编译, 还允许开发者构建一个定制的 std 库. 当前, Rust 官方着手进行 xargo 和
     rustup 工具的整合.

**** extern 语法
     Rust 提供了 extern 语法使得 FFI 非常便于使用

     - *extern 关键字*: 通过 extern 关键字声明的函数, 可以在 Rust 和 C 语言中自
       由使用
     - *extern 块*: 如果在 Rust 中调用 C 代码, 则可以使用 extern 块, 将外部的 C
       函数进行逐个标记, 以供 Rust 内部调用.

     编译器会根据 extern 语法自动在 Rust-ABI 和 C-ABI 之间切换. 有 3 个 extern
     ABI 字符串是跨平台的:
     - ~extern "Rust"~: 默认的 ABI, 任何普通的 fn 函数都将使用该 ABI
     - ~extern "C"~: 这是指定使用 C-ABI, 等价于 ~extern fn foo()~ 这样的函数声明
     - ~extern "system"~: 这和 ~extern "C"~ 是相似的, 只是在 Win32 平台上等价于
       ~stdcall~.

     除此之外, Rust 还支持其他 extern ABI 字符串, 详情可以参见官方 [[https://doc.rust-lang.org/reference/items/external-blocks.html][Reference]] 页
     面. 另外还有三个 Rust 编译器专用的 ABI 字符串:
     - ~extern "rust-intrinsic"~: 代表 Rust 编译器内部函数的 ABI
     - ~extern "rust-call"~: ~Fn::call~ 的 ABI
     - ~extern "platform-intrinsic"~: 特定平台内在函数的 ABI     

*** 与 C/C++ 语言交互
    C 语言这种万能 "胶水" 语言赋予了 Rust 和其他语言通信的能力.
    
    Rust 中可以方便无缝地调用 C 函数, 所以对于现有的操作系统和一些 C/C++ 实现的
    底层系统库, 可以使用 Rust 进行安全无缝地绑定和扩展, 达到从 C/C++ 向 Rust 迁
    移的目的, 甚至也可以让 Rust 和 C/C++ 协同工作. eg: 把系统中堆安全要求高的部
    分迁移到 Rust, 其余部分继续用 C/C++, 保留原始的性能.

    通过 C-ABI, Rust 也可以被其他语言调用. 一般用于提升动态语言的性能, eg: Ruby、
    Python、Node.js 等. 可以把系统中造成性能瓶颈的部分用 Rust 来重写, 然后通过
    FFI 在动态语言中调用
    
**** 在 Rust 中调用 C 函数
     使用 ~extern "C"~ 块内部定义的函数签名, 可以直接使用. 也可以省略 "C", 默认
     的 extern 块就是按 C-ABI 处理的.
     
**** 在 Rust 中调用 C++ 函数
     Rust 中也可以调用 C++ 函数, 前提是 C++ 也需要使用 C-ABI.

     Cargo.toml 中添加了 build.rs 文件配置, 以及 build 依赖库 *cc*.
     
     Rust 中想要调用 C/C++, 首先需要连接 C/C++ 生成的静态/动态库. 可以通过手动调
     用 gcc/g++ 来编译 C/C++ 文件, 使用 *ar* 工具来生成静态库. 但是现在制作 Rust
     的 crate, 这些工作需要自动化. 所以这里要利用 *build.rs* 文件, 在 Rust 构建
     之前, 将依赖的 C/C++ 库打包好. 构建依赖的库 *cc* 是对 gcc 等各大平台 C/C++
     编译器的抽象.

     安全性讨论见: [[https://github.com/ZhangHanDong/tao-of-rust-codes/issues/290][issue]]

     cc 库可以更方便地进行编译操作和处理过程.

     若不使用 cc 库, 也可以在 build.rs 文件中使用 ~Command::new("g++")~ 等命令来
     自动化编译 C++ 文件的过程.

**** 补充: Rust 中调用 C 函数的意外问题
     使用 printf 等函数时不会立即输出, 使用 fflush 强制缓冲区更新才会输出.
     
     讨论见: [[https://www.366service.com/cn/qa/e831adcaca21c70b155e6419cdcf8987][为什么Rust函数和FFI C函数按反向顺序执行]]

     代码见: ~13.3.rustcallc~

**** 在 C 中调用 Rust 函数
     在 C 中调用 Rust 函数中的思路同样也是通过静态库或动态库进行链接的.

     gcc/clang 参数说明:
     - ~-I~: 增加 include 搜索目录(引入.h 等文件)
     - ~-L~: 增加 lib 搜索目录
     - ~l~: 指定 lib 名称

**** 类型匹配与内存布局
     前面的演示代码中, 没有展示 Rust 和 C 相互传递参数的情况. 实际上, 在开发
     Rust 和 C 相互调用的程序时, 根本无法避免相互传递参数. 所以, 在需要传递参数
     的情况下, 必须保证参数的类型和内存布局可以满足调用约定.

     Rust 的 Char 类型和 C 的 Char 类型完全不同, 在 Rust 中 Chai 类型是一个
     Unicode 标量值, 但 C 中 Char 只是一个普通的整数. Rust 标准库在
     ~std::os::raw~ 模块中提供了与 C 语言中各种类型匹配的映射类型. eg: ~c_char~
     类型, 其实就是 ~i8~ 类型的别名. 所以 ~hm_chars~ 的函数可以标注为
     ~std::os_raw~ 模块中的 ~c_char~ 类型.

     libc 库也提供了对 C 中基本数据类型的映射. 通常情况下, ~std::os::raw~ 模块或
     libc 都没有什么区别, 但 libc 库 *不依赖 std*.

     在 Rust 函数内部进行处理的时候, 需要转换成 Rust 中的字符串类型. 为了方便转
     换, Rust 标准库 ~std::ffi~ 模块中提供了 *CStr* 类型, 该类型会产生一个 ~\0~
     字符数组的引用. 所以在使用时, 先通过 ~CStr::from()~ 函数将 ~c_char~ 字符类
     型转成 Rust 可用的 ~CStr~ 类型. 当然, 要判断传入的字符串是否为空.

     牢记原则: *谁分配(申请), 谁释放*.
     
     ~#[repr(C)]~ 属性可以标明内存布局兼容 C-ABI.

     若要在 C 和 Rust 之间需要传递更加复杂的类型, 可以使用 C 语言中的 *不透明数
     据类型(Opaque) 和 Rust 中的 ~Box<T>~ 相对应*.

     *注意*: 对于 13-83 代码的 Database 结构体, 没有使用 ~#[repr(C)]~ 来保证内存
     布局是 C-ABI 兼容的. *因为在 C 代码中, 要使用抽象的结构体类型与其相对应, 并
     非一个具体的结构体类型*. 这种抽象的结构体类型叫做 *不透明数据类型*.

     将 Database 的结构体示例放到堆内存, 是为了 *拥有稳定的内存地址*, 因此传递给
     C 使用是 *安全的*.
     
**** 第三方工具介绍
     在编写 Rust 中调用 C 函数的代码时, 重复最多的工作就是在 extern 块中声明外部
     哈数接口. 而在 C 中调用 Rust 的代码时, 重复最多的工作就是在头文件中增加外部
     函数接口.

     于是社区中出现了一些工具可以帮助开发者自动完成以下这些工作:
     - *rust-bindgen*: 该库可以根据头文件自动生成 Rust FFI 的 C 绑定, 也支持部分
       C++ 功能
     - *cbindgen*: 该库可以根据 Rust 代码自动生成头文件
     - *ctest*: 该库可以为 Rust FFI 的 C 绑定自动生成测试文件

     针对移动平台的库推荐:
     - *cargo-lipo*: 提供 cargo lipo 命令, 自动生成用于 iOS 的通用库
     - *jni*: 提供 Rust 的 JNI 绑定, 用于和 Android 平台交互

     Rust 用于 iOS/Android 平台时, 涉及交叉编译, 要注意设置相关的 target 格式.

*** 使用 Rust 提升动态语言性能
    使用 Rust 可以为动态语言编写本地扩展. 在 Rust 诞生之前, 普遍使用 C/C++ 为动
    态语言编写扩展, 但是存在内存安全风险, 甚至引起内存泄漏. 使用 Rust 为动态语言
    编写扩展, 既可以保证性能, 还能提升内存安全.
    
    动态语言都有自己的虚拟机, 所以调用 Rust 代码不可能像 C/C++ 那样直接链接 Rust
    的链接库获取相关的函数调用信息. 所以, 动态语言提供的 FFI 基本都是基于
    *libffi* 库来实现动态调用 C 函数的能力, 兼容 C-ABI 的链接库都可以直接被动态
    调用. 该 libffi 库是动态语言虚拟机和二进制的一道桥梁.

    TODO...

** Rust 与 WebAssembly
   *WebAssembly* 是近两年兴起的一种 *新的字节码格式*, 它的缩写是 "WASM". 这种格
   式背后的意义在于, 在某种程度上, 它将改变整个 web 的生态. 所以, Rust 2018 的重
   点发展目标之一就是简历针对便于开发 WebAssembly 的生态工具.

   WebAssembly 项目是 Google、MicroSoft、Mozilla 等多家公司联合发起的一个面向
   Web 的通用二进制和文本格式项目. 它的出现并不是为了让开发者手写代码, 而是作为
   C/C++/Rust 语言的一种编译目标, 这样就产生了一个巨大的意义: *在客户端提供了一
   种接近本地允许速度的多种语言编写代码的方式*. 在某种意义上, WebAssembly 相当于
   一种 *中间语言(IR)*. 其实 WebAssembly 的名词也由此而来, 就像汇编语言那样是所
   有语言转换成机器码的通用底层语言, WebAssembly 就是面向 Web 的汇编.

   目前 WebAssembly 的重要应用领域是浏览器中配合 JavaScript API 提升前端应用的性
   能, 虽然 JavaScript 目前有很多优化的手段, 效果也不错, 但是它的计算性能还是很
   慢, 对于一些计算密集型场景, 就可以使用 WebAssembly 来替代. eg: 游戏的渲染引擎、
   物理引擎, 图像音频/视频的处理和编辑、加密算法等.

   WebAssembly 比 JavaScript 更快地原因主要体现在以下几个方面:

   - WebAssembly 体积更小, 下载和解析更快. WebAssembly 的二进制格式就是为了更适
     合解析而设计, 其解析速度要比 JavaScript 快一个数量级
   - WebAssembly 不受 JavaScript 的约束, 可以利用更多的 CPU 特性. eg: 64 位整数、
     内存读写偏移量、非内存对齐读写和多种 CPU 指令等
   - 生成 WebAssembly 编译器工具链的优化和改进. eg: 在 Rust 中, 可以使用 wasm-gc
     工具来优化生成的 wasm 文件的大小
   - WebAssembly 不需要垃圾回收. 内存操作是手动控制, 但也没必要担心内存泄露的问
     题, 因为 WebAssembly 使用的整个内存空间是由 JavaScript 分配的, 它实际上是一
     个 JavaScript 对象, 最终会由 JavaScript 的 GC 去管理


   *警告*: 内容有改动
   同时, WebAssembly 还在不断地朝着执行效率更高的方向发展. 目前 WebAssembly 还不
   支持 DOM 操作, 但是已经有了解决方案, 就是依赖 [[https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md][Reference Types]] 和 Host
   Bindings[疑似废弃] 技术在 WebAssembly 中直接操作 JavaScript + DOM 对象和调用
   其方法.

   *WebAssembly* 名称虽然包含了 Web, 但其发展至今, *已经不仅仅局限于 Web*. 为了
   将 WebAssembly 嵌入到不同的环境中, 其 *规范* 是被拆分到了独立的文档中, 并区分
   了层级:

   - *核心层*: 定义 WebAssembly 模块及其指令集的语义
   - *API 层*: 定义应用程序接口, 目前指定了 2 个 API: JavaScript API 和 Web API.

   由此可看出, WebAssembly *是独立于 Web 的规范, Web 只是其应用的特定环境*. 事实
   上, WebAssembly 还应用于除 Web 之外的其他领域: 桌面图形化程序、区块链智能合约
   和编写操作系统内核.

   随着该技术的发展, 将会应用到更多领域.

*** WebAssembly 要点介绍
    为了理解 WebAssembly 的工作机制, 需要了解如下关键概念:
    - *模块*: 模块是 WebAssembly 的基本编译单位, 一个 .wasm 文件就是一个模块. 其
      中定义了各种函数, 可以被 JavaScript 加载调用.
    - *线性内存*: 用于和 JavaScript 通信, 是一个可变大小的 ArrayBuffer, 由
      JavaScript 分配. WebAssembly 提供了对其进行操作的指令.
    - *表格*: 用于存放函数应用, 支持动态调用函数
    - *实例*: 一个模块的实例包括其在运行时使用的所有状态, eg: 内存、表格和一系列
      的值. 同一个模块的多个实例可以共享相同的内存和表格
    - *栈式机器*: WebAssembly 指令的运行是基于栈式机器定义的, 每种类型的指令都是
      在栈上进行出栈和入栈操作

**** 文本格式 wast
     WebAssembly 模块提供 2 种格式: *二进制* 和 *文本格式*. 其中文本格式是基于
     *S 表达式*, 供人类读写, 所以也称为 *wast*. 文本格式和二进制格式也可以通过工
     具相互转换.

     详见 MDN: [[https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format][理解 WebAssembly 文本格式]]

     #+begin_src wat
        (module
          (func $add (param $lhs i32) (param $rhs i32) (result i32)
            get_local $lhs
            get_local $rhs
            i32.add)
          (export "add" (func $add))
        )
     #+end_src

     每一对括号都代表一个 *节点*. 括号内第一个元素是代表节点的类型, 后面由空格分
     隔的是数学或子节点列表. 以上代码一共可以分成三大节点: *module*, *func* 和
     *export*. 其中, module 表示模块, func 代表函数, export 是指将模块内定义的函
     数导出.

     函数签名 ~$add~ 中, ~$~ 符开头可以为参数、函数名或局部变量等起名. 除了导出/
     导出的指令, 模块中几乎所有的代码都被划分到函数中. 由 func 定义的函数签名中
     包含的头两个 param 节点是表示函数的参数, 均为 i32 类型. 最后一个 result 节
     点代表函数的返回值为 i32 类型.

     函数体中, ~get_local~ 指令是用于获取参数的值, 最后调用 ~i32.add~ 操作, 表示
     将 2 个 i32 类型的参数进行相加, 该操作是 WebAssembly 内置的运算符([[https://webassembly.github.io/spec/core/exec/index.html][更多文档]]).
     wasm 文件执行是以 *栈式机器* 定义的, *get_local* 指令会将它读到的参数值压到
     栈上, 然后 ~i32.add~ 从栈上取出两个 i32 类型的值进行求和, 将计算结果压到栈
     顶.

     export 节点是一个导出声明. 在 export 指令后面的 "add" 是指定给 JavaScript
     用的函数名.

     文本格式的 WebAssembly 代码构建为 wasm 后, 使用如下代码导入:
     #+begin_src js
       // 1. 导入文件
       fetch('../out/main.wasm').then(response =>
         // 通过 arrayBuffer 获取
         response.arrayBuffer()
         // 2. 编译并实例化
       ).then(bytes => WebAssembly.instantiate(bytes)).then(results => {
         instance = results.instance;
         // 3. 使用导出方法
         document.getElementById("container").textContent = instance.exports.add(1,1);
       }).catch(console.error);
     #+end_src

**** 使用 WebAssembly 内存和 JavaScript 交互
     因为 WebAssembly 当前只支持 i32、i64、f32 和 f64 这四种可用的基本类型, 所以,
     为了处理字符串以及其他复杂的类型, WebAssembly 提供了内存. WebAssembly 的
     *内存实际上一种可增长的线性字节数组*, 由 JavaScript *通过
     ~WebAssembly.Memory~ 接口来创建*.

     #+begin_src wat
       (module
         ;; 导入 JavaScript 的方法或对象供 WebAssembly 使用.
         ;; 导入 console.log 方法, 起名为 $log
         (import "console" "log" (func $log (param i32 i32)))
         ;; 导入由 JavaScript 创建的内存, 并且指定了内存至少为 1 页(64KB)
         ;; 导入的函数签名会被 WebAssembly 进行静态检查
         (import "js" "mem" (memory 1))
         ;; 使用 data 指令把数据写入到内存中
         ;; "(i32 const 0)" 用于指定在线性内存中放置数据的偏移量, 0 表示起始位置
         (data (i32.const 0) "Hi WASM,")
         ;; 把另一个字符串存入内存中, 偏移量为 8 (因为第一个字符串长度为 8, 起始为 0)
         ;; 避免冲突, 防止覆盖字符串
         (data (i32.const 8) "I'm Coming")
         ;; 导出 writeHi 函数给 JavaScript 调用
         (func (export "writeHi")
           i32.const 0
           i32.const 18
           ;; 调用了由 JavaScript 导入的 $log 函数
           call $log
         )
       )
     #+end_src

     以上代码一共包含三种主要的节点: *import*, *data* 与 *func*.

     重写 main.js
     #+begin_src js
       // 分配指定的 1 页内存
       var memory = new WebAssembly.Memory({ initial: 1 });

       function consoleLogString(offset, length) {
         // 对 wasm 内存中的字符串进行解码
         var bytes = new Uint8Array(memory.buffer, offset, length);
         var string = new TextDecoder('utf8').decode(bytes);
         console.log(string);
       }

       // 用于导入到 wasm 中使用的 log 方法和内存.
       // 与 wat 文本格式代码中的两个 import 节点相对应
       var importObject = {
         console: {
           log: consoleLogString
         },
         js: {
           mem: memory
         }
       }

       // 通过该方法直接从底层进行流式源码编译和实例化模块, 这是加载 wasm 最有效、最优化的方法
       WebAssembly.instantiateStreaming(
         fetch('../out/main.wasm'), importObject
       ).then(obj => {
         obj.instance.exports.writeHi();
       })
     #+end_src

     因 wasm 中的字符串只是 *原始的字节*, *只有通过解码才能在 js 中使用*.

     通过 *WebAssembly.instantiateStreaming* 方法可直接从底层进行流式源码编译和
     实例化模块, 是加载 wasm 最有效、最优化的方法.

**** 表格与动态链接
     表格和内存相似， 只不过表格是必须通过索引才能获取的可变大小的数组. 在日常开
     发中, 经常需要动态调用一些函数. 而这些函数不能直接存储在内存中, 因为内存会
     把存储的原始内容作为字节暴露出去. 如果函数存储在内存中, wasm 就可以任意查看
     和修改原始函数地址, *这是极度不安全的行为*. 所以, *在表格中存储函数引用, 然
     后返回表格的索引*, 通常为 i32 类型. 通过 *call_indirect* 指令可以调用索引值,
     从而达到调用函数的目的.

     多个 wasm 可以实现动态链接, 模块实例可以共享相同的内存和表格. 通过内存和表
     格, 就可以实现 JavaScript 和 wasm 的基本互操作.
     
     shared0.wat:
     #+begin_src wat
       (module
         (import "js" "memory" (memory 1))
         ;; 导入由 JavaScript 定义的表格, 1 代表初始大小, 表示该表中将存储一个函数引用
         ;; anyfunc 代表 "任意签名的函数"
         (import "js" "table" (table 1 anyfunc))
         (elem (i32.const 0) $shared0func)
         (func $shared0func (result i32)
           ;; 创建常数 0
           i32.const 0
           ;; 该指令从内存中获取存储到常数 0 位置的值, 获取回来的值会被放到栈顶(也就是该函数返回值)
           i32.load)
         )
     #+end_src

     shared1.wat:
     #+begin_src wat
       (module
         (import "js" "memory" (memory 1))
         (import "js" "table" (table 1 anyfunc))
         ;; 创建函数类型, 用于在后续的表格引用调用时进行类型检查
         (type $void_to_i32 (func (result i32)))
         (func (export "doIt") (result i32)
           ;; 以下操作指令将常量 42 存储到索引为 0 的内存中
           i32.const 0
           i32.const 42
           i32.store
           ;; 等价于从表格中获取索引为 0 的函数调用
           ;; 该函数引用正是 shared0.wat 中所存储的 $shared0func
           i32.const 0
           call_indirect (type $void_to_i32)
         )
       )
     #+end_src

*** 使用 Rust 开发 WebAssembly
    手写 wat 文本格式开发 wasm 的效率显然不会很高. WebAssembly 设计之初也是作为
    一种编译目标而存在的, 它可以作为很多编程语言的编译目标.

    - C/C++: 可以通过 *EmScripten* 工具来编译到 wasm. EmScripten 是一个 LLVM 后
      端工具, 可以将 LLVM 中间码编译到 asm.js. 所以, C/C++ 的编译流程是通过任何
      一个 LLVM 前端工具(eg: Clang)生成 LLVM IR, 然后通过 EmScripten 生成
      asm.js, 最后通过一个 WebAssembly 编译工具链 Binaryen 将 asm.js 生成 wasm
      二进制格式. 其中 asm.js 是 JavaScript 的一个子集, 可以说它是 WebAssembly
      的雏形. 在一些不支持 wasm 的浏览器中, 也可以使用 asm.js 来代替.
    - Rust: 支持 wasm 的两种编译目标
      + wasm32-unknown-unknown: 使用的是 LLVM WebAssembly Backend 和 lld 链接器
      + wasm32-unknown-emscripten: 会继续使用 EmScripten, 和 C/C++ 类似

    使用以下命令可以安装工具链:
    #+begin_src sh
      rustup target add wasm32-unknown-unknown --toolchain nightly
    #+end_src
    
    通过 ~cargo install wasm-gc~ 安装 wasm-gc 工具进行优化大小, 不过随着 lld 链
    接器的进一步完善, 增加了 *链接时优化(LTO)* 功能就不再需要使用 wasm-gc.
    
*** 打造 WebAssembly 开发生态
    即使是使用 Rust 编写代码再编译为 wasm, 开发效率还是比较低. WebAssembly 标准
    自定义了四种类型: 两种数字和两种浮点数. 在大多数情况下, 这四种类型完全不够用.
    因此, Rust 官方大招了以 wasm-bindgen 为首的一系列工具, 旨在提升 Rust 开发
    wasm 的体验. 这一系列工具重点包括:

    - wasm-bindgen: 核心是促进 JavaScript 和 Rust 之间使用 wasm 进行通信. 它允许
      开发者直接使用 Rust 的结构体、JavaScript 的类、字符串等类型, 而不仅仅是
      wasm 支持的整数或浮点数. 开发者只需要专注于业务.
    - wasm-pack: 一站式构建、发布 Rust 编译 wasm 到 npm 平台.
    - cargo-generate: 直接生成 wasm-bindgen 和 wasm-pack 项目模板, 方便开发.

    Rust 官方对 Rust 和 WebAssembly 的愿景: *希望可以更方便地使用 Rust 开发
    wasm*, *并且不需要改变现有开发流程*.

    wasm-bindgen 致力于为 JavaScript 生态和 Rust crate 生态系统建立共享的基础.
    wasm-bindgen 通过内置的 *js-sys* 包提供了对所有全局 JavaScript API 的绑定,
    只需通过 ~wasm_bindgen::js~ 即可调用. 同样, 通过内置的 *web-sys* 包提供了对
    所有 Web API 的绑定, 方便开发者调用.

    
